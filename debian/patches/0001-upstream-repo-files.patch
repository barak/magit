From: "Barak A. Pearlmutter" <barak+git@pearlmutter.net>
Date: Tue, 1 Sep 2015 16:54:29 +0100
Subject: upstream repo files

Take some files from upstream repo tag 2.4.1 which are not present in
the 2.4.1 distributed tarball.  To whit:

/CONTRIBUTING.md (documentation)
/Documentation/*.org (complete sources for .info files)
/Documentation/RelNotes/* (complete upstream changelog)
/t/* (allow "make test" at build time)

Origin: git://github.com/magit/magit.git tag 2.2.1
Forwarded: not-needed
---
 CONTRIBUTING.md                  |   55 +
 Documentation/RelNotes/0.5.1.txt |   11 +
 Documentation/RelNotes/0.6.1.txt |   24 +
 Documentation/RelNotes/0.7.0.txt |   70 +
 Documentation/RelNotes/0.8.0.txt |   55 +
 Documentation/RelNotes/0.8.1.txt |   28 +
 Documentation/RelNotes/0.8.2.txt |   27 +
 Documentation/RelNotes/1.0.0.txt |   84 +
 Documentation/RelNotes/1.1.0.txt |  112 +
 Documentation/RelNotes/1.1.1.txt |   25 +
 Documentation/RelNotes/1.1.2.txt |   33 +
 Documentation/RelNotes/1.2.0.txt |   73 +
 Documentation/RelNotes/1.2.1.txt |   15 +
 Documentation/RelNotes/1.2.2.txt |   17 +
 Documentation/RelNotes/1.4.0.txt |  231 ++
 Documentation/RelNotes/1.4.1.txt |   31 +
 Documentation/RelNotes/1.4.2.txt |   23 +
 Documentation/RelNotes/2.1.0.txt |  446 ++++
 Documentation/RelNotes/2.2.0.txt |  235 ++
 Documentation/RelNotes/2.2.1.txt |   45 +
 Documentation/RelNotes/2.2.2.txt |   45 +
 Documentation/RelNotes/2.3.0.txt |  264 ++
 Documentation/RelNotes/2.3.1.txt |   31 +
 Documentation/RelNotes/2.4.0.txt |  156 ++
 Documentation/RelNotes/2.4.1.txt |   31 +
 Documentation/magit-popup.org    |  590 +++++
 Documentation/magit.org          | 5426 ++++++++++++++++++++++++++++++++++++++
 Documentation/with-editor.org    |  259 ++
 t/magit-tests.el                 |  263 ++
 29 files changed, 8705 insertions(+)
 create mode 100644 CONTRIBUTING.md
 create mode 100644 Documentation/RelNotes/0.5.1.txt
 create mode 100644 Documentation/RelNotes/0.6.1.txt
 create mode 100644 Documentation/RelNotes/0.7.0.txt
 create mode 100644 Documentation/RelNotes/0.8.0.txt
 create mode 100644 Documentation/RelNotes/0.8.1.txt
 create mode 100644 Documentation/RelNotes/0.8.2.txt
 create mode 100644 Documentation/RelNotes/1.0.0.txt
 create mode 100644 Documentation/RelNotes/1.1.0.txt
 create mode 100644 Documentation/RelNotes/1.1.1.txt
 create mode 100644 Documentation/RelNotes/1.1.2.txt
 create mode 100644 Documentation/RelNotes/1.2.0.txt
 create mode 100644 Documentation/RelNotes/1.2.1.txt
 create mode 100644 Documentation/RelNotes/1.2.2.txt
 create mode 100644 Documentation/RelNotes/1.4.0.txt
 create mode 100644 Documentation/RelNotes/1.4.1.txt
 create mode 100644 Documentation/RelNotes/1.4.2.txt
 create mode 100644 Documentation/RelNotes/2.1.0.txt
 create mode 100644 Documentation/RelNotes/2.2.0.txt
 create mode 100644 Documentation/RelNotes/2.2.1.txt
 create mode 100644 Documentation/RelNotes/2.2.2.txt
 create mode 100644 Documentation/RelNotes/2.3.0.txt
 create mode 100644 Documentation/RelNotes/2.3.1.txt
 create mode 100644 Documentation/RelNotes/2.4.0.txt
 create mode 100644 Documentation/RelNotes/2.4.1.txt
 create mode 100644 Documentation/magit-popup.org
 create mode 100644 Documentation/magit.org
 create mode 100644 Documentation/with-editor.org
 create mode 100644 t/magit-tests.el

diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 0000000..5c45ab1
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,55 @@
+<p align="center">
+  <img src="http://magit.vc/img/L.png" align="left">
+  <img src="http://magit.vc/img/R.png" align="right">
+  <b>
+    When something doesn't work as expected, then please first consult the
+    <a href="http://magit.vc/manual/magit/FAQ.html">FAQ</a> and ask a
+	search engine.   If that doesn't solve your problem, then please ask for help on
+    <a href="http://emacs.stackexchange.com/questions/tagged/magit"> Emacs.Stackexchange</a>.
+  </b>
+</p>
+***
+
+Getting help
+============
+
+**When something doesn't work as expected then please first see the
+[FAQ][faq].** Then also try the list of [open issues][issues] and use
+the search box at the top of that page to find older related issues.
+You should also consult the [manual][manual] and ask a general-purpose
+search engine.
+
+If everything else fails then ask for help on the
+**[Emacs Stackexchange site][forum]**, the
+[mailing list][list], or the
+[Gitter chat][chat].
+
+Reporting issues and suggesting features
+========================================
+
+To report bugs and suggest new feature use the [issue tracker][issues].
+
+Never use the phrase "at the very least".
+
+Code contributions
+==================
+
+If you have some code which you would like to be merged, then open a
+[pull request][pulls].  Please create atomic commits with descriptive
+commit messages.
+
+Donations
+=========
+
+Please also consider to contribute by making a
+[monetary donation][donations].
+
+
+[chat]:      https://gitter.im/magit/magit
+[donations]: http://magit.vc/donations.html
+[faq]:       http://magit.vc/manual/magit/FAQ.html
+[forum]:     http://emacs.stackexchange.com/questions/tagged/magit
+[issues]:    https://github.com/magit/magit/issues
+[list]:      https://groups.google.com/forum/?fromgroups#!forum/magit
+[manual]:    http://magit.vc/manual
+[pulls]:     https://github.com/magit/magit/pulls
diff --git a/Documentation/RelNotes/0.5.1.txt b/Documentation/RelNotes/0.5.1.txt
new file mode 100644
index 0000000..d08cdb0
--- /dev/null
+++ b/Documentation/RelNotes/0.5.1.txt
@@ -0,0 +1,11 @@
+Magit v0.5.1 Release Notes
+==========================
+
+This is the first release of Magit.  Enjoy!
+
+Released 14 August 2008 by Marius Vollmer.
+
+Authors
+-------
+
+   157  Marius Vollmer
diff --git a/Documentation/RelNotes/0.6.1.txt b/Documentation/RelNotes/0.6.1.txt
new file mode 100644
index 0000000..a58c3ba
--- /dev/null
+++ b/Documentation/RelNotes/0.6.1.txt
@@ -0,0 +1,24 @@
+Magit v0.6.1 Release Notes
+==========================
+
+Released 16 October 2008 by Marius Vollmer.
+
+Changes since v0.5.1
+--------------------
+
+Almost everything has changed.  Some highlights:
+
+ * Magit now works with Git 1.6.0.  (John Wiegley)
+
+ * Support for interactive rewriting.
+
+ * Sections can be shown and hidden.
+
+ * Staging, unstaging, applying, reverting and discarding changes can
+   now be done line-by-line, not only hunk-by-hunk.
+
+Authors
+-------
+
+   212  Marius Vollmer
+     -  John Wiegley
diff --git a/Documentation/RelNotes/0.7.0.txt b/Documentation/RelNotes/0.7.0.txt
new file mode 100644
index 0000000..9191804
--- /dev/null
+++ b/Documentation/RelNotes/0.7.0.txt
@@ -0,0 +1,70 @@
+Magit v0.7.0 Release Notes
+==========================
+
+Released 8 March 2009 by Marius Vollmer.
+
+Changes since v0.6.1
+--------------------
+
+ * Tagging, on 't' and 'T'.
+
+ * Stashing, on 'z' and 'Z'.
+
+ * Wazzup, on 'w'.  Wazzup gives you an overview over how other
+   branches relate to the current one.
+
+ * There is more control over pushing.  'P' now takes a prefix argument
+   and pushing a branch without a default remote will ask for one.
+
+ * Logs have changed a bit: 'l' shows the traditional brief log, and
+   'L' shows a more verbose log.  Use the prefix arg to specify the
+   range of the log.
+
+ * M-x magit-status doesn't prompt anymore for a directory when invoked
+   from within a Git repository.  Use C-u to force a prompt.
+
+ * When you have nothing staged, 'c' will now explicitly ask whether to
+   commit everything instead of just going ahead and do it.  This can
+   be customized.
+
+ * The digit keys '1', '2', '3', and '4' now show sections on the
+   respective level and hide everything below.  With Meta, they work on
+   all sections; without, they work only on sections that are a parent
+   or child of the current section.
+
+ * Typing '+' and '-' will change the size of hunks, via the "-U"
+   option to git diff.  '0' resets hunks to their default size.
+
+ * Typing 'k' on the "Untracked files" section title will offer to
+   delete all untracked files.
+
+ * Magit understands a bit of git-svn: the status buffer shows unpushed
+   and unpulled commits, 'N r' runs git svn rebase, and 'N c' runs git
+   svn dcommit.
+
+ * Magit now also works when the direcory is accessed via tramp.
+
+ * M-x magit-status can also create new repositories when given a
+   directory that is not a Git repository.
+
+ * Magit works better with oldish Gits that don't understand "--graph",
+   for example.
+
+ * The name of the Git program and common options for it can be
+   customized.
+
+Authors
+-------
+
+   107  Marius Vollmer
+    18  John Wiegley
+     9  Alexey Voinov
+     5  Marcin Bachry
+     3  Rémi Vanicat
+     2  Alex Ott
+     2  René Stadler
+     2  Steve Purcell
+     1  Daniel Farina
+     1  David Wallin
+     1  Ian Eure
+     1  Jesse Alama
diff --git a/Documentation/RelNotes/0.8.0.txt b/Documentation/RelNotes/0.8.0.txt
new file mode 100644
index 0000000..538f09a
--- /dev/null
+++ b/Documentation/RelNotes/0.8.0.txt
@@ -0,0 +1,55 @@
+Magit v0.8.0 Release Notes
+==========================
+
+Released 7 May 2010 by Phil Jackson.
+
+Changes since v0.7.0
+--------------------
+
+ * By setting magit-repo-dirs, you can get better repo completion.
+   Magit will offer all subdirectories (upto magit-repo-dirs level
+   deep) of the listed directories when magit-status asks for a
+   directory to work on.  You can get the old behavior with a double
+   prefix to magit-status.
+
+ * Hitting 'c' or 'C' while resolving a conflict in the middle of a
+   rebase will offer to continue the rebase instead of trying to commit
+   your changes.
+
+ * Pulling will ask which branch to pull from when you don't have a
+   default branch configured.
+
+ * Switching to a remote branch will offer to create a local tracking
+   branch for it.
+
+ * Hitting C-c C-s while editing a commit message will toggle the
+   "--signoff" option.
+
+ * Hitting 's' on the "Untracked files" section title will stage all
+   untracked files.
+
+ * Hitting 'C-u S' will stage all untracked and tracked files.
+
+ * Performance improvements in the status buffer.
+
+ * Bug fixes to make Magit work better with newer Gits.
+
+Authors
+-------
+
+    66  Phil Jackson
+    53  Marius Vollmer
+    27  Rémi Vanicat
+     7  Alexey Voinov
+     5  Hannu Koivisto
+     5  Roger Crew
+     4  John Wiegley
+     4  Moritz Bunkus
+     3  Ben Walton
+     2  Marcin Bachry
+     2  Óscar Fuentes
+     1  David Abrahams
+     1  Leo Liu
+     1  Pavel Holejsovsky
+     1  Ramkumar Ramachandra
+     1  Steve Purcell
diff --git a/Documentation/RelNotes/0.8.1.txt b/Documentation/RelNotes/0.8.1.txt
new file mode 100644
index 0000000..95b204f
--- /dev/null
+++ b/Documentation/RelNotes/0.8.1.txt
@@ -0,0 +1,28 @@
+Magit v0.8.1 Release Notes
+==========================
+
+Released 10 June 2010 by Phil Jackson.
+
+Changes since v0.8.0
+--------------------
+
+ * New library `rebase-mode.el'.  Edit Git rebase files.
+
+ * New commands `magit-log-all' and `magit-log-first-parent'.
+
+ * New command `magit-git-command'.  Run any Git command.
+
+ * `magit-remote-update' learned to fetch just the current remote.
+
+ * `magit-tag' learned to place the tag on something other than HEAD.
+
+Authors
+-------
+
+    55  Phil Jackson
+     7  Rémi Vanicat
+     7  Ævar Arnfjörð Bjarmason
+     4  Natalie Weizenbaum
+     2  Ramkumar Ramachandra
+     1  Mark Hepburn
+     1  Moritz Bunkus
diff --git a/Documentation/RelNotes/0.8.2.txt b/Documentation/RelNotes/0.8.2.txt
new file mode 100644
index 0000000..9367486
--- /dev/null
+++ b/Documentation/RelNotes/0.8.2.txt
@@ -0,0 +1,27 @@
+Magit v0.8.2 Release Notes
+==========================
+
+Released 10 July 2010 by Phil Jackson.
+
+Changes since v0.8.1
+--------------------
+
+ * Use shorter more human readable representations for refs.
+
+ * Optionally show refs for remote branches the way Git would.
+
+ * Tell VC to update the mode-line for us.
+
+Authors
+-------
+
+    21  Phil Jackson
+    18  Natalie Weizenbaum
+     2  Alan Falloon
+     2  Moritz Bunkus
+     2  Rémi Vanicat
+     1  Alex Ott
+     1  Leo Liu
+     1  Sean Bryant
+     1  Ævar Arnfjörð Bjarmason
+     1  Óscar Fuentes
diff --git a/Documentation/RelNotes/1.0.0.txt b/Documentation/RelNotes/1.0.0.txt
new file mode 100644
index 0000000..92f9175
--- /dev/null
+++ b/Documentation/RelNotes/1.0.0.txt
@@ -0,0 +1,84 @@
+Magit v1.0.0 Release Notes
+==========================
+
+Released 23 March 2011 by Phil Jackson.
+
+Changes since v0.8.2
+--------------------
+
+ * New library `magit-key-mode.el'.  From a popup buffer dispatch
+   Magit/Emacs commands which wrap Git commands and select the
+   arguments passed to Git.  Group various sets of related commands
+   in new menus and adjust them accordingly.
+
+ * New library `magit-svn.el' based on code previously in `magit.el'.
+   Improve the implementation.  Control `git svn' from Magit.
+
+ * New library `magit-topgit.el' based on code previously in
+   `magit.el'.  Improve the implementation.  Control TopGit from Magit.
+
+ * Provide a wrapper for `completing-read'.  Support using iswitchb to
+   do completion.
+
+ * Fixed and improved information shown during a rebase.
+
+ * New macro `magit-define-inserter' to define functions which insert
+   sections.
+
+ * New macro `magit-add-action'.  A hook-like extension mechanism for
+   commands that behave differently based on the type of the section
+   at point.
+
+ * New macro `magit-define-command'.  Like `defun' but also define
+   a hook in addition to the function/command.  If a hook function
+   succeeds do not run the function body as passed to this macro.
+
+ * New commands `magit-add-change-log-entry'
+   and `magit-add-change-log-entry-other-window'.
+
+ * New command `magit-change-what-branch-tracks'.
+
+ * New commands `magit-run-git-gui' and `magit-run-gitk'.
+
+ * Various new submodule commands.
+
+ * Various new branch commands.
+
+ * Various new log commands.  Remove some old log commands.
+
+ * Make reflog commands more like the log commands.
+
+ * Numerous bugfixes and tweaks.
+
+Authors
+-------
+
+   197  Phil Jackson
+    27  Natalie Weizenbaum
+    25  Óscar Fuentes
+    22  Moritz Bunkus
+    20  Rémi Vanicat
+    17  Aaron Culich
+    10  Timo Juhani Lindfors
+     8  Ramkumar Ramachandra
+     8  Ævar Arnfjörð Bjarmason
+     6  Yann Hodique
+     5  Hannu Koivisto
+     5  Julien Danjou
+     5  Peter J. Weisberg
+     4  Leo Liu
+     3  Robin Green
+     2  Brian Warner
+     2  Christian Kluge
+     2  Marc Herbert
+     1  Andreas Fuchs
+     1  Chris Bernard
+     1  David Abrahams
+     1  Dominique Quatravaux
+     1  John Wiegley
+     1  Paul Stadig
+     1  Philip Weaver
+     1  Remco van 't Veer
+     1  Robert Boone
+     1  Rüdiger Sonderfeld
+     1  Tom Feist
diff --git a/Documentation/RelNotes/1.1.0.txt b/Documentation/RelNotes/1.1.0.txt
new file mode 100644
index 0000000..0e1c1fb
--- /dev/null
+++ b/Documentation/RelNotes/1.1.0.txt
@@ -0,0 +1,112 @@
+Magit v1.1.0 Release Notes
+==========================
+
+Released 23 December 2011 by Yann Hodique.
+
+Changes since v1.0.0
+--------------------
+
+ * Added distinct faces for various different kinds of refs.
+
+ * Completely redesigned existing faces.
+
+ * Added library `magit-classic-theme.el' for users who like the old
+   faces better.
+
+ * Share many more key bindings between all Magit modes.  Previously
+   many commands were only available in certain buffers, even though
+   they are useful in all Magit buffers.
+
+ * Added library `magit-simple-keys.el' for users who don't like the
+   popups.
+
+ * Added support for using Ido to do completion.
+
+ * Added support for Ediff.
+
+ * Added shell script `magit'.
+
+ * Added library `magit-bisect.el'.
+
+ * Added library `magit-stgit.el'.
+
+ * Added mode `magit-svn-mode'.
+
+ * Added mode `magit-topgit-mode'.
+
+ * Added mode `magit-rebase-mode'.
+
+ * Added buttons to commit buffer to cylce to commits which were
+   previously shown.  The commands are `magit-show-commit-backward'
+   and `magit-show-commit-forward.
+
+ * Defined backward compatibility implementations of some Emacs
+   functions.
+
+ * Type changes are now shown in diffs.
+ 
+ * Added option `magit-set-upstream-on-push'.
+
+ * Added option `magit-default-tracking-name-function'.
+
+ * Added option `magit-log-auto-more'.
+
+ * Added option `magit-create-branch-behaviour'.
+
+ * Added option `magit-status-buffer-switch-function'.
+
+ * Added option `magit-rewrite-inclusive'.
+
+ * Added options `magit-highlight-trailing-whitespace' and
+   `magit-highlight-indentation'.
+
+ * Added command `magit-show'.  Visit REVISION:FILE.
+
+ * Added command `magit-delete-branch-forced'.
+
+ * Added command `magit-log-edit-toggle-author'.
+
+ * `magit-reset-working-tree' learned to remove untracked files.
+
+ * `magit-push' learned to set the upstream branch.
+
+Authors
+-------
+
+   152  Peter J. Weisberg
+    55  Yann Hodique
+    18  Phil Jackson
+    18  Pieter Praet
+    18  Rémi Vanicat
+    12  Moritz Bunkus
+    10  Lluís Vilanova
+     8  Eli Barzilay
+     7  Nicolas Dudebout
+     6  Roger Crew
+     5  Štěpán Němec
+     3  David Abrahams
+     3  Hannu Koivisto
+     3  Jeff Bellegarde
+     3  Rüdiger Sonderfeld
+     2  Alan Falloon
+     2  Andreas Rottmann
+     2  Andrew Kirkpatrick
+     2  Craig Andera
+     2  Jasper St. Pierre
+     1  Andrey Smirnov
+     1  Bastian Beischer
+     1  Chris Moore
+     1  Daniel Brockman
+     1  Eric Davis
+     1  George Kadianakis
+     1  Kimberly Wolk
+     1  Luke Amdor
+     1  Luís Borges de Oliveira
+     1  Marc Herbert
+     1  Marco Craveiro
+     1  Ramkumar Ramachandra
+     1  Steve Purcell
+     1  Thomas Jost
+     1  Tibor Simko
+     1  Tom Feist
+     1  Ævar Arnfjörð Bjarmason
diff --git a/Documentation/RelNotes/1.1.1.txt b/Documentation/RelNotes/1.1.1.txt
new file mode 100644
index 0000000..21b3baf
--- /dev/null
+++ b/Documentation/RelNotes/1.1.1.txt
@@ -0,0 +1,25 @@
+Magit v1.1.1 Release Notes
+==========================
+
+Released 14 January 2012 by Yann Hodique.
+
+Changes since v1.1.0
+--------------------
+
+ * `magit-svn-get-local-ref' learned to expand branch specs containing
+   braces.
+
+ * `magit-log-edit' learned to amend and create commits with no message.
+
+ * Several other fixes and improvements.
+
+Authors
+-------
+
+     6  Nicolas Dudebout
+     6  Yann Hodique
+     1  Graham Clark
+     1  Justin Caratzas
+     1  Peter J. Weisberg
+     1  Ryan C. Thompson
+     1  Timo Juhani Lindfors
diff --git a/Documentation/RelNotes/1.1.2.txt b/Documentation/RelNotes/1.1.2.txt
new file mode 100644
index 0000000..2c5aea2
--- /dev/null
+++ b/Documentation/RelNotes/1.1.2.txt
@@ -0,0 +1,33 @@
+Magit v1.1.2 Release Notes
+==========================
+
+Released 23 September 2012 by Yann Hodique.
+
+Changes since v1.1.1
+--------------------
+
+ * Modes now have proper mode-line lighters.
+
+ * Hook variables are now defined semi-explicitly.
+
+ * Uninteresting refs are no longer shown in logs.
+
+ * The deprecated `assoc' libary is no longer used.
+
+ * Several other fixes and improvements.
+
+Authors
+-------
+
+    13  Yann Hodique
+     9  Peter J. Weisberg
+     2  Jonas Bernoulli
+     2  Ramkumar Ramachandra
+     1  Bradley Wright
+     1  Bryan Shell
+     1  Damien Cassou
+     1  Eric Davis
+     1  John Wiegley
+     1  Nic Ferier
+     1  Nick Alcock
+     1  Rémi Vanicat
diff --git a/Documentation/RelNotes/1.2.0.txt b/Documentation/RelNotes/1.2.0.txt
new file mode 100644
index 0000000..b27f259
--- /dev/null
+++ b/Documentation/RelNotes/1.2.0.txt
@@ -0,0 +1,73 @@
+Magit v1.2.0 Release Notes
+==========================
+
+Released 23 September 2012 by Yann Hodique.
+
+Changes since v1.1.2
+--------------------
+
+ * Rewrote the branch manager.
+
+ * Diffs are optionally refined using `diff-refine-hunk'.
+
+ * Added library `magit-blame.el' defining new mode
+   `magit-blame-mode'.
+
+ * Added library `magit-wip.el' defining new modes
+   `magit-wip-save-mode' and `magit-wip-mode'.
+
+ * New section movement commands; `magit-goto-next-sibling-section'
+   and `magit-goto-previous-sibling-section'.
+
+ * Added command `magit-file-log'.
+
+ * Added command `magit-manual-merge'.
+
+ * `magit-delete-branch-force' was merged into `magit-delete-branch'.
+
+ * `magit-move-branch' learned to force the rename.
+
+ * `magit-reset-working-tree' learned to remove ignored files.
+
+ * `magit-pull' learned to set `branch.BRANCH.merge'.
+
+ * `magit-log-edit' learned to respect GIT_AUTHOR_EMAIL,
+   GIT_AUTHOR_NAME and GIT_AUTHOR_DATE.
+
+ * `magit-visit-item' learned to visit untracked files, diffs and
+   hunks.
+
+ * Added option `magit-sha1-abbrev-length'.
+
+Authors
+-------
+
+   157  Yann Hodique
+    61  Nicolas Dudebout
+    14  Peter J. Weisberg
+    12  Jonas Bernoulli
+    10  Ryan C. Thompson
+     7  Miles Bader
+     6  Damien Cassou
+     5  Samuel Bronson
+     4  Dale Hagglund
+     4  Eli Barzilay
+     4  Takafumi Arakaki
+     4  rabio
+     3  Leonardo Etcheverry
+     3  Nick Alcock
+     3  Rémi Vanicat
+     3  Rüdiger Sonderfeld
+     2  Graham Clark
+     2  Hans-Peter Deifel
+     2  Moritz Bunkus
+     1  Andreas Liljeqvist
+     1  Christian Dietrich
+     1  Christopher Monsanto
+     1  Daniel Hackney
+     1  Hannu Koivisto
+     1  John Wiegley
+     1  Jonathan Roes
+     1  Ole Arndt
+     1  Ron Parker
+     1  Suhail Shergill
diff --git a/Documentation/RelNotes/1.2.1.txt b/Documentation/RelNotes/1.2.1.txt
new file mode 100644
index 0000000..6e255bf
--- /dev/null
+++ b/Documentation/RelNotes/1.2.1.txt
@@ -0,0 +1,15 @@
+Magit v1.2.1 Release Notes
+==========================
+
+Released 23 May 2014 by Jonas Bernoulli.
+
+Changes since v1.2.0
+--------------------
+
+ * `magit-delete-directory' was rewritten to deal with an incompatible
+   change in `delete-directory' in Emacs v24.4.
+
+Authors
+-------
+
+     1  Jonas Bernoulli
diff --git a/Documentation/RelNotes/1.2.2.txt b/Documentation/RelNotes/1.2.2.txt
new file mode 100644
index 0000000..e529dc9
--- /dev/null
+++ b/Documentation/RelNotes/1.2.2.txt
@@ -0,0 +1,17 @@
+Magit v1.2.2 Release Notes
+==========================
+
+Released 23 October 2014 by Jonas Bernoulli.
+
+Changes since v1.2.1
+--------------------
+
+ * `magit-delete-directory' uses itself when deleting recursively,
+   instead of `org-delete-directory' which it was copied from.
+
+ * Many byte-compile warnings were addressed.
+
+Authors
+-------
+
+     5  Jonas Bernoulli
diff --git a/Documentation/RelNotes/1.4.0.txt b/Documentation/RelNotes/1.4.0.txt
new file mode 100644
index 0000000..f0f8d9e
--- /dev/null
+++ b/Documentation/RelNotes/1.4.0.txt
@@ -0,0 +1,231 @@
+Magit v1.4.0 Release Notes
+==========================
+
+Released 1 April 2015 by Jonas Bernoulli.
+
+This release sits in the middle of a commit marathon that lasted for
+more than 4700 commits.
+
+When I became Magit's new maintainer during the summer of 2013 Magit
+was already a big success, but underneath its shiny surface it was
+having some serious problems.  Over the years the source had gotten
+very disorganized and many old abstractions were no longer sufficient.
+Unfortunately existing code had almost never been adjusted when new
+features had been added, leading to a lot of new code that worked
+around limitations of existing code.
+
+This was clearly not sustainable in the long run, and so I started
+cleaning up and replacing the existing abstractions with simpler, yet
+often more powerful implementations.  Unfortunately his had to happen
+incrementally as it was seldom possible to cleanup one area without
+making substantial changes elsewhere.  Along the way I also addressed
+many of the hundreds of feature requests, but that was more of a bonus
+- the focus was on getting the codebase ready for future improvements.
+
+At the beginning of 2014 I moved development to the new next branch.
+Working on a branch which was not used by thousands of Melpa users
+allowed me to move faster and users were no longer affected by the
+occasional regression.  But it also meant that I now had to maintain
+two branches.  In hindsight I should have released the master branch
+as 1.3.0 at that time, despite all the known defects it had.
+
+Since then I have finished the cleanup on the next branch and then
+moved on to implement many new features.  On the master branch the
+focus was on bugfixes and the occasional backport.  This release is
+based on the master branch.  Later this spring 2.1.0 will be released
+based on the next branch.
+
+Compiling a list of all changes in 1.4.0 would by a major amount of
+work in itself, so instead the below list is for the most part limited
+to major changes, which enabled the user visible changes.  Many users
+don't have to be told about the new features anyway - they have been
+using them for more than a year now.
+
+Changes since v1.2.2
+--------------------
+
+ * The libraries `magit-topgit.el', `magit-stgit.el', and
+   `magit-svn.el' all reincarnated as separate repository.
+
+ * The libraries `magit-classic-theme.el' and `magit-simple-keys.el',
+   which allowed users to undo some of the changes in older releases,
+   were removed.
+
+ * The library `rebase-mode.el' was renamed to `git-rebase-mode.el'
+   and moved to the `magit/git-modes' repository.
+
+ * The library `magit-log-edit-mode.el' was removed and replaced with
+   `git-commit-mode.el' from the `magit/git-modes' repository.
+
+ * The functionality provided by the library `magit-bisect.el' was
+   replaced with a new implementation in `magit.el'.
+
+ * The package `cl-lib` is now used instead of the obsolete `cl'.
+
+ * The library `magit.el' no longer lacks any recognizable structure.
+
+ * The macro `magit-define-command' was removed.
+   The hook that was defined in addition to the command only served
+   to make things more complicated and the generated doc-string was
+   insufficient.
+
+ * The use of "section actions" has been reduced to a minimum.
+   Commands that behave differently depending on the type of the
+   current section still use `magit-section-case' or in some cases
+   even `magit-section-action', but the preferred way for users to
+   add new variants now is to add a new command to the type-specific
+   section keymap, instead of the hooks defined by
+   `magit-section-action'.
+
+ * More work is done directly in `magit-with-section'.
+   Most of the helper functions were removed.  These functions
+   were not intended to be used directly, but that did not keep
+   contributors from doing so, leading to many inconsistencies.
+
+ * The mode machinery was massively refactored.
+   Most importantly the new macro `magit-mode-setup' was added,
+   replacing the old `magit-mode-init' which forgoes most of the
+   things each and every of its callers has to do, which let to many
+   inconsistencies
+
+ * The refresh machinery was massively refactored.
+   A refresh now has to be requested more explicitly by either calling
+   `magit-refresh' or one of the functions that call Git and then the
+   former.  Also, refreshing now more often correctly preserves point.
+
+ * Washing diffs now takes less cycles.
+   Previously the code used to wash diffs was very complicated.  It
+   passed around state using many dynamically bound variables, and
+   called `git diff' many times.  Now we call `git diff' once and then
+   wash its output in one go.
+
+ * Commits and stashes are now washed using the regular diffwasher.
+
+ * Low-level functions for running Git were massively refactored, and
+   many new variants were added.  Previously many callers had to deal
+   with the gory details themselves (and usually did it badly).
+
+ * The output from processes is now logged in a dedicated buffer.
+   From this buffer it's also possible to kill a running process.
+
+ * The Wazzup buffer was massively refactored.
+   All options to optionally make it faster were removed, as it is now
+   faster out-of-the-box without sacrificing any functionality at all.
+
+ * Many more competing abstractions were unified.
+   It was common to have one no longer sufficient core abstraction, and
+   several competing wrapper abstractions.  In most cases this has been
+   replaced with a single, less complex implementation, which serves all
+   of the current use cases.
+
+ * Refreshing "after a asynchronous process has run" now happens after
+   the process has actually finished.  That was always the intention,
+   but not what actually used to happen.
+
+ * The commit message is no longer provided when calling `git commit'.
+   Instead Git populates a file with a template and then uses $EDITOR
+   to have the user edit that.  This did not work so well for a while
+   but now we succeed in having the emacsclient being used as $EDITOR.
+
+ * A new Branch Manager was added.
+
+ * Log learned to show optionally show author information in the
+   margin.
+
+ * Terminology with regards to what a tracking branch is, was fixed.
+
+ * When creating a new branch the default choice is what Git would
+   default to, instead of some silly name.
+
+ * Tools used to test whether Git supports certain features was removed.
+   Instead we now require a non-ancient version of Git.
+
+ * The shell script `magit' reincarnated as a separate repository.
+
+Authors
+-------
+
+  1838  Jonas Bernoulli
+   171  Yann Hodique
+   121  Pieter Praet
+    59  Rémi Vanicat
+    24  Nicolas Dudebout
+    21  Takafumi Arakaki
+    16  acple
+    14  Phil Jackson
+    13  Rüdiger Sonderfeld
+    12  Mitchel Humpherys
+     8  Servilio Afre Puentes
+     7  Ramkumar Ramachandra
+     7  Teruki Shigitani
+     6  Lluís Vilanova
+     6  Sergey Vinokurov
+     5  Thierry Volpiatto
+     4  Moritz Bunkus
+     4  Noam Postavsky
+     4  Seong-Kook Shin
+     3  Laurent Laffont
+     3  Leonardo Etcheverry
+     3  Loic Dachary
+     3  Raimon Grau
+     3  Sébastien Gross
+     2  Bastian Beischer
+     2  Damien Cassou
+     2  Evgkeni Sampelnikof
+     2  Greg A. Woods
+     2  Greg Sexton
+     2  Jesse Alama
+     2  Leandro Facchinetti
+     2  Nguyễn Tuấn Anh
+     2  Nick Alexander
+     2  Pekka Pessi
+     2  Philippe Vaucher
+     2  Rafael Laboissiere
+     2  Sebastian Wiesner
+     1  Abdo Roig-Maranges
+     1  Adam Spiers
+     1  Andrei Chițu
+     1  Andrew Schwartzmeyer
+     1  Brandon W Maister
+     1  Chris Done
+     1  Chris Ring
+     1  Christopher Monsanto
+     1  Cornelius Mika
+     1  Dan LaManna
+     1  David Hull
+     1  Dennis Paskorz
+     1  Divye Kapoor
+     1  Eric Schulte
+     1  Felix Geller
+     1  Feng Li
+     1  Geoff Shannon
+     1  Jan Tatarik
+     1  Jeff Dairiki
+     1  John Wiegley
+     1  Jordan Greenberg
+     1  Kyle Meyer
+     1  Lele Gaifax
+     1  Manuel Vázquez Acosta
+     1  Marcel Wolf
+     1  Marian Schubert
+     1  Matus Goljer
+     1  Nick Dimiduk
+     1  Nicolas Richard
+     1  Peter J. Weisberg
+     1  Philipp Haselwarter
+     1  Prathamesh Sonpatki
+     1  Romain Francoise
+     1  Roy Crihfield
+     1  Sanjoy Das
+     1  Sergey Pashinin
+     1  Steve Purcell
+     1  Steven Chow
+     1  Steven Thomas
+     1  Thomas Frössman
+     1  Thomas Riccardi
+     1  Ting-Yu Lin
+     1  Wilfred Hughes
+     1  Win Treese
+     1  York Zhao
+     1  aaa707
+     1  Ævar Arnfjörð Bjarmason
diff --git a/Documentation/RelNotes/1.4.1.txt b/Documentation/RelNotes/1.4.1.txt
new file mode 100644
index 0000000..15dc747
--- /dev/null
+++ b/Documentation/RelNotes/1.4.1.txt
@@ -0,0 +1,31 @@
+Magit v1.4.1 Release Notes
+==========================
+
+Released 12 April 2015 by Jonas Bernoulli.
+
+This is a bugfix release.
+
+Changes since v1.4.0
+--------------------
+
+ * The external library `magit-log-edit.el' is no longer supported.
+   If it is still installed, then instruct the user to remove it.
+
+ * The function `magit-maybe-show-setup-instructions' is now run even
+   when `magit' has not been loaded by the time `after-init-hook' ran.
+
+ * Invalid `:package-version' keywords in option definitions were
+   fixed.  In some cases the value was "2.1.0" instead of "1.4.0".
+
+ * Some unnecessary obsolete-variable definitions were removed.
+
+ * Running tests on Travis CI was fixed.
+
+ * The Makefile, README.md, and release notes received minor fixes
+   and cleanup.
+
+Authors
+-------
+
+     9  Jonas Bernoulli
+     1  Noam Postavsky
diff --git a/Documentation/RelNotes/1.4.2.txt b/Documentation/RelNotes/1.4.2.txt
new file mode 100644
index 0000000..b50f1a8
--- /dev/null
+++ b/Documentation/RelNotes/1.4.2.txt
@@ -0,0 +1,23 @@
+Magit v1.4.2 Release Notes
+==========================
+
+Released 8 June 2015 by Jonas Bernoulli.
+
+This is a bugfix release.
+
+Changes since v1.4.1
+--------------------
+
+ * Automatic revers of file-visiting buffers now works again in Emacs
+   version 24.5.  It was broken due to an incompatible change in that
+   Emacs release.
+
+ * Git's reflogs sometimes end with bogus entries.  We now work around
+   that when listing stashes.
+
+Authors
+-------
+
+    11  Jonas Bernoulli
+     1  Peter Vasil
+     1  Steven E. Harris
diff --git a/Documentation/RelNotes/2.1.0.txt b/Documentation/RelNotes/2.1.0.txt
new file mode 100644
index 0000000..0331193
--- /dev/null
+++ b/Documentation/RelNotes/2.1.0.txt
@@ -0,0 +1,446 @@
+It's Magit!  A Git Porcelain inside Emacs
+=========================================
+
+Magit is an interface to the version control system Git, implemented
+as an Emacs package.  Magit aspires to be a complete Git porcelain.
+While we cannot (yet) claim that Magit wraps and improves upon each
+and every Git command, it is complete enough to allow even experienced
+Git users to perform almost all of their daily version control tasks
+directly from within Emacs.  While many fine Git clients exist, only
+Magit and Git itself deserve to be called porcelains.
+
+For more information about Magit, see http://magit.vc.
+
+Magit v2.1.0 Release Notes
+==========================
+
+Released 1 July 2015 by Jonas Bernoulli.
+
+This release marks the end of a commit marathon that lasted for more
+than 4700 commits.  It is the first major release in over two and a
+half years.  The last major release was 1.2.0, which was released
+under old leadership.  Version 1.4.0, which I released earlier this
+year, for the most part consisted of changes that prepared for this
+release (so you might want to read the respective release notes too).
+
+This release comes with many new and exciting features, but the most
+important change is the massive increase in consistency both in the
+user interface and the internal abstractions.
+
+Magit always provided a very intuitive staging interface, which is
+vastly superior to `git add --interactive'.  This release extends this
+to other apply variants.  Starting with this release, other areas have
+also begun to be more than just incremental improvements over what Git
+itself provides.  But this is still limited to certain features which
+have gotten more attention than others (most prominently rebasing).
+
+Interlude
+---------
+
+The code base is finally in a state that allows me to concentrate on
+implementing my vision of what version control could be like.  But
+this will only be possible if, unlike during the last two and a half
+years, I am being paid for my work.
+
+I intend to run a fund-raising campaign, but you can already donate
+now (see http://magit.vc/donations.html).  I am also looking for
+corporate sponsorship and/or employment.  One area where Magit
+actually lags behind other Git clients is integration with Git hosting
+platforms and code review tools.  I hope that these platforms have an
+interest in being supported by the best Git client and are willing to
+pay for it.
+
+I am very interested in a job that would let me work on Magit *and* on
+other projects, which would benefit from the skills I have acquired
+integrating two complex systems and dealing with all the social and
+technical challenges that arise when running a popular project.
+
+Changes since v1.4.0
+--------------------
+
+ * A new manual has been added.  It's much more comprehensive than the
+   old manual and instead of just documenting the various commands and
+   options, it also explains concepts and plumbing functions, and
+   comes with extensive indices for commands, functions, and options.
+
+   Actually three new manuals were added; the packages `magit-popup'
+   and `with-editor' are documented in separate manuals.
+
+   The manuals are written in Org mode and then exported to Texinfo.
+
+ * Performance is much better now.  In most cases this was achieved by
+   delaying work until it is actually needed.  Most importantly diffs
+   are only partially washed until being fully expanded.  Some
+   features come in a fancy and in a fast variant; when that is the
+   case, we now usually default to the fast variant.
+
+ * Many options can now be set on a per-repository basis, and the
+   manual describes how to do so.  (Actually this was always possible
+   but, because it was undocumented, nobody did it.)  It's possible to
+   define "repository classes", e.g. "huge repositories", and then add
+   the respective repositories to that class.  This is very useful in
+   order to turn off certain features only in repositories where they
+   would have a negative impact on performance, without having to do
+   it for each repository individually.
+
+ * Many faces have been simplified.  Most importantly, section heading
+   faces no longer set a background color (except for hunk headings)
+   and instead just use the default background.  Refname faces no
+   longer set the background color or the box property.
+
+ * Many, probably the majority of, functions, variables, and faces
+   have been renamed, which was necessary because there was very
+   little consistency before.
+
+   Most importantly, the names of commands and options now begin with
+   a prefix that includes the name of the respective git sub-command.
+   For example, the names of all commands and options related to
+   diffing now begin with `magit-diff-'.
+
+   Many plumbing functions and variables were also renamed.  In some
+   cases, that also lead to shared prefixes, such as `magit-process-',
+   `magit-mode-', `magit-git-', and `magit-insert-'.  But many
+   plumbing functions and variables continue to use names whose only
+   common part is the `magit-' prefix.
+
+   Future renames will be performed at well defined times and obsolete
+   function/variable definitions will be provided for backward
+   compatibility.  No renames are planned at present.
+
+ * The external libraries `git-commit-mode.el' and `git-rebase-mode.el'
+   are no longer required and have to be uninstalled because they
+   conflict with their successors `git-commit.el' and `git-rebase.el',
+   which are now maintained inside the Magit repository instead of the
+   Git-Modes repository.
+
+   The library `git-commit.el' can be used without Magit, so it is
+   distributed as a separate Elpa package.  However, `git-rebase.el'
+   now depends on several Magit libraries and is therefore distributed
+   as part of the `magit' package.
+
+ * The library `magit-key-mode.el' was removed and replaced with
+   `magit-popup.el'.  The new implementation is much more flexible and
+   easier to use than the old one.  Major new features include setting
+   default arguments directly inside the popup and macros for defining
+   new popups and extending existing popups.
+
+   This new library can also be used by packages that are not related
+   to Magit and is therefore available as a separate Elpa package.
+
+ * The library `with-editor.el' was added.  Its purpose is to use the
+   emacsclient as $GIT_EDITOR when git is started as a subprocess and
+   requires an editor.  This is used while committing and rebasing.
+   This also works over Tramp, where a "sleeping editor" shell script
+   is used to communicate over standard output instead of a socket
+   like the emacsclient does.
+
+   The `1.4.0' release already supported this, but this release splits
+   this feature into a separate library.  And now that it is a separate
+   library, it can also be used by packages that are not related to
+   Magit.  `with-editor.el' is distributed as a separate Elpa package.
+
+ * All libraries are now located in the new `lisp/' subdirectory.
+
+ * The library `magit.el' has been split into many new libraries.
+   The code base is now much better organized.  Together with the
+   description of plumbing commands in the manual, this should make it
+   much easier for contributors to get started.
+
+ * The library `magit-wip.el' has been rewritten from scratch and no
+   longer depends on the external and unmaintained shell script from
+   https://github.com/bartman/git-wip.
+
+ * There are now three different modes that commit to the
+   work-in-progress refs before/after certain events, and in addition
+   to the old working tree wip refs, these modes now also commit to
+   index wip refs.  When these new modes are turned on, Git's
+   protection of committed (but dangling) changes is effectively
+   extended to uncommitted changes (which some exceptions).  These
+   modes are not enabled by default due to performance concerns.
+
+ * The library `magit-blame.el' has been rewritten from scratch.  The
+   new implementation can blame recursively, jump to the next/previous
+   chunk from the same commit, replace headings with separator lines,
+   scroll the revision buffer for the chunk at point (like log buffers),
+   and fine-tune the arguments for `git blame' using a popup.
+
+ * The new library `magit-ediff.el' replaces the old Ediff support.
+   The new implementation comes with a dwim command and a popup, and
+   it relies less on high-level functions provided by VC and Ediff
+   itself, because many of those turned out to be unsuitable.
+
+ * The popular third-party library `dash.el' is now required.  This
+   is the only mandatory external dependency now, except for Git and
+   Emacs themselves, of course.
+
+ * When using Ido inside Magit, users now have to install the
+   third-party library `ido-completing-read+.el'.  This is necessary
+   because the function `ido-completing-read', which is part of the
+   built-in library `ido.el', is not a sufficient drop-in replacement
+   for `completing-read'.
+
+ * The new macro `magit-insert-section' replaces `magit-with-section'.
+   The macros `magit-cmd-insert-section' and `magit-git-insert-section'
+   were removed without a direct replacement.
+
+ * The new functions `magit-insert' and `magit-put-face-property' take
+   care of working around the fact that negative overlay priorities
+   are not supported, i.e., that overlays always take precedence
+   against text properties.  Previously this was done in various
+   places, and not always correctly (e.g., in some cases overlays did
+   not evaporate).
+
+ * The section visibility and movement commands were rewritten from
+   scratch.  All those commands now share the prefix `magit-section-'
+   and edge cases are handled better.  New commands were added that
+   allow cycling the visibility of sections and their children.  From
+   a user perspective Magit's section handling is now quite similar to
+   that of Org mode.
+
+ * The macro `magit-section-action' was removed.  The related macro
+   `magit-section-case' still exists and will continue to do so.  The
+   action variant provided user-customizable hooks, but these hooks
+   were rarely, if ever, used.  Instead of such action hooks, users who
+   wish to extend Magit now have to use type-specific section keymaps.
+
+ * Section highlighting was rewritten from scratch.  The new
+   implementation uses hooks to allow washing certain section types
+   differently than others - without obfuscating the simple cases.
+   Washing diffs is much more complicated than washing all other
+   sections, and that part has been factored out.  The washing of
+   all other section types is now quite simple.
+
+ * The appearance of the region now indicates whether it is valid as a
+   selection.  As far as Magit is concerned, valid selections are hunk
+   internal regions and regions that mark sibling sections of the same
+   type.  When a region does not satisfy one of these, then it is
+   displayed the sames as in other buffers and Magit cannot act on it.
+
+ * The new option `magit-no-confirm' makes it easy to forgo having to
+   confirm potentially dangerous actions.  Many of these actions are
+   only dangerous for users who don't know how to undo them.  When the
+   wip modes are turned on, many more previously fatal actions can be
+   easily undone.  Adding `safe-with-wip' here makes it unnecessary to
+   confirm these actions.
+
+ * The new Refs buffer combines the features of the old Wazzup and
+   Branch Manager buffers into one, more powerful and efficient
+   synthesis.  For each reference, cherries can be shown by expanding
+   the ref section, but unlike in the Wazzup buffer, the cherries are
+   not calculated until the expansion happens, making it vastly more
+   efficient.  Besides local and remote branches, the buffer now also
+   lists tags, and users can add additional sections listing other
+   refs, e.g., stashes.  The format of refs headers is now
+   customizable.
+
+ * File-visiting buffers are now reverted without using code from the
+   built-in `autorevert.el` library.  The function we previously used
+   was intended for internal use only and indeed, changes made there
+   broke Magit in the past.
+
+ * The new option `magit-revert-buffers' controls whether and how
+   buffers visiting tracked files are reverted.  As before, such
+   buffers are reverted by default.  But by default this is now done
+   rather noisily to encourage users to read the doc-string and
+   pick what is right for them.  It's now also possible to revert
+   asynchronously and for the user to be asked every time there are
+   buffers that could be reverted.  This option replaces
+   `magit-auto-revert-mode`.
+
+ * Many new section inserters are available.  Some are variations of
+   default inserters; `magit-insert-unpulled-cherries', for example, is
+   like `magit-insert-unpulled-commits' but prefixes each commit with
+   "+" or "-" to indicate its "cherry state". Other inserters are
+   completely new (e.g., `magit-insert-unpulled-module-commits').
+
+ * The header sections in status buffers can now be customized using
+   the new `magit-status-headers-hook'.  This is an additional section
+   insertion hook; separating it from `magit-status-sections-hook'
+   gives users complete control over what information is displayed in
+   the headers, while still making the first header the parent section
+   of all the other header lines.
+
+ * Many commands that previously could only act on the section at
+   point can now act on all sections selected by a region, which can
+   span sibling sections of the same type.
+
+ * Many commands now more intelligently dwim based on the section at
+   point.
+
+ * Where it makes sense, completion and confirmation have been merged
+   into a single user action.  Many commands that previously allowed
+   carrying out or aborting some action now also allow the user to act
+   on something different from the default choice.  Where one
+   previously had to confirm with `yes RET', one now confirms with just
+   `RET' (to accept the default choice, which previously was the only
+   choice).
+
+ * The distinction between the various "apply variants" has been
+   clearly worked out, and they now all provide the same feature set.
+   The variants are: stage, unstage, discard, reverse, and "regular
+   apply".  In all cases, it is possible to act on a file or hunk, or
+   part of a hunk.  When acting on the hunk level, all variants are
+   implemented on top of `git apply', thus the name "apply variants".
+
+   Un-/staging has always been one of Magit's most beloved features,
+   and this release takes it to the next level by making the other
+   apply variants just as consistent, powerful, and intuitive to use.
+
+   All apply variants are context aware, meaning that, for example, the
+   stage variant knows that an already staged change cannot be staged.
+   That leads to better error messages.
+
+ * The committing prefix now features additional variants.  It was
+   already possible to quickly create a fixup or squash commit; the
+   new variants do that and then also instantly perform a rebase to
+   actually combine these commits with their intended target commits.
+
+ * Rebase sequences are now initiated from the new rebasing prefix.
+   Several rebasing variants exist, of course including basic
+   "rebase onto something" and interactive rebase.  Other variants
+   automatically detect and combine squash and fixup commits with
+   their intended targets.  Others let the user edit or reword a
+   single commit, without having to go through the steps that are
+   irrelevant in these cases.
+
+ * When a rebase sequence stops at a commit, then the rebasing prefix
+   instead features suffix commands for continuing, editing, or
+   aborting the sequence; or skipping the current commit.
+
+ * When a rebase sequence stops, the status buffer displays a list of
+   the already applied and yet-to-be applied commits.  These commits
+   can be acted on like those in logs.
+
+ * Cherry-picking, reverting, and applying patches using `git am' are
+   treated the same way as rebasing.  A prefix command features
+   several variants to initiate the sequence.  When a sequence is in
+   progress, then the same prefix instead features suffix commands for
+   continuing or aborting the sequence, and the status buffer lists
+   the relevant commits.
+
+ * The magit-specific "rewriting" feature has been removed because it
+   was a hybrid of "rebasing" and "cherry-picking" and vastly
+   inferior to both of them.
+
+ * The merging prefix features several new convenient merge variants.
+
+ * Merges can now be previewed before actually carrying them out.
+
+ * When a merge results in conflicts then the commits being merged are
+   listed in the status buffer, making it easier to review conflicting
+   changes in the context they were created.
+
+ * Its now possible to discard one side of a conflict directly from
+   the hunk containing the conflict, using the regular discard key
+   `k'.  It's also possible to restore a conflict.
+
+ * When using an existing branch as the starting-point of a new
+   branch, it is now automatically configured as the upstream branch.
+
+ * The branching prefix now features suffix commands for un-/setting
+   the upstream branch.  Previously this was coupled with pushing in
+   a truly obscure way.
+
+ * Branch descriptions can now be displayed in the refs or status
+   buffer, and the description can be edited using a suffix command
+   from the branching prefix.
+
+ * The URL of a remote can now be changed from the remoting prefix.
+
+ * A new pulling prefix command was added, which features several new
+   pulling variants.  Previously only one pulling command existed and
+   it had to be controlled using prefix arguments, which was very
+   cumbersome.
+
+ * A new pushing prefix command was added, which features several new
+   pushing variants.  Previously only one pushing command existed and
+   it had to be controlled using prefix arguments, which was very
+   cumbersome.
+
+ * The various tagging commands are now suffix commands of the new
+   tagging prefix command.
+
+ * It is now possible to stash, or create a snapshot from, just the
+   staged or the unstaged changes, instead of both.  Suffix commands
+   for branching, listing, and showing stashes were added to the
+   stashing prefix
+
+ * When creating stashes the new implementation in `magit-wip.el' is
+   used instead of `git stash'.  This allows the user to create
+   snapshot stashes without touching any files in the working tree.
+
+ * The submodule prefix now features new suffix commands for adding,
+   setting up, and fetching modules.
+
+ * Submodules with unmerged commits can now be displayed in the status
+   buffer.  Sections representing submodules can be expanded to show
+   their unpulled commits.  These commits can be acted on like commits
+   belonging to the super-project.
+
+ * Support for displaying diffs inside the log buffer instead of in a
+   separate diff buffer has been removed.  It might come back one day,
+   but the old implementation had just fallen behind regular one-line
+   log too much.
+
+ * The logging prefix features many new infix arguments and suffix
+   commands, which can now be combined in more flexible ways than
+   before.
+
+ * Many commands that previously read a single commit, branch, or
+   file in the minibuffer, can now read multiple, comma-separated items
+   from the user, while providing completion candidates for all of
+   them.  Likewise, when selecting a range, completion is available
+   for the second commit too.
+
+ * All of Git's reset variants are now exposed as individual commands,
+   but not all of them have a key binding by default.
+
+This was just the tip of the iceberg.
+
+Authors
+-------
+
+  2187  Jonas Bernoulli
+    28  Sebastian Wiesner
+    25  Kyle Meyer
+    19  Noam Postavsky
+    17  Pieter Praet
+    12  Rémi Vanicat
+     9  Florian Ragwitz
+     5  Philippe Vaucher
+     5  Ramkumar Ramachandra
+     4  Cornelius Mika
+     4  Kan-Ru Chen
+     4  Syohei Yoshida
+     3  Alex Dunn
+     3  Alex Kost
+     3  Nicolas Richard
+     2  Eric Schulte
+     2  Ingo Lohmar
+     2  Mitchel Humpherys
+     2  Peter Eisentraut
+     2  Ryan C. Thompson
+     1  Adeodato Simó
+     1  Andrew Schwartzmeyer
+     1  Andy Sawyer
+     1  Bradley Wright
+     1  Guillaume Martres
+     1  John Mastro
+     1  John Wiegley
+     1  Julien Danjou
+     1  Lingchao Xin
+     1  Mark Oteiza
+     1  Michael Fogleman
+     1  Michael Griffiths
+     1  Michal Sojka
+     1  Natalie Weizenbaum
+     1  Oleh Krehel
+     1  Peter Vasil
+     1  Rüdiger Sonderfeld
+     1  Steven E. Harris
+     1  Teemu Likonen
+     1  Thomas A Caswell
+     1  Tim Perkins
+     1  Tim Wraight
+     1  Wei Huang
+     1  Xavier Noria
diff --git a/Documentation/RelNotes/2.2.0.txt b/Documentation/RelNotes/2.2.0.txt
new file mode 100644
index 0000000..6d2b4be
--- /dev/null
+++ b/Documentation/RelNotes/2.2.0.txt
@@ -0,0 +1,235 @@
+It's Magit!  A Git Porcelain inside Emacs
+=========================================
+
+Magit is an interface to the version control system Git, implemented
+as an Emacs package.  Magit aspires to be a complete Git porcelain.
+While we cannot (yet) claim that Magit wraps and improves upon each
+and every Git command, it is complete enough to allow even experienced
+Git users to perform almost all of their daily version control tasks
+directly from within Emacs.  While many fine Git clients exist, only
+Magit and Git itself deserve to be called porcelains.
+
+For more information about Magit, see http://magit.vc.
+
+Please consider supporting development by making a donation.
+See http://magit.vc/donations.html.
+
+Magit v2.2.0 Release Notes
+==========================
+
+Released 16 August 2015 by Jonas Bernoulli.
+
+We are pleased to announce the release of Magit version 2.2.0,
+representing 321 commits by 19 people over 6 weeks.
+
+I would like to thank Kyle Meyer and Noam Postavsky for joining
+the developer team and helping me with this release. -- Jonas
+
+Changes since v2.1.0
+--------------------
+
+* The Elpa packages `with-editor' and `magit-popup' now depend on the
+  package `async' and turn on the mode `async-bytecomp-package-mode'.
+  If available, the mode is turned on even when these packages have
+  not been installed from an Elpa archive.  It is being turned on in
+  both of these libraries because any one of them might be the first
+  package from the Magit repository that is being updated.
+
+  It is possible to prevent the mode from being turned on when loading
+  these libraries by setting `async-bytecomp-allowed-packages' to nil
+  before loading them.  If you do that, then you must mention that you
+  have done so when reporting a bug (which might therefore be due to
+  miscompiled files).
+
+  Turning on `async-bytecomp-package-mode' advises `package--compile',
+  instructing it to compile Magit and its dependencies (as well as
+  others packages listed in `async-bytecomp-allowed-packages' and
+  their dependencies) in a separate Emacs instance.
+
+  Unfortunately it is necessary that we do this because when an old
+  version of a package is already loaded when a new version is being
+  installed, then the old version sometimes interferes during
+  compilation of the new version, leading to miscompiled files.
+
+  This usually does not happen very often, but when updating from
+  Magit v1 to v2 then it is expected, which is why users were
+  instructed to uninstall the old version before installing v2.1.0.
+  Unfortunately many users never saw those instructions, so we have
+  no choice but to use this approach to get rid of miscompiled files.
+
+* Two new commands have been added to the diff refresh popup that
+  allow the range of the previous diff to be manipulated.
+  `magit-diff-flip-revs' swaps the revisions of the range, and
+  `magit-diff-switch-range-type' toggles between ".." and "..." range
+  types.
+
+* The commands `magit-ediff-show-unstaged', `magit-ediff-show-staged',
+  `magit-ediff-show-commit', and `magit-ediff-show-working-tree' have
+  been added to the Ediff popup.
+
+* New option `magit-ediff-dwim-show-on-hunks' controls whether calling
+  `magit-ediff-dwim' runs a show variant (`magit-ediff-show-unstaged'
+  or `magit-ediff-show-staged') rather than `magit-ediff-stage' when
+  point is on an uncommitted hunk.
+
+* `magit-diff' and `magit-ediff-compare' no longer prompt the user for
+  confirmation when constructing a range from the last and first
+  commits selected by a region.  A prefix argument can now be used to
+  specify that the diff is between the second revision and the common
+  ancestor of both revisions (i.e., the "..." range type is used).
+
+* `magit-ediff-*' variants now limit file choices to those that have
+  changed between the revisions of interest.  If only one file has
+  changed, this file is used without prompting.
+
+* `magit-diff' and `magit-ediff-compare' now consider the location at
+  point when choosing the default for the prompt, and this default
+  value usually corresponds with the actions of their DWIM
+  counterparts.
+
+* The key in Ediff popup for `magit-ediff-compare' has changed from
+  "d" to "r" to be consistent with the key in the diff popup for the
+  similarly behaved `magit-diff`.
+
+* Entering a single commit for the range to `magit-ediff-compare' now
+  compares the commit with the working tree (like `magit-diff' and
+  `git diff') rather than the previous commit.
+
+* The popup `magit-diff-refresh-popup' and its suffix commands and
+  helper functions were fixed.  Most importantly file arguments and
+  diff-type arguments are no longer lost when this popup is used -
+  it only changes those arguments it is supposed to change.  Also
+  the popup only lists the arguments which can actually be used in
+  the current buffer (in status buffers fewer are supported than in
+  diff-only buffers).
+
+* The popup `magit-diff-popup' and its suffix commands now use the
+  arguments currently in the `magit-diff-mode' buffer of the current
+  repository.  Previously the arguments were always reset to the
+  default value of `magit-diff-arguments'.
+
+* The default values of `magit-diff-section-arguments' and
+  `magit-diff-arguments' now contain the `--no-ext-diff' switch.
+
+* New popup `magit-log-refresh-popup' allows changing the log
+  arguments used in the current buffer.  This allows changing the
+  arguments used in a log buffer without having to specify the
+  reference(s) again.  And it makes it possible to change the log
+  arguments used in the status buffer, which previously required that
+  option `magit-log-section-arguments' was customized manually.
+
+* When a log is displayed for the purpose of having the user select
+  a commit, then this is now displayed in a buffer separate from the
+  regular log buffer.  New option `magit-log-select-buffer-name-format'
+  controls the name of that buffer and new option
+  `magit-log-select-arguments' controls the arguments.
+
+* The default value of `magit-log-section-arguments' now contains the
+  `--decorate' switch.
+
+* `magit-log-buffer-file' respects the log arguments currently in
+  effect in the repositories log buffer, or if that doesn't exist the
+  default value of `magit-log-arguments'.  Because this command is not
+  invoked from the log popup, it's now also possible to turn on the
+  `--follow' using a prefix argument.
+
+* Log graphs are no longer shown in color by default, because turning
+  the control sequences into faces is very inefficient.  To allow
+  users to get back the colorful graphs, the `--color' switch has been
+  added to the log popup.
+
+* In the refs manager, `RET' on a local branch again "visits" that
+  branch by checking it out (like in v1.4).  With a prefix argument it
+  instead "visits" the branch by showing information about other refs
+  relative to the visited one (like in v2.1 even without a prefix
+  argument).
+
+  When the new option `magit-visit-ref-create' is non-nil, then a
+  remote branch is "visited" by creating a new local branch that
+  tracks that remote branch, and checking out that local branch.
+
+* To avoid losing any standard functionality, `C-w' and `M-w' now
+  fallback to `kill-ring-save' when the region is active.  They also
+  work in more places and in some cases copy more useful information
+  than before.
+
+* New option `magit-push-always-verify' has been added because changes
+  in v2.1 caused many users to accidentally push to `master' instead
+  of a remote feature branch as intended.  All users should set this
+  option to nil, but only after having read the documentation.  The
+  commands that respect this option instruct users to consult its
+  documentation.
+
+* Moving through a log using `n' and `p' is now much faster because
+  the revision buffer is no longer recreated for each commit along the
+  way.  Because Emacs does not support key-down-events this had to be
+  implemented using a timer, which has the unfortunate effect that it
+  leads to a delay even when only pressing one of these keys briefly
+  to move by a single line.  This delay can be adjusted using the new
+  option `magit-diff-auto-show-delay'.
+
+* When creating a new branch, first reading the starting point and
+  only then the name of the new branch has advantages.  But many users
+  disagree, so the option `magit-branch-read-upstream-first' has been
+  added.  It defaults to t.
+
+* New commands `magit-wip-log' and `magit-wip-log-current' allow
+  showing log for a branch and its wip refs (which the various wip
+  modes commit to).
+
+* New command `magit-submodule-deinit'.
+
+* New command `magit-commit-augment' allows the user to pick a commit
+  to squash into and edit the squash commit message.
+
+* New push commands `magit-push-implicitly' and `magit-push-quickly'.
+
+* When reading user input, many commands now offer a better default
+  choice and better completion candidates.
+
+* All apply variants now use `--3way' when called with a prefix
+  argument.
+
+* Log commands now respect the entries in the .mailmap file.
+
+* The command `magit-pull-current' now also fetches tags by default.
+
+* When a file has conflicts then the type of conflict is shown now.
+
+* New option `magit-log-show-refname-after-summary'.
+
+* New section inserter `magit-insert-user-header'.
+
+* New face `magit-section-secondary-heading'.
+
+* New commands `magit-run-gitk-all' and `magit-run-gitk-branches'.
+  The existing command `magit-run-gitk' now always calls `gitk'
+  without any arguments.
+
+* New commands `magit-shell-command' and `magit-shell-command-topdir'.
+
+This release also contains various documentation fixes, code
+clean-ups, bug fixes, and other small to medium improvements.
+
+Authors
+-------
+
+   225  Jonas Bernoulli
+    67  Kyle Meyer
+     8  Noam Postavsky
+     3  Mitchel Humpherys
+     2  Greg Lucas
+     2  Mark Karpov
+     2  Yuichi Higashi
+     1  Johann Klähn
+     1  Josiah Schwab
+     1  Kan-Ru Chen
+     1  Nicklas Lindgren
+     1  Phil Sainty
+     1  Richard Kim
+     1  Robin Green
+     1  Rémi Vanicat
+     1  Steven Vancoillie
+     1  Thomas Frössman
+     1  Ting-Yu Lin
+     1  Vineet Naik
diff --git a/Documentation/RelNotes/2.2.1.txt b/Documentation/RelNotes/2.2.1.txt
new file mode 100644
index 0000000..11771bf
--- /dev/null
+++ b/Documentation/RelNotes/2.2.1.txt
@@ -0,0 +1,45 @@
+Magit v2.2.1 Release Notes
+==========================
+
+Released 24 August 2015 by Jonas Bernoulli.
+
+This is a bugfix release.
+
+* The version strings in the manual were not set to "2.2" when v2.2.0
+  was released.
+
+* Some menu bindings were not adjusted when commands were renamed.
+
+* The "next" tag was never shown in the "Tag(s)" header of the status
+  buffer.
+
+* Blaming did not abort gracefully when the user killed the buffer.
+
+* Blaming failed on indirect buffers.
+
+* Blaming did not detect when a file was untracked.
+
+* Blaming passed the wrong line range when the file's buffer was
+  narrowed.
+
+* `magit-shell-command-topdir' used `magit-git-command' instead of
+  `magit-shell-command'.
+
+* `magit-copy-as-kill' added "nil" to the `kill-ring' when there was
+  nothing useful to put there.
+
+* `magit-find-file-hook', `magit-find-index-hook',
+  `magit-refresh-popup-buffer-hook' were used without being defined
+  using `defvar'.
+
+* `magit-format-ref-labels' failed to work around a Git bug, resulting
+  in refnames not being colorized when `--simplify-by-decoration' is
+  used.
+
+This release also contains various documentation fixes.
+
+Authors
+-------
+
+    16  Jonas Bernoulli
+    11  Kyle Meyer
diff --git a/Documentation/RelNotes/2.2.2.txt b/Documentation/RelNotes/2.2.2.txt
new file mode 100644
index 0000000..1d5ec52
--- /dev/null
+++ b/Documentation/RelNotes/2.2.2.txt
@@ -0,0 +1,45 @@
+Magit v2.2.2 Release Notes
+==========================
+
+Released 3 September 2015 by Jonas Bernoulli.
+
+This is a bugfix release.
+
+* `magit-diff-wash-diff' choked on unmerged binary files.  #2211
+
+* `magit-blame-popup' did not allow empty input when reading a value
+  for "-C" or "-M".  #2208
+
+* The `emacsclient' executables belonging to non-current alternative
+  installations of Emacs on Debian were not considered when setting
+  the default value of `with-editor-emacsclient-executable'.  #2217
+
+* `server-edit', which switches to a buffer preferably one with
+  another client, was used when finishing or aborting a `with-editor'
+  session.  When `emacsclient' was used to connect to a server and
+  then a commit or rebase was invoked, then there would be another
+  client and switching to its buffer after finishing the commit or
+  rebase would be undesirable.  Now we use `server-done' instead.
+  #2197
+
+* When `--stat' abbreviates the name of a file, then that name was
+  stored in the section object instead of the full name.  #2199
+
+* `magit-file-relative-name' with non-nil TRACKED failed in Tramp
+  repositories.  #2206
+
+* After failing to clone, `magit-clone' also tried to show the status
+  of the non-existent clone.  #2203
+
+* `magit-wip-log' did not display a log if the working tree or index
+  ref did not exist.
+
+This release also contains various documentation fixes and code
+clean-ups.
+
+Authors
+-------
+
+    29  Jonas Bernoulli
+     5  Kyle Meyer
+     1  Barak A. Pearlmutter
diff --git a/Documentation/RelNotes/2.3.0.txt b/Documentation/RelNotes/2.3.0.txt
new file mode 100644
index 0000000..884f5bd
--- /dev/null
+++ b/Documentation/RelNotes/2.3.0.txt
@@ -0,0 +1,264 @@
+It's Magit!  A Git Porcelain inside Emacs
+=========================================
+
+Magit is an interface to the version control system Git, implemented
+as an Emacs package.  Magit aspires to be a complete Git porcelain.
+While we cannot (yet) claim that Magit wraps and improves upon each
+and every Git command, it is complete enough to allow even experienced
+Git users to perform almost all of their daily version control tasks
+directly from within Emacs.  While many fine Git clients exist, only
+Magit and Git itself deserve to be called porcelains.
+
+For more information about Magit, see http://magit.vc.
+
+Magit v2.3.0 Release Notes
+==========================
+
+Released 28 October 2015 by Jonas Bernoulli.
+
+We are pleased to announce the release of Magit version 2.3.0,
+representing 367 commits by 12 people over 10 weeks.
+
+Changes since v2.2.0
+--------------------
+
+* Added `--interactive' switch to `magit-rebase-popup' so that rebase
+  variants which normally perform a non-interactive rebase can be used
+  to perform an interactive rebase too.  #2186
+
+* Commands that perform an interactive rebase should no longer be used
+  non-interactively (i.e. they should only be used as commands).  #2187
+
+* Rebasing commands now can start with a root commit.  Root commits
+  are detected automatically, so users don't have to use the `--root'
+  switch explicitly.  #2187
+
+* Added new command `magit-checkout-file'.
+
+* Added new option `magit-bury-buffer-function' to give users more
+  control over how Magit buffers are buried, replacing the old binary
+  option `magit-restore-window-configuration'.  The default is still
+  the same, i.e. `magit-restore-window-configuration' is used.  #2193
+
+* Added new function `magit-mode-quit-window' as a simpler variant to
+  `magit-restore-window-configuration'.  #2193
+
+* Information about related refs in `magit-revision-mode' buffers are
+  now grouped in the same section as other headers and are formatted
+  like those other headers instead of like diffstats.  The redundant
+  header which previously grouped the related refs section is gone.
+  All headers are inserted by the new `magit-insert-revision-headers'
+  section inserter.  #2216
+
+* No longer avoid calling git more than absolutely necessary when
+  creating a `magit-revision-mode' buffer.  This simplifies parsing,
+  makes it simpler to prettify how information is presented, allows
+  users to customize how and in what order information is presented,
+  and prepares for faster, asynchronously created diffs.  #2216
+
+* The various sections in revision buffers are now inserted using new
+  section inserters named `magit-insert-revision-{*}', all of which
+  are part of the default value of `magit-revision-sections-hook'.
+  #2216
+
+* The various sections in diff buffers are now inserted using new
+  section inserters named `magit-insert-diff-{*}', all of which are
+  part of the default value of `magit-diff-sections-hook'.  #2216
+
+* Added new option `magit-revision-headers-format' whose value is
+  passed to `git show --format=' to insert most of the headers,
+  excluding the related-refs headers.  The default value now uses
+  placeholders which respect information in the file ".mailmap".
+  #2216
+
+* Removed options `magit-revision-show-notes',
+  `magit-diff-show-xref-buttons', `magit-revision-show-xref-buttons',
+  `magit-diff-show-diffstat', and `magit-revision-show-diffstat'.
+  Whether these sections are inserted is now controlled using the
+  hooks `magit-diff-section-hook' and `magit-revision-section-hook'.
+  #2216
+
+* Gravatar images can now be shown in `magit-revision-buffers'.  New
+  option `magit-revision-show-gravatars' controls whether these images
+  should be inserted and can also be used to adjust to customizations
+  of `magit-revision-headers-format'.
+
+  This feature is not enabled by default due to privacy concerns.
+
+  Gravatar images are spliced into two halves which are then displayed
+  on separate lines.  On OS X the splicing has a bug in some Emacs
+  builds, which causes the top and bottom halves to be interchanged.
+  Setting the new option `magit-revision-use-gravatar-kludge' to `t'
+  works around this issue.  #2216
+
+* After using the region to stage or discard parts of a hunk, point is
+  now placed on the beginning of the next or previous block of changed
+  lines.  Previously we just jumped to the beginning of the hunk at
+  the same index as the previous hunk, but that often was very far
+  away from where point was before the refresh.  #2227
+
+* The function `magit-toplevel' was refactored and many tests were
+  added.  It now returns the correct value when a symlink to a
+  sub-directory of a working tree is involved.  #2242
+
+* New option `magit-keep-region-overlay' allows displaying the region
+  overlay together with the visualization of a valid Magit selection.
+  See the doc-string for why we think you shouldn't do that, but if
+  you disagree then you can now have it your way.  #2091
+
+* Avoid the inefficiency of `git log --graph --max-count=N REV' (it
+  calculates the graph for all reachable commits, not just the N
+  commits), by additionally limiting the history using a range
+  calculated from REV and N, when possible.  #2243
+
+* Renamed `magit-file-buffer-mode' to `magit-file-mode'.  Related
+  symbols were renamed accordingly.
+
+* Added new minor mode `magit-blob-mode' and new commands
+  `magit-blob-previous' and `magit-blob-next'.  #2195
+
+* Added new commands `magit-branch-spinoff' and `magit-branch-reset'.
+  #2191
+
+* Added new option `magit-status-expand-stashes'.
+
+* In addition to `default-directory' also set `list-buffers-directory'
+  to the top-level of the working tree in Magit buffers, causing that
+  directory to be displayed in the "File" column of the *Buffer List*
+  buffer.
+
+* Added a kludge to keep Cygwin and MYSYS2 executables from expanding
+  globs when called from a native Windows Emacs executable.  #2281
+
+* Added a revision stack.  The new commands `magit-copy-section-value'
+  and `magit-copy-buffer-revision', which are intended for use inside
+  Magit buffers, push an entry to the stack, and the new command
+  `magit-pop-revision-stack' inserts a representation into an editable
+  buffer.  New option `magit-pop-revision-stack-format' controls how
+  the representation of the revision is formatted.  The old commands
+  `magit-copy-as-kill' and `magit-copy-buffer-thing-as-kill' have been
+  removed.  #2225
+
+* The default values of options `magit-commit-extend-override-date'
+  and `magit-commit-extend-override-date' changed to `t'.
+
+* Added new option `magit-log-show-margin'.
+
+* Added new option `magit-log-remove-graph-args'.  #2226
+
+* Added support for showing actionable diffs inside logs.  #2226
+
+* Added basic support for tracing the evolution of a region.  #2226
+
+* Added new command `magit-stash-format-patch'.
+
+* All apply variants learned how to apply multiple hunks at once. #2271
+
+* Regular apply learned how to apply multiple files at once. #2271
+
+* `git-commit-setup' learned to handle Cygwin paths.  It had to be
+  taught about that separately from the rest of Magit, because, for
+  historic reasons, we try to keep the `git-commit' package usable
+  without Magit.
+
+* The signatures of `magit-mode-setup' and `magit-mode-get-buffer'
+  have changed, and `magit-mode-get-buffer-create' has been removed.
+  Extensions have to be adjusted accordingly.  #2282.
+
+* All Magit-Mode buffers (including process buffers, but excluding
+  popup, blob-visiting, and file-visiting buffers, whose major-modes
+  do not derive from `magit-mode' and therefore aren't "Magit-Mode
+  buffers") are now displayed using `magit-display-buffer', which is a
+  wrapper around the low-level `display-buffer'.  High-level functions
+  such as `pop-to-buffer' and `switch-to-buffer' are no longer used to
+  display Magit buffers.
+
+  `magit-display-buffer' uses the function specified by the new option
+  `magit-display-buffer-function' to actually display the buffer in
+  some window.  The default value is `magit-display-buffer-traditional'.
+  By implementing their own variant to wrap around `display-buffer',
+  users can take complete control over how Magit buffers are displayed.
+  It's also possible to use `display-buffer' directly and specify the
+  display actions in `display-buffer-alist'.
+
+  Added new options `magit-pre-display-buffer-hook' and
+  `magit-post-display-buffer-hook', and removed the options
+  `magit-status-buffer-switch-function' and
+  `magit-diff-switch-buffer-function'.  #2282
+
+* Added new options `magit-generate-buffer-name-function',
+  `magit-buffer-name-format', and `magit-uniquify-buffer-names',
+  replacing the various `magit-{*}-buffer-name-format' options.  #2282
+
+* Added new command `magit-toggle-buffer-lock'.  Previously it was
+  possible to prevent Magit from reusing an existing buffer to display
+  something else, using the command `magit-rename-buffer' (which was
+  removed).  Now this is done by locking the buffer to its value.
+  #2282
+
+* The status buffer is now always refreshed after running a Magit
+  command triggers a refresh.  Previously that was only the case if
+  the buffer in which the command was invoked was a Magit buffer too.
+
+* Added optional support for refreshing the status buffer every time a
+  buffer visiting a file, which is tracked in the current repository,
+  is saved.  To enable this add `magit-after-save-refresh-buffers' to
+  `after-save-hook'.
+
+* Added new functions `magit-log-maybe-update-revision-buffer',
+  `magit-log-maybe-update-blob-buffer',
+  `magit-status-maybe-update-revision-buffer', and
+  `magit-status-maybe-update-blob-buffer', and added some of them to
+  `magit-section-movement-hook'.  Removed the function
+  `magit-log-maybe-show-commit', which served about the same purpose
+  as these new functions.  Previously one had to customize the option
+  `magit-diff-auto-show' to control when the other buffer was updated,
+  now one does so by adding or removing the above functions to or from
+  `magit-section-movement-hook'.  The other window is only ever
+  updated now, to initially create it, use `SPC'.  #2338
+
+* Added new hook `magit-process-find-password-functions', with no
+  default members.  These functions, if any, are run when git requests
+  a password from the user, if there are no such functions, or if they
+  fail, then the user has to type the password as before.  Added new
+  function `magit-process-password-auth-source'.  It can be added to
+  that hook and uses `auth-source' to get the password from one of the
+  sources it supports.  #2311
+
+* Removed broken support for unicode log graphs.
+
+* `magit-expand-git-file-name' learned to use the output of `mount' to
+  map Cygwin paths into native Windows paths.  `git-commit-setup' now
+  uses `magit-expand-git-file-name' if available.  #2348
+
+* Added new function `magit-define-popup-sequence-action' and taught
+  related functions about `:sequence-actions'.
+
+* Added new hook `magit-credential-hook' and added new hook function
+  `magit-maybe-start-credential-cache-daemon' to it.  This allows
+  starting Git's credential daemon separately, which is necessary
+  because Emacs sends SIGHUP and closes the pty when e.g `git push'
+  (which started the daemon) finishes.  Upon receiving that signal
+  the daemon terminates.  We work around this by starting the daemon
+  directly before invoking the git subcommand which might need
+  credentials.  #2360
+
+This release also contains the changes described in the v2.2.1 and
+v2.2.2 release notes, as well as various other documentation fixes,
+code clean-ups, bug fixes, and other small to medium improvements.
+
+Authors
+-------
+
+   305  Jonas Bernoulli
+    38  Kyle Meyer
+    15  Noam Postavsky
+     1  Andriy Kmit'
+     1  Barak A. Pearlmutter
+     1  Brian Warner
+     1  Damien Cassou
+     1  John Mastro
+     1  Nicolas Petton
+     1  Nikolay Martynov
+     1  Peter Jaros
+     1  Phil Sainty
diff --git a/Documentation/RelNotes/2.3.1.txt b/Documentation/RelNotes/2.3.1.txt
new file mode 100644
index 0000000..b1d1291
--- /dev/null
+++ b/Documentation/RelNotes/2.3.1.txt
@@ -0,0 +1,31 @@
+Magit v2.3.1 Release Notes
+==========================
+
+Released 11 November 2015 by Jonas Bernoulli.
+
+This is a bugfix release.
+
+* `magit-stash-drop' now shows a message with the hash of the dropped
+  stash to make it easier to recover from dropping the wrong stash.
+
+* `magit-revert-buffers' now avoids needlessly connecting to unrelated
+  hosts.  It first checks whether a given file is on the same host as
+  the repository, and only if that is so it checks whether the file is
+  located inside the repository, using `file-in-directory-p', which,
+  for Tramp files, requires connecting to the remote host.
+
+* `magit-commit-message-buffer' no longer hangs when a symlink to the
+  repository is involved.
+
+This release also contains various documentation fixes and code
+clean-ups.
+
+Authors
+-------
+
+    10  Jonas Bernoulli
+     3  Noam Postavsky
+     2  Kyle Meyer
+     1  Carl Lieberman
+     1  David L. Rager
+     1  Syohei Yoshida
diff --git a/Documentation/RelNotes/2.4.0.txt b/Documentation/RelNotes/2.4.0.txt
new file mode 100644
index 0000000..db90d5c
--- /dev/null
+++ b/Documentation/RelNotes/2.4.0.txt
@@ -0,0 +1,156 @@
+It's Magit!  A Git Porcelain inside Emacs
+=========================================
+
+Magit is an interface to the version control system Git, implemented
+as an Emacs package.  Magit aspires to be a complete Git porcelain.
+While we cannot (yet) claim that Magit wraps and improves upon each
+and every Git command, it is complete enough to allow even experienced
+Git users to perform almost all of their daily version control tasks
+directly from within Emacs.  While many fine Git clients exist, only
+Magit and Git itself deserve to be called porcelains.
+
+For more information about Magit, see http://magit.vc.
+
+Magit v2.4.0 Release Notes
+==========================
+
+Released 18 January 2016 by Jonas Bernoulli.
+
+We are pleased to announce the release of Magit version 2.4.0,
+representing 269 commits by 14 people over 12 weeks.
+
+Changes since v2.3.0
+--------------------
+
+* The new mode `magit-auto-revert-mode', a magit-specific globalized
+  variant of `auto-revert-mode', replaces the old implementation, which
+  was configured using the option `magit-revert-buffers'.  The new
+  mode is enabled for all users by default, except for those who have
+  set `magit-revert-buffers' to nil while the old implementation was
+  still in use.  #2474
+
+* The option `magit-refresh-status-buffer' was added, allowing users
+  to prevent automatic refreshes of the status buffer for performance
+  reasons.
+
+* All of Git's push-related variables are now honored.  #2414
+
+* In addition to the upstream branch, the push-remote (configured
+  using `branch.<name>.pushRemote' or `remote.pushDefault') is now
+  also fully supported.  #2414
+
+* The status buffer now features up to four logs listing unpulled and
+  unpushed commits.  Two for the upstream and two for the push-remote.
+  #2414
+
+* The branch popup now shows the most important Git variables that are
+  in some way related to branches.  The values of these variables can
+  now be conveniently changed from that popup.  #2414
+
+* The fetch, pull, push, and rebase popups now feature an action which
+  acts on the push-remote, another which acts on the upstream, and yet
+  another which acts on any other source or target.  For each of these
+  actions the respective branch is shown in the popup.
+
+  The actions in the push popup are displayed even if the respective
+  variables are unset - they then offer to set these variables before
+  pushing.  Setting `magit-push-current-set-remote-if-missing' to nil
+  disables this.
+
+  Many key bindings were changed for consistency and safety reasons.
+  Likewise many commands were renamed and their behavior was adjusted.
+  Some new commands, related to the push-remote, were added.  #2414
+
+* The command `magit-push-implicitly' was removed from the push popup.
+  The command's doc-string explains how to put it back.  If these
+  instructions are followed, then the popup shows what will happen if
+  the command is used.  #2453
+
+* The command `magit-push-to-remote' was added.  The command's
+  doc-string explains how to add it to the push popup.  #2453
+
+* The option `magit-push-always-verify' was removed.  That was only a
+  temporary kludge to keep users from shooting themselves in the foot.
+  This is no longer necessary because one now always sees where one is
+  about to push to.  #2414
+
+* The popup command `magit-pull-and-fetch-popup' was added as a
+  possible replacement for the separate `magit-push-popup' and
+  `magit-fetch-popup'.  #2452
+
+* The option `magit-branch-prefer-remote-upstream' was added for users
+  who prefer to always use remote branches as upstreams.  #2447
+
+* The options `magit-clone-set-remote.pushDefault' and
+  `magit-remote-add-set-remote.pushDefault' were added.  #2447
+
+* When Git is run for side-effects and exits with a non-zero status,
+  then the respective error message is now inserted into the status
+  buffer.  This should help those users who do not see that message
+  when it is being displayed in the echo area.
+
+* Popups gained support for a new event type `:variable', which can be
+  used to change the value of Git variables.  This can only be used in
+  combination with Magit (just `magit-popup.el' by itself is not
+  sufficient).  #2409
+
+* The backward-compatibility kludge `magit-branch-manager' has been
+  removed.  The one and only binding to show the refs buffer now is
+  "y"; the "b v" binding has been removed.
+
+* The command `with-editor-finish' now runs the new hook
+  `with-editor-post-finish-hook'.
+
+* The command `magit-diff-visit-file' now runs the new hook
+  `magit-diff-visit-file-hook'.
+
+* When the upstream branch or push remote is configured but the
+  respective branch does not actually exist, then that is now reported
+  in the header of the status buffer.  #2390
+
+* The header line about the upstream branch in the status buffer is
+  now prefixed with either "Merge" or "Rebase", depending on the value
+  of `branch.<current-branch>.rebase'. #2390
+
+* `magit-define-popup' learned two new arguments, `:setup-function' and
+  `:refresh-function'.  These arguments should be used instead of the
+  MODE argument, which is now deprecated.  #2389
+
+* Negative text properties are no longer faked; that was just too ugly
+  and inefficient.  Since v2.1.0 Magit no longer sets the background
+  color for any faces except for those related to diffs.  Third-party
+  themes which still set the background color of non-diff faces have
+  to be adjusted, because the background color of these faces would be
+  shadowed by the highlighting of the current section.  This does not
+  apply to diff-related faces because diff sections are highlighted
+  differently from other sections.  #2387
+
+* The commands `git-rebase-move-line-up' and `git-rebase-move-line-down'
+  have been extended.  When a region is active, they now operate on
+  all lines touched by the region, not just the current line.  In
+  addition, a numeric prefix can now be given to specify how many
+  lines the current line or selection is moved across.
+
+* The option `magit-popup-display-action' was added.
+
+This release also contains the changes described in the v2.3.1 release
+notes, as well as various other documentation fixes, code clean-ups,
+bug fixes, and other small to medium improvements.
+
+Authors
+-------
+
+   226  Jonas Bernoulli
+    22  Kyle Meyer
+    10  Noam Postavsky
+     1  Carl Lieberman
+     1  Damien Cassou
+     1  David L. Rager
+     1  John Mastro
+     1  Lele Gaifax
+     1  Michael Heerdegen
+     1  Miloš Mošić
+     1  Raimon Grau
+     1  Sylvain Rousseau
+     1  Syohei Yoshida
+     1  Zach Latta
diff --git a/Documentation/RelNotes/2.4.1.txt b/Documentation/RelNotes/2.4.1.txt
new file mode 100644
index 0000000..94a4135
--- /dev/null
+++ b/Documentation/RelNotes/2.4.1.txt
@@ -0,0 +1,31 @@
+Magit v2.4.1 Release Notes
+==========================
+
+Updates since v2.4.0
+--------------------
+
+* Added new utility function `magit-rev-abbrev', `magit-ref-p', and
+  `magit-tag-p'.
+
+Fixes since v2.4.0
+------------------
+
+* When determining the emacsclient executable most suitable for the
+  current emacs instance, With-Editor ignored any executable that is
+  actually named "emacsclient-snapshot".
+
+* When determining the most suitable git executable, an error occured
+  if "Git for Windows 1.x" is used and an cygpath executable is
+  available.
+
+* An error occured when refreshing the status buffer when there is a
+  new, staged but not yet committed, submodule.
+
+This release also contains typofixes.
+
+Authors
+-------
+
+     9  Jonas Bernoulli
+     4  Kyle Meyer
+     1  Noam Postavsky
diff --git a/Documentation/magit-popup.org b/Documentation/magit-popup.org
new file mode 100644
index 0000000..ab082b9
--- /dev/null
+++ b/Documentation/magit-popup.org
@@ -0,0 +1,590 @@
+#+TITLE: Magit-Popup User Manual
+#+AUTHOR: Jonas Bernoulli
+#+EMAIL: jonas@bernoul.li
+#+DATE: 2015
+#+LANGUAGE: en
+
+#+TEXINFO_DIR_CATEGORY: Emacs
+#+TEXINFO_DIR_TITLE: Magit-Popup: (magit-popup).
+#+TEXINFO_DIR_DESC: Infix arguments with feedback
+#+SUBTITLE: for version 2.3
+
+#+OPTIONS: H:4 num:3 toc:2
+#+STARTUP: indent
+
+* Copying
+:PROPERTIES:
+:COPYING:    t
+:END:
+
+#+BEGIN_TEXINFO
+@ifnottex
+Taking inspiration from regular prefix commands and prefix arguments,
+this library implements a similar abstraction; a new kind of prefix
+command that is associated with a specific set of infix arguments and
+suffix commands.
+@end ifnottex
+
+@quotation
+Copyright (C) 2015 Jonas Bernoulli <jonas@@bernoul.li>
+
+You can redistribute this document and/or modify it under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or (at your option) any
+later version.
+
+This document is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+@end quotation
+#+END_TEXINFO
+
+* Introduction
+
+Taking inspiration from regular prefix commands and prefix arguments,
+this library implements a similar abstraction; a new kind of prefix
+command that is associated with a specific set of infix arguments and
+suffix commands.
+
+Invoking such a prefix command displays a popup buffer which lists the
+associated infix arguments and suffix commands.  In that buffer each
+argument is prefixes with the key sequence that can be used to toggle
+it or change its value.  Likewise each suffix command is prefixed with
+the key used to invoke it.  Such a popup buffer might look like this:
+
+#+BEGIN_EXAMPLE
+,-----------------------------------------
+|Switches
+| -l Show graph (--graph)
+| -d Show refnames (--decorate)
+|
+|Options
+| =m Search messages (--grep="popup")
+| =p Search patches (-G)
+|
+|Action
+| l Show log for current branch
+| o Show log for another branch
+'-----------------------------------------
+#+END_EXAMPLE
+
+The user could then for example type ~-l~ to toggle the ~--graph~ *switch*
+(when it is on then it is shown in green, otherwise in gray), or ~=m~ to
+change the value of the *option* ~--grep~.
+
+Once all arguments are as desired one invokes a suffix command, which
+causes the popup buffer to disappears.  The suffix command should then
+retrieve the infix arguments in its ~interactive~ form like this is done
+for prefix arguments.
+
+While such "prefix-infix-suffix" combos were inspired by regular
+prefix commands and prefix arguments, they are also quite different.
+This should illustrate the most basic differences:
+
+- A regular prefix commands
+
+  #+BEGIN_EXAMPLE
+          /- command1
+  prefix --- command2
+          \- command3
+  #+END_EXAMPLE
+
+- Prefix arguments
+
+  #+BEGIN_EXAMPLE
+           /- command1
+  C-u ... --- command2
+           \- well *any* command
+  #+END_EXAMPLE
+
+- A Prefix-Infix-Suffix combo
+
+  #+BEGIN_EXAMPLE
+           /- argument1 -\ /- suffix1
+  prefix----- argument2 --+-- suffix2
+         ^ \- argument3 -/
+         |        |
+         '--------'
+      (refresh buffer)
+   #+END_EXAMPLE
+
+This library was written as a replacement for ~magit-key-mode~ which was
+used in Magit releases before 2.1.0.  It is used to implement all
+"popups" in the current Magit release but a future release will switch
+to yet another implementation.
+
+This library does not depend on any other Magit libraries and it is
+distributed as a separate package, which makes it possible to use it
+in packages that are not related to Magit.  But keep in mind that it
+will be deprecated eventually.
+
+* Usage
+
+Every popup buffers created with a prefix command contains a section
+named "Actions" listing the available suffix commands.  Most buffers
+also contain a "Switches" and/or an "Options" section which list the
+two types of infix arguments separately.
+
+Switches are arguments that can be toggled on or off.  When a switch
+is active then it is shown in color, when it is off then it is shown
+in gray (of course the details depend on the color theme in use).
+
+Options are arguments that have a value.  When an option has a value
+then that is shown after the option itself.  Because for some options
+the empty string is a valid value, options are additionally colorized
+like switches to indicate whether they are active or not.
+
+The events bound to suffix commands are always single alphabetic
+characters.  The bindings for arguments are always two events long.
+For switches the first key is always ~-~, for options it is always ~=~.
+The second key is always an alphabetic character.
+
+By default popup buffers also feature a section listing commands
+common to all popups.  To avoid conflicts with suffix commands, the
+bindings of these common commands are not alphabetic characters.  This
+section is shown by default so that documentation-resistant users get
+a change to notice them.
+
+- User Option: magit-popup-show-common-commands
+
+  This option controls whether the section which lists the commands
+  that are common to all popups is initially show.  We recommend you
+  set this to ~nil~ - after you have memorized that it can be shown on
+  demand using ~C-t~.
+
+- Key: C-t, magit-popup-toggle-show-common-commands
+
+  Show or hide the section listing the commands shared by all popups.
+
+- Key: C-g, magit-popup-quit
+
+  Quit popup buffer without invoking a suffix command.
+
+Without further action, setting arguments only affects the next suffix
+command.  Invoking the same prefix command again resets the arguments
+to their default value, but the defaults can be changed directly from
+the popup buffer itself.  For a prefix command named ~NAME-popup~ the
+default values are stored as the value of the custom option named
+~NAME-arguments~.  While this option can be customized using the Custom
+interface, it is better to do so directly from the popup buffer.
+
+- Key: C-c C-c, magit-popup-set-default-arguments
+
+  This sets the default value for the arguments for the current popup.
+
+  Then the popup buffer is closed without invoking a suffix command;
+  unless a prefix argument is used in which case the popup remains
+  open.
+
+- Key: C-x C-s, magit-popup-save-default-arguments
+
+  This sets the default value for the arguments for the current popup
+  and saves it for future Emacs sessions.
+
+  Then the popup buffer is closed without invoking an action; unless a
+  prefix argument is used in which case the popup remains open.
+
+It is also possible to add additional arguments and commands to an
+existing popup, but that cannot be done directly from the popup (or
+the Custom interface).  See [[*Customizing existing popups]].
+
+Documentation about a popup's arguments and commands can be shown
+directly from the popup.
+
+- Key: C-h i, magit-popup-info
+
+  Show this manual.
+
+- Key: ?, magit-popup-help
+
+  This command reads a key sequence and then shows the documentation
+  of the argument or command that sequence is bound to.  In other
+  words type the same keys that you would use to invoke the argument
+  or command, but prefix the sequence with ~?~.
+
+  For suffix commands this shows the doc-string.  For arguments this
+  command can only show something for popups that have an associated
+  man-page.  If the man-page is set, then this command displays it in
+  a separate buffer and puts point on the entry about the argument in
+  question.
+
+  The buffer which is used to display the documentation is selected.
+  Simply press ~q~ to leave that buffer and restore the old window
+  configuration.
+
+While it isn't very useful, it is possible to move around in a popup
+buffer using ~C-p~ and ~C-n~, and to invoke the argument or command at
+point using ~RET~.  But it is much more efficient to use the dedicated
+key bindings instead, so these commands are not listed in popup
+buffers along with the other common commands.
+
+** Customizing existing popups
+
+It is possible to define additional infix arguments and suffix
+commands to an existing popup using the following functions.
+
+You can find some examples which use the below commands at
+https://github.com/magit/magit/wiki/Additional-proposed-infix-arguments-and-suffix-commands.
+
+- Function: magit-define-popup-switch popup key desc switch &optional enable at prepend
+
+  In POPUP, define KEY as SWITCH.
+
+  POPUP is a popup command defined using ~magit-define-popup~.  SWITCH
+  is a string representing an argument that takes no value.  KEY is a
+  character representing the second event in the sequence of
+  keystrokes used to toggle the argument.  (The first event, the
+  prefix, is shared among all switches, defaults to ~-~, and can be
+  changed in ~magit-popup-mode-keymap~).
+
+  DESC is a string describing the purpose of the argument, it is
+  displayed in the popup.
+
+  If optional ENABLE is non-nil then the switch is on by default.
+
+  SWITCH is inserted after all other switches already defined for
+  POPUP, unless optional PREPEND is non-nil, in which case it is
+  placed first.  If optional AT is non-nil then it should be the KEY
+  of another switch already defined for POPUP, the argument is then
+  placed before or after AT, depending on PREPEND.
+
+- Function: magit-define-popup-option popup key desc option &optional reader value at prepend
+
+  In POPUP, define KEY as OPTION.
+
+  POPUP is a popup command defined using ~magit-define-popup~.  OPTION
+  is a string representing an argument that takes a value.  KEY is a
+  character representing the second event in the sequence of
+  keystrokes used to set the argument's value.  (The first event, the
+  prefix, is shared among all options, defaults to ~=~, and can be
+  changed in ~magit-popup-mode-keymap~).
+
+  DESC is a string describing the purpose of the argument, it is
+  displayed in the popup.
+
+  If optional VALUE is non-nil then the option is on by default, and
+  VALUE is its default value.
+
+  OPTION is inserted after all other options already defined for
+  POPUP, unless optional PREPEND is non-nil, in which case it is
+  placed first.  If optional AT is non-nil then it should be the KEY
+  of another option already defined for POPUP, the argument is then
+  placed before or after AT, depending on PREPEND.
+
+- Function: magit-define-popup-action popup key desc command &optional at prepend
+
+  In POPUP, define KEY as COMMAND.
+
+  POPUP is a popup command defined using ~magit-define-popup~.  COMMAND
+  can be any command but should usually consume the popup arguments in
+  its ~interactive~ form.  KEY is a character representing the event
+  used invoke the action, i.e. to interactively call the COMMAND.
+
+  DESC is a string describing the purpose of the action, it is
+  displayed in the popup.
+
+  COMMAND is inserted after all other commands already defined for
+  POPUP, unless optional PREPEND is non-nil, in which case it is
+  placed first.  If optional AT is non-nil then it should be the KEY
+  of another command already defined for POPUP, the command is then
+  placed before or after AT, depending on PREPEND.
+
+- Function: magit-define-popup-sequence-action popup key desc command &optional at prepend
+
+  Like ~magit-define-popup-action~, but modifies the value of the
+  ~:sequence-actions~ property instead of ~:actions~.
+
+- Function: magit-change-popup-key popup type from to
+
+  In POPUP, bind TO to what FROM was bound to.  TYPE is one of
+  ~:action~, ~:sequence-action~, ~:switch~, or ~:option~.  Bind TO and unbind
+  FROM, both are characters.
+
+- Function: magit-remove-popup-key popup type key
+
+  In POPUP, remove KEY's binding of TYPE.  POPUP is a popup command
+  defined using ~magit-define-popup~.  TYPE is one of ~:action~,
+  ~:sequence-action~, ~:switch~, or ~:option~.  KEY is the character which
+  is to be unbound.
+
+It is also possible to change other aspects of a popup by setting a
+property using ~plist-put~.  See [[*Defining prefix commands]] for valid
+properties.  The most likely change Magit users might want to make
+is:
+
+#+BEGIN_SRC emacs-lisp
+  (plist-put magit-show-refs-popup :use-prefix nil)
+#+END_SRC
+
+** Other options
+
+- User Option: magit-popup-use-prefix-argument
+
+  This option controls the effect that the use of a prefix argument
+  before entering a popup has.  The *intended* default is ~default~, but
+  the *actual* default is ~disabled~.  This is necessary because the old
+  popup implementation did simply forward such a pre-popup prefix
+  argument to the suffix command invoked from the popup, and changing
+  that without users being aware of it could lead to tears.
+
+  - ~disabled~
+
+    Bring up a Custom option buffer so that the user reads
+    this and then makes an informed choice.
+
+  - ~default~
+
+    With a prefix argument directly invoke the popup's
+    default action (an Emacs command), instead of bringing
+    up the popup.
+
+  - ~popup~
+
+    With a prefix argument bring up the popup, otherwise
+    directly invoke the popup's default action.
+
+  - ~nil~
+
+    Ignore prefix arguments.
+
+  This option can be overridden for individual popups.
+  ~magit-show-refs-popup~ for example defaults to invoking the default
+  action directly.  It only shows the popup buffer when a prefix
+  argument is used.  See [[*Customizing existing popups]].
+
+- User Option: magit-popup-manpage-package
+
+  The Emacs package used to display man-pages, one of ~man~ or ~woman~.
+
+To emphasize the default action by making it bold use this:
+
+#+BEGIN_SRC emacs-lisp
+  (button-type-put 'magit-popup-action-button 'format " %k %D")
+#+END_SRC
+
+* Defining prefix and suffix commands
+
+If you write an extension for Magit then you should use this library
+now and later when ~transient~ is released port to that.
+
+If you are considering using this library to define popups for
+packages not related to Magit, then keep in mind that it will be
+superseded eventually.  Once ~transient~ has been released I will only
+fix bugs in ~magit-popup~ but not implement any new features.
+
+Also consider using ~hydra~ instead.  To some extend ~magit-popup~ and
+~hydra~ are similar but have a different focus.  The main purpose of
+~magit-popup~ is to pass infix arguments to suffix commands.  If all you
+need is a command dispatcher then you are better of using ~hydra~.  Of
+course ~hydra~ may also be a better fit not only because of the features
+it lacks, but also because of the features it provides, which are in
+turn missing from ~magit-popup~.
+
+Here is an example of how one defines a prefix command along with its
+infix arguments, and then also one of its suffix commands.
+
+#+BEGIN_SRC emacs-lisp
+  ;;;###autoload (autoload 'magit-tag-popup "magit" nil t)
+  (magit-define-popup magit-tag-popup
+    "Show popup buffer featuring tagging commands."
+    'magit-commands
+    :man-page "git-tag"
+    :switches '((?a "Annotate" "--annotate")
+                (?s "Sign"     "--sign")
+                (?f "Force"    "--force"))
+    :actions  '((?t "Create"   magit-tag)
+                (?k "Delete"   magit-tag-delete)
+                (?p "Prune"    magit-tag-prune))
+    :default-action 'magit-tag)
+
+  ;;;###autoload
+  (defun magit-tag (name rev &optional args)
+    "Create a new tag with the given NAME at REV."
+    (interactive (list (magit-read-tag "Tag name")
+                       (magit-read-branch-or-commit "Place tag on")
+                       (magit-tag-arguments)))
+    (magit-run-git-with-editor "tag" args name rev))
+#+END_SRC
+
+** Defining prefix commands
+
+Prefix commands and their infix arguments are defined using the macro
+~magit-define-popup~.  The key bindings and descriptions of suffix
+commands are also defined using that macro, but the actual interactive
+commands have to be defined separately using plain ~defun~.
+
+- Macro: magit-define-popup name doc [group [mode [option]]] :keyword value...
+
+  This macro defines a popup named NAME.  The NAME should begin with
+  the package prefix and by convention end with ~-popup~, it is used
+  as the name of the command which shows the popup and for an internal
+  variable (whose value is used to store information about the popup
+  and should not be accessed directly).  DOC is the doc-string of the
+  popup command.
+
+  This macro also defines an option and a function both named
+  ~SHORTNAME-arguments~, where SHORTNAME is NAME with the trailing
+  ~-popup~ removed.  The name of this option and this function can be
+  overwritten using the optional argument OPTION, but that is rarely
+  advisable. As a special case if OPTION is specified but ~nil~, then
+  this option and this function are not defined at all, which is
+  useful for popups that are used as simple dispatchers that offer no
+  arguments.
+
+  The option ~SHORTNAME-arguments~ holds the value for the popup
+  arguments.  It can be customized from within the popup or using the
+  Custom interface.  It can also have a buffer local value in any
+  non-popup buffer.  The local value for the buffer from which the
+  popup command was invoked, can be set from within the popup buffer.
+
+  The function ~SHORTNAME-arguments~ returns the currently effective
+  value of the variable by the same name.  See below for more
+  information.
+
+  The optional argument GROUP specifies the Custom group in which the
+  option is placed.  If omitted then the option is placed in some
+  group the same way it is done when directly using ~defcustom~ and
+  omitting the group.
+
+  The optional argument MODE specifies the mode used by the popup
+  buffer.  If it is omitted or ~nil~ then ~magit-popup-mode~ is used.
+
+  The remaining arguments should have the form ~[KEYWORD VALUE]...~.
+
+  The following keywords are meaningful (and by convention are
+  usually specified in that order):
+
+  - ~:actions~
+
+    The actions which can be invoked from the popup.  VALUE is a list
+    whose members have the form (KEY DESC COMMAND), see
+    ~magit-define-popup-action~ for details.
+
+    How the actions are split into rows and columns currently depends
+    on the available space and ~:max-action-columns~.
+
+    WARNING: This will likely be change to use a more explicit format
+    (((KEY DESC COMMAND)...)...) before the release.
+
+    Actions are regular Emacs commands, which usually have an
+    ~interactive~ form setup to consume the values of the popup
+    ~:switches~ and ~:options~ when invoked from the corresponding popup,
+    else when invoked as the default action or directly without using
+    the popup, the default value of the variable ~SHORTNAME-arguments~.
+    This is usually done by calling the function ~SHORTNAME-arguments~.
+
+    Members of VALUE may also be strings, assuming the first member is
+    also a string.  Instead of just one action section with the
+    heading \"Actions\", multiple sections are then inserted into the
+    popup buffer, using these strings as headings.
+
+    Members of VALUE may also be nil.  This should only be used
+    together with ~:max-action-columns~ and allows having gaps in the
+    action grit, which can help arranging actions sensibly.
+
+  - ~:default-action~
+
+    The default action of the popup which is used directly instead of
+    displaying the popup buffer, when the popup is invoked with a
+    prefix argument.  Also see ~magit-popup-use-prefix-argument~ and
+    ~:use-prefix~, which can be used to inverse the meaning of the
+    prefix argument.
+
+  - ~:use-prefix~
+
+    Controls when to display the popup buffer and when to invoke the
+    default action (if any) directly.  This overrides the global
+    default set using ~magit-popup-use-prefix-argument~.  The value, if
+    specified, should be one of ~default~ or ~prefix~.
+
+  - ~:switches~
+
+    The popup arguments which can be toggled on and off.  VALUE is a
+    list whose members have the form ~(KEY DESC SWITCH)~, see
+    ~magit-define-popup-switch~ for details.
+
+  - ~:options~
+
+    The popup arguments which take a value, as in "--opt~OPTVAL".
+    VALUE is a list whose members have the form (KEY DESC OPTION
+    READER), see ~magit-define-popup-option~ for details.
+
+  - ~:default-arguments~
+
+    The default arguments, a list of switches (which are then enabled
+    by default) and options with there default values, as in
+    "--OPT~OPTVAL\".
+
+  - ~:man-page~
+
+    The name of the manpage to be displayed when the user requests
+    help for an argument.
+
+  When MODE is ~magit-popup-sequence-mode~, then the following keywords
+  are also meaningful:
+
+  - ~:sequence-predicate~
+
+    When this function returns non-nil, then the popup uses
+    ~:sequence-actions~ instead of ~:actions~, and does not show the
+    ~:switches~ and ~:options~.
+
+  - ~:sequence-actions~
+
+    The actions which can be invoked from the popup, when
+    ~:sequence-predicate~ returns non-nil.
+
+** Defining suffix commands
+
+Commands intended to be invoked from a particular popup should
+determine the currently effective arguments by calling the function
+~SHORTNAME-arguments~ inside their ~interactive~ form.  This function
+is created by the ~magit-define-popup~ macro.  For a popup named
+~prefix-foo-popup~ the name of this function is ~prefix-foo-arguments~.
+
+When the command was invoked as an action in the respective popup,
+then this function returns the arguments that were set in the popup.
+Otherwise when the command was invoked as the default of the popup (by
+calling the popup command with a prefix argument), or without using
+the popup command at all, then this function returns the buffer-local
+or global value of the variable ~SHORTNAME-arguments~.
+
+Internally arguments are handled as a list of strings.  This might not
+be appropriate for the intended use inside commands, or it might be
+necessary to manipulate that list somehow, i.e. to split "--ARG=VAL"
+into "--ARG""VAL".  This should be done by advising or redefining the
+function ~SHORTNAME-arguments~.
+
+Internally ~SHORNAME-arguments~ used following variables and function.
+Except when redefining the former, you should not use these directly.
+
+- Variable: magit-current-popup
+
+  The popup from which this editing command was invoked.
+
+- Variable: magit-current-popup-args
+
+  The value of the popup arguments for this editing command.
+
+  If the current command was invoked from a popup, then this is a list
+  of strings of all the set switches and options.  This includes
+  arguments which are set by default not only those explicitly set
+  during this invocation.
+
+  When the value is nil, then that can be because no argument is set,
+  or because the current command wasn't invoked from a popup at all.
+
+- Function: magit-current-popup-args &rest args
+
+  This function returns the value of the popup arguments for this
+  editing command.  The value is the same as that of the variable by
+  the same name, except that FILTER is applied.  FILTER is a list of
+  regexps; only arguments that match one of them are returned.  The
+  first element of FILTER may also be ~:not~ in which case only
+  arguments that don't match any of the regexps are returned, or ~:only~
+  which doesn't change the behavior.
+
+#  LocalWords:  ARG DESC KEY's LocalWords Magit OPTVAL POPUP PREPEND
+#  LocalWords:  Popup SHORTNAME args desc magit manpage popup popup's
+#  LocalWords:  popups pre prepend
diff --git a/Documentation/magit.org b/Documentation/magit.org
new file mode 100644
index 0000000..a68658f
--- /dev/null
+++ b/Documentation/magit.org
@@ -0,0 +1,5426 @@
+#+TITLE: Magit User Manual
+#+AUTHOR: Jonas Bernoulli
+#+EMAIL: jonas@bernoul.li
+#+DATE: 2015
+#+LANGUAGE: en
+
+#+TEXINFO_DIR_CATEGORY: Emacs
+#+TEXINFO_DIR_TITLE: Magit: (magit).
+#+TEXINFO_DIR_DESC: Using Git from Emacs with Magit.
+#+SUBTITLE: for version 2.3
+
+#+OPTIONS: H:4 num:3 toc:2
+#+STARTUP: indent
+
+* Copying
+:PROPERTIES:
+:COPYING:    t
+:END:
+
+#+BEGIN_TEXINFO
+@ifnottex
+Magit is an interface to the version control system Git, implemented
+as an Emacs package.  Magit aspires to be a complete Git porcelain.
+While we cannot (yet) claim that Magit wraps and improves upon each
+and every Git command, it is complete enough to allow even experienced
+Git users to perform almost all of their daily version control tasks
+directly from within Emacs.  While many fine Git clients exist, only
+Magit and Git itself deserve to be called porcelains.
+@end ifnottex
+
+@quotation
+Copyright (C) 2015 Jonas Bernoulli <jonas@@bernoul.li>
+
+You can redistribute this document and/or modify it under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or (at your option) any
+later version.
+
+This document is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+@end quotation
+#+END_TEXINFO
+
+* Introduction
+
+Magit is an interface to the version control system Git, implemented
+as an Emacs package.  Magit aspires to be a complete Git porcelain.
+While we cannot (yet) claim that Magit wraps and improves upon each
+and every Git command, it is complete enough to allow even experienced
+Git users to perform almost all of their daily version control tasks
+directly from within Emacs.  While many fine Git clients exist, only
+Magit and Git itself deserve to be called porcelains.
+
+Staging and otherwise applying changes is one of the most important
+features in a Git porcelain and here Magit outshines anything else,
+including Git itself.  Git's own staging interface (~git add --patch~)
+is so cumbersome that many users only use it in exceptional cases.
+In Magit staging a hunk or even just part of a hunk is as trivial as
+staging all changes made to a file.
+
+The most visible part of Magit's interface is the status buffer, which
+displays information about the current repository.  Its content is
+created by running several Git commands and making their output
+actionable.  Among other things, it displays information about the
+current branch, lists unpulled and unpushed changes and contains
+sections displaying the staged and unstaged changes.  That might sound
+noisy, but, since sections are collapsible, it's not.
+
+To stage or unstage a change one places the cursor on the change and
+then types ~s~ or ~u~.  The change can be a file or a hunk, or when the
+region is active (i.e. when there is a selection) several files or
+hunks, or even just part of a hunk.  The change or changes that these
+commands - and many others - would act on are highlighted.
+
+Magit also implements several other "apply variants" in addition to
+staging and unstaging.  One can discard or reverse a change, or
+apply it to the working tree.  Git's own porcelain only supports this
+for staging and unstaging and you would have to do something like ~git
+diff ... | ??? | git apply ...~ to discard, revert, or apply a single
+hunk on the command line.  In fact that's exactly what Magit does
+internally (which is what lead to the term "apply variants").
+
+Magit isn't just for Git experts, but it does assume some prior
+experience with Git as well as Emacs.  That being said, many users
+have reported that using Magit was what finally taught them what Git
+is capable of and how to use it to its fullest.  Other users
+wished they had switched to Emacs sooner so that they would have
+gotten their hands on Magit earlier.
+
+While one has to know the basic features of Emacs to be able to make
+full use of Magit, acquiring just enough Emacs skills doesn't take
+long and is worth it, even for users who prefer other editors.  Vim
+users are advised to give [[https://bitbucket.org/lyro/evil/wiki/Home][Evil]], the "Extensible VI Layer for Emacs",
+and [[https://github.com/syl20bnr/spacemacs][Spacemacs]], an "Emacs starter-kit focused on Evil" a try.
+
+Magit provides a consistent and efficient Git porcelain.  After a
+short learning period, you will be able to perform most of your daily
+version control tasks faster than you would on the command line.  You
+will likely also start using features that seemed too daunting in the
+past.
+
+Magit fully embraces Git.  It exposes many advanced features using a
+simple but flexible interface instead of only wrapping the trivial
+ones like many GUI clients do.  Of course Magit supports logging,
+cloning, pushing, and other commands that usually don't fail in
+spectacular ways; but it also supports tasks that often cannot be
+completed in a single step.  Magit fully supports tasks such as
+merging, rebasing, cherry-picking, reverting, and blaming by not only
+providing a command to initiate these tasks but also by displaying
+context sensitive information along the way and providing commands
+that are useful for resolving conflicts and resuming the sequence
+after doing so.
+
+Magit wraps and in many cases improves upon at least the following Git
+porcelain commands: ~add~, ~am~, ~bisect~, ~blame~, ~branch~,
+~checkout~, ~cherry~, ~cherry-pick~, ~clean~, ~clone~, ~commit~,
+~config~, ~describe~, ~diff~, ~fetch~, ~format-patch~, ~init~, ~log~,
+~merge~, ~merge-tree~, ~mv~, ~notes~, ~pull~, ~rebase~, ~reflog~,
+~remote~, ~request-pull~, ~reset~, ~revert~, ~rm~, ~show~, ~stash~,
+~submodule~, and ~tag~.  Many more Magit porcelain commands are
+implemented on top of Git plumbing commands.
+
+* Installation
+
+Magit can be installed using Emacs' package manager or manually from
+its development repository.
+
+** Updating from an older release
+
+When updating from ~1.2.*~ or ~1.4.*~, you should first uninstall Magit
+and some of its dependencies and restart Emacs before installing the
+latest release.
+
+- The old Magit installation has to be removed because some macros
+  have changed and using the old definitions when building the new
+  release would lead to very strange results, including compile
+  errors.  This is due to a limitation in Emacs' package manager or
+  rather Emacs itself: it's not possible to reliably unload a feature
+  or even all features belonging to a package.
+
+- Furthermore the old dependencies ~git-commit-mode~ and ~git-rebase-mode~
+  have to be removed because they are no longer used by the ~2.1.0~
+  release and later, and get in the way of their successors ~git-commit~
+  and ~git-rebase~.
+
+So please uninstall the packages ~magit~, ~git-commit-mode~, and
+~git-rebase-mode~.  Then quit Emacs and start a new instance.  Only then
+follow the instructions in either one of the next two sections.
+
+Also note that starting with the ~2.1.0~ release, Magit requires at least
+Emacs ~24.4~ and Git ~1.9.4~.  You should make sure you have at least
+these releases installed before updating Magit.  And if you connect to
+remote hosts using Tramp, then you should also make sure to install a
+recent enough Git version on these hosts.
+
+** Installing from an Elpa archive
+
+If you are updating from a release older than ~2.1.0~, then you have to
+first uninstall the old version.  See [[*Updating from an older release]].
+
+Magit is available from all three of the popular unofficial Elpa
+archives: Melpa, Melpa-Stable, and Marmalade.  If you haven't used
+Emacs' package manager before, then it is high time you familiarize
+yourself with it by reading the documentation in the Emacs manual,
+see [[info:emacs#Packages]].  Then add one of the archives to ~package-archives~:
+
+- To use Melpa:
+
+#+BEGIN_SRC emacs-lisp
+  (require 'package)
+  (add-to-list 'package-archives
+               '("melpa" . "http://melpa.org/packages/") t)
+#+END_SRC
+
+- To use Melpa-Stable:
+
+#+BEGIN_SRC emacs-lisp
+  (require 'package)
+  (add-to-list 'package-archives
+               '("melpa-stable" . "http://stable.melpa.org/packages/") t)
+#+END_SRC
+
+- To use Marmalade:
+
+#+BEGIN_SRC emacs-lisp
+  (require 'package)
+  (add-to-list 'package-archives
+               '("marmalade" . "http://marmalade-repo.org/packages/") t)
+#+END_SRC
+
+Once you have added your preferred archive, you need to update the
+local package list using:
+
+#+BEGIN_SRC undefined
+  M-x package-refresh-contents RET
+#+END_SRC
+
+Once you have done that, you can install Magit and its dependencies
+using:
+
+#+BEGIN_SRC undefined
+  M-x package-install RET magit RET
+#+END_SRC
+
+Now see [[*Post-installation tasks]].
+
+** Installing from the Git repository
+
+If you are updating from a release older than ~2.1.0~, then you have to
+first uninstall the old version.  See [[*Updating from an older release]].
+
+Magit depends on the ~dash~ library, available from all three of the
+popular third-party Elpa archives.  Install it using ~M-x
+package-install RET dash RET~.  Of course you may also install it
+manually from its development repository, but I won't cover that here.
+
+Then clone the Magit repository:
+
+#+BEGIN_SRC shell
+  $ git clone git://github.com/magit/magit.git ~/.emacs.d/site-lisp/magit
+  $ cd ~/.emacs.d/site-lisp/magit
+#+END_SRC
+
+Then compile the libraries and generate the info manuals:
+
+#+BEGIN_SRC shell
+  $ make
+#+END_SRC
+
+If you haven't installed ~dash~ using Elpa or at ~/path/to/magit/../dash~,
+then you have to tell ~make~ where to find it.  To do so create
+~/path/to/magit/config.mk~ with the following content before running
+~make~:
+
+#+BEGIN_SRC makefile
+  LOAD_PATH = -L /path/to/magit/lisp -L /path/to/dash
+#+END_SRC
+
+Finally add this to your init file:
+
+#+BEGIN_SRC emacs-lisp
+  (add-to-list 'load-path "~/.emacs.d/site-lisp/magit/lisp")
+  (require 'magit)
+
+  (with-eval-after-load 'info
+    (info-initialize)
+    (add-to-list 'Info-directory-list
+                 "~/.emacs.d/site-lisp/magit/Documentation/"))
+#+END_SRC
+
+Note that you have to add the ~lisp/~ subdirectory to the ~load-path~,
+not the top-level of the repository.
+
+Instead of requiring the feature ~magit~, you could only load the
+autoloads, by loading the file ~magit-autoloads.el~.
+
+Instead of running Magit directly from the repository by adding that
+to the ~load-path~, you might want to instead install it in some other
+directory using ~sudo make install~ and setting ~load-path~ accordingly.
+
+To update Magit use:
+
+#+BEGIN_SRC shell
+  $ git pull
+  $ make
+#+END_SRC
+
+At times it might be necessary to run ~make clean all~ instead.
+
+To view all available targets use ~make help~.
+
+Now see [[*Post-installation tasks]].
+
+** Post-installation tasks
+
+After installing Magit you should verify that you are indeed using the
+Magit, Git, and Emacs releases you think you are using.  It's best to
+restart Emacs before doing so, to make sure you are not using an
+outdated value for ~load-path~.
+
+#+BEGIN_SRC undefined
+  M-x magit-version RET
+#+END_SRC
+
+should display something like
+
+#+BEGIN_SRC undefined
+  Magit 2.2.0, Git 2.4.2, Emacs 24.5.1
+#+END_SRC
+
+Then you might also want to read about options that many users likely
+want to customize.  See [[*Essential settings]].
+
+To be able to follow cross references to Git manpages found in this
+manual, you might also have to manually install the ~gitman~ info manual,
+or advice ~Info-follow-nearest-node~ to instead open the actual manpage.
+See [[*How to install the gitman info manual?]].
+
+If you are completely new to Magit then see [[*Getting started]].
+
+If you have used an older Magit release before, then you should have a
+look at the release notes
+https://raw.githubusercontent.com/magit/magit/master/Documentation/RelNotes/2.1.0.txt
+and
+https://raw.githubusercontent.com/magit/magit/master/Documentation/RelNotes/2.2.0.txt
+
+And last but not least please consider making a donation, to ensure
+that I can keep working on Magit.  See http://magit.vc/donations.html
+for various donation options.
+
+* Getting started
+
+This section describes the most essential features that many
+Magitians use on a daily basis.  It only scratches the surface but
+should be enough to get you started.
+
+(You might want to create a repository just for this walk-through,
+e.g. by cloning an existing repository.  If you don't use a separate
+repository then make sure you create a snapshot as described below).
+
+To display information about the current Git repository, type ~M-x
+magit-status~.  You will be doing that so often that it is best to bind
+this command globally:
+
+#+BEGIN_SRC emacs-lisp
+  (global-set-key (kbd "C-x g") 'magit-status)
+#+END_SRC
+
+Most Magit commands are commonly invoked from this buffer.  It should
+be considered the primary interface to interact with Git using Magit.
+There are many other Magit buffers, but they are usually created from
+this buffer.
+
+Depending on what state your repository is in, this buffer will
+contain sections titled "Staged changes", "Unstaged changes",
+"Unpulled commits", "Unpushed commits", and/or some others.
+
+If some staged and/or unstaged changes exist, you should back them up
+now.  Type ~z~ to show the stashing popup buffer featuring various stash
+variants and arguments that can be passed to these commands.  Do not
+worry about those for now, just type ~Z~ (uppercase) to create a stash
+while also keeping the index and work tree intact.  The status buffer
+should now also contain a section titled "Stashes".
+
+Otherwise, if there are no uncommitted changes, you should create some
+now by editing and saving some of the tracked files.  Then go back to
+the status buffer, while at the same time refreshing it, by typing ~C-x
+g~.  (When the status buffer, or any Magit buffer for that matter, is
+the current buffer, then you can also use just ~g~ to refresh it).
+
+Move between sections using ~p~ and ~n~.  Note that the bodies of some
+sections are hidden.  Type ~TAB~ to expand or collapse the section at
+point.  You can also use ~C-tab~ to cycle the visibility of the current
+section and its children. Move to a file section inside the section
+named "Unstaged changes" and type ~s~ to stage the changes you have made
+to that file. That file now appears under "Staged changes".
+
+Magit can stage and unstage individual hunks, not just complete files.
+Move to the file you have just staged, expand it using ~TAB~, move to
+one of the hunks using ~n~, and unstage just that by typing ~u~.  Note how
+the staging (~s~) and unstaging (~u~) commands operate on the change at
+point.  Many other commands behave the same way.
+
+You can also un-/stage just part of a hunk.  Inside the body of a hunk
+section (move there using ~C-n~), set the mark using ~C-SPC~ and move down
+until some added and removed lines fall inside the region but not all
+of them.  Again type ~s~ to stage.
+
+It's also possible to un-/stage multiple files at once.  Move to a
+file section, type ~C-SPC~, move to the next file using ~n~, and then ~s~ to
+stage both files.  Note that both the mark and point have to be on the
+headings of sibling sections for this to work.  If the region looks
+like it does in other buffers, then it doesn't select Magit sections
+that can be acted on as a unit.
+
+And then of course you want to commit your changes.  Type ~c~.  This
+shows the committing popup buffer featuring various commit variants
+and arguments that can be passed to ~git commit~.  Do not worry about
+those for now.  We want to create a "normal" commit, which is done by
+typing ~c~ again.
+
+Now two new buffers appear.  One is for writing the commit message,
+the other shows a diff with the changes that are about to committed.
+Write a message and then type ~C-c C-c~ to actually create the commit.
+
+You probably don't want to push the commit you just created because
+you just committed some random changes, but if that is not the case
+you could push it by typing ~P~ to bring up the push popup and then ~P~
+again to push to the configured upstream.  (If the upstream is not
+configured, then you would be prompted for the push target instead.)
+
+Instead we are going to undo the changes made so far.  Bring up the
+log for the current branch by typing ~l l~, move to the last commit
+created before starting with this walk through using ~n~, and do a hard
+reset using ~C-u x~.  *WARNING*: this discards all uncommitted changes.
+If you did not follow the advice about using a separate repository for
+these experiments and did not create a snapshot of uncommitted changes
+before starting to try out Magit, then don't do this.
+
+So far we have mentioned the commit, push, and log popups.  These are
+probably among the popups you will be using the most, but many others
+exist.  To show a popup with all other popups (as well as the various
+apply commands), type ~h~.  Try a few.
+
+The key bindings in that popup correspond to the bindings in Magit
+buffers, including but not limited to the status buffer.  So you could
+type ~h d~ to bring up the diff popup, but once you remember that "d"
+stands for "diff", you would usually do so by just typing ~d~.  But the
+"popup of popups" is useful even once you have memorized all the
+bindings, as it can provide easy access to Magit commands from
+non-Magit buffers.  So you should bind this globally too:
+
+#+BEGIN_SRC emacs-lisp
+  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
+#+END_SRC
+
+You might also want to enable ~global-magit-file-mode~ (see [[*Minor mode
+for buffers visiting files]]).
+
+* Interface concepts
+** Modes and Buffers
+
+Magit provides several major-modes.  For each of these modes there
+usually exists only one buffer per repository.  Separate modes and
+thus buffers exist for commits, diffs, logs, and some other things.
+
+Besides these special purpose buffers, there also exists an overview
+buffer, called the *status buffer*.  Its usually from this buffer that
+the user invokes Git commands, or creates or visits other buffers.
+
+In this manual we often speak about "Magit buffers".  By that we mean
+buffers whose major-modes derive from ~magit-mode~.
+
+- Key: M-x magit-toggle-buffer-lock, magit-toggle-buffer-lock
+
+  This command locks the current buffer to its value or if the buffer
+  is already locked, then it unlocks it.
+
+  Locking a buffer to its value, prevents it from being reused to
+  display another value.  The name of a locked buffer contains its
+  value, which allows telling it apart from other locked buffers and
+  the unlocked buffer.
+
+  Not all Magit buffers can be locked to their values, for example it
+  wouldn't make sense to lock a status buffer.
+
+  There can only be a single unlocked buffer using a certain
+  major-mode per repository.  So when a buffer is being unlocked and
+  another unlocked buffer already exists for that mode and repository,
+  then the former buffer is instead deleted and the latter is
+  displayed in its place.
+
+*** Switching Buffers
+
+- Function: magit-display-buffer buffer
+
+  This function is a wrapper around ~display-buffer~ and is used to
+  display any Magit buffer.  It displays BUFFER in some window and,
+  unlike ~display-buffer~, also selects that window, provided
+  ~magit-display-buffer-noselect~ is ~nil~.  It also runs the hooks
+  mentioned below.
+
+- Variable: magit-display-buffer-noselect
+
+  When this is non-nil, then ~magit-display-buffer~ only displays the
+  buffer but forgoes also selecting the window.  This variable should
+  not be set globally, it is only intended to be let-bound, by code
+  that automatically updates "the other window".  This is used for
+  example when the revision buffer is updated when you move inside the
+  log buffer.
+
+- User Option: magit-display-buffer-function
+
+  The function specified here is called by ~magit-display-buffer~ with
+  one argument, a buffer, to actually display that buffer.  This
+  function should call ~display-buffer~ with that buffer as first and a
+  list of display actions as second argument.
+
+  Instead of using a wrapper around ~display-buffer~, that function
+  itself can be used here, in which case the display actions have to
+  be specified by adding them to ~display-buffer-alist~ instead.
+
+  To learn about display actions, see [[info:elisp#Choosing a Window for
+  Display]].
+
+- Function: magit-display-buffer-traditional buffer
+
+  This function is the current default value of the option
+  ~magit-display-buffer-function~.  Before that option and this function
+  were added, the behavior was hard-coded in many places all over the
+  code base but now all the rules are contained in this one function
+  (except for the "noselect" special case mentioned above).
+
+  If you want to use different rules, then a good way of doing that is
+  to start with a copy of this function and then adjust it to your
+  needs.  More functions to choose from will be added in the future,
+  and eventually the default will change.
+
+- User Option: magit-pre-display-buffer-hook
+
+  This hook is run by ~magit-display-buffer~ before displaying the
+  buffer.
+
+- Function: magit-save-window-configuration
+
+  This function saves the current window configuration.  Later when
+  the buffer is buried, it may be restored by
+  ~magit-restore-window-configuration~.
+
+- User Option: magit-post-display-buffer-hook
+
+  This hook is run by ~magit-display-buffer~ after displaying the
+  buffer.
+
+- Function: magit-maybe-set-dedicated
+
+  This function remembers if a new window had to be created to display
+  the buffer, or whether an existing window was reused.  This
+  information is later used by ~magit-mode-quit-window~, to determine
+  whether the window should be deleted when its last Magit buffer is
+  buried.
+
+*** Naming Buffers
+
+- User Option: magit-generate-buffer-name-function
+
+  The function used to generate the names of Magit buffers.
+
+  Such a function should take the options ~magit-uniquify-buffer-names~
+  as well as ~magit-buffer-name-format~ into account.  If it doesn't,
+  then should be clearly stated in the doc-string.  And if it supports
+  %-sequences beyond those mentioned in the doc-string of the option
+  ~magit-buffer-name-format~, then its own doc-string should describe
+  the additions.
+
+- Function: magit-generate-buffer-name-default-function mode
+
+  This function returns a buffer name suitable for a buffer whose
+  major-mode is MODE and which shows information about the repository
+  in which ~default-directory~ is located.
+
+  This function uses ~magit-buffer-name-format~ and supporting all of
+  the %-sequences mentioned the documentation of that option.  It also
+  respects the option ~magit-uniquify-buffer-names~.
+
+- User Option: magit-buffer-name-format
+
+  The format string used to name Magit buffers.
+
+  At least the following %-sequences are supported:
+
+  - ~%m~
+
+    The name of the major-mode, but with the ~-mode~ suffix removed.
+
+  - ~%M~
+
+    Like ~%m~ but abbreviate ~magit-status-mode~ as ~magit~.
+
+  - ~%v~
+
+    The value the buffer is locked to, in parentheses, or an empty
+    string if the buffer is not locked to a value.
+
+  - ~%V~
+
+    Like ~%v~, but the string is prefixed with a space, unless it is an
+    empty string.
+
+  - ~%t~
+
+    The top-level directory of the working tree of the repository, or
+    if ~magit-uniquify-buffer-names~ is non-nil an abbreviation of that.
+
+  The value should always contain either ~%m~ or ~%M~, ~%v~ or ~%V~, and ~%t~.
+  If ~magit-uniquify-buffer-names~ is non-nil, then the value must end
+  with ~%t~.
+
+- User Option: magit-uniquify-buffer-names
+
+  This option controls whether the names of Magit buffers are
+  uniquified.  If the names are not being uniquified, then they
+  contain the full path of the top-level of the working tree of the
+  corresponding repository.  If they are being uniquified, then they
+  end with the basename of the top-level, or if that would conflict
+  with the name used for other buffers, then the names of all these
+  buffers are adjusted until they no longer conflict.
+
+  This is done using the ~uniquify~ package; customize its options to
+  control how buffer names are uniquified.
+
+*** Quitting Windows
+
+- Key: q, magit-mode-bury-buffer
+
+  This command buries the current Magit buffer.  With a prefix
+  argument, it instead kills the buffer.
+
+- User Option: magit-bury-buffer-function
+
+  The function used to actually bury or kill the current buffer.
+
+  ~magit-mode-bury-buffer~ calls this function with one argument.  If
+  the argument is non-nil, then the function has to kill the current
+  buffer.  Otherwise it has to bury it alive.  The default value
+  currently is ~magit-restore-window-configuration~.
+
+- Function: magit-restore-window-configuration kill-buffer
+
+  Bury or kill the current buffer using ~quit-window~, which is called
+  with KILL-BUFFER as first and the selected window as second
+  argument.
+
+  Then restore the window configuration that existed right before the
+  current buffer was displayed in the selected frame.  Unfortunately
+  that also means that point gets adjusted in all the buffers, which
+  are being displayed in the selected frame.
+
+- Function: magit-mode-quit-window kill-buffer
+
+  Bury or kill the current buffer using ~quit-window~, which is called
+  with KILL-BUFFER as first and the selected window as second
+  argument.
+
+  Then, if the window was originally created to display a Magit buffer
+  and the buried buffer was the last remaining Magit buffer that was
+  ever displayed in the window, then that is deleted.
+
+** Automatic save
+
+File-visiting buffers are by default saved at certain points in time.
+This doesn't guarantee that Magit buffers are always up-to-date, but,
+provided one only edits files by editing them in Emacs and uses only
+Magit to interact with Git, one can be fairly confident.  When in
+doubt or after outside changes, type ~g~ (~magit-refresh~) to save and
+refresh explicitly.
+
+- User Option: magit-save-repository-buffers
+
+  This option controls whether file-visiting buffers are saved before
+  certain events.
+
+  If this is non-nil then all modified file-visiting buffers belonging
+  to the current repository may be saved before running commands,
+  before creating new Magit buffers, and before explicitly refreshing
+  such buffers.  If this is ~dontask~ then this is done without user
+  intervention.  If it is ~t~ then the user has to confirm each save.
+
+** Automatic refresh and revert
+
+After running a command which may change the state of the current
+repository, the current Magit buffer and the corresponding status
+buffer are refreshed.  Status buffer may optionally be automatically
+refreshed whenever a buffer is saved to a file inside the respective
+repository.
+
+Automatically refreshing Magit buffers ensures that the displayed
+information is up-to-date most of the time but can lead to a
+noticeable delay in big repositories.  Other Magit buffers are not
+refreshed to keep the delay to a minimum and also because doing so can
+sometimes be undesirable.
+
+- User Option: magit-revert-buffers
+
+  This option controls if and how file-visiting buffers in the current
+  repository are reverted.
+
+  Unmodified buffers visiting files belonging to the current
+  repository may be reverted after refreshing the current Magit buffer
+  and after running certain other commands.
+
+  - ~nil~
+
+    Don't revert any buffers.
+
+  - ~ask~
+
+    List the buffers which might potentially have to be reverted and
+    ask the user whether she wants to revert them.  If so, then do it
+    synchronously.
+
+  - ~t~
+
+    Revert the buffers synchronously, mentioning each one as it is
+    being reverted and then also show a summary in the echo area.
+
+  - ~usage~
+
+    Like ~t~ but include usage information in the summary.  This is the
+    default so that users come here and pick what is right for them.
+
+  - ~silent~
+
+    Revert the buffers synchronously and be quiet about it.
+
+    This is the recommended setting, because for the other values the
+    revert messages might prevent you from seeing other, more
+    important, messages in the echo area.
+
+  - NUMBER
+
+    An integer or float.  Revert the buffers asynchronously,
+    mentioning each one as it is being reverted.  If user input
+    arrives, then stop reverting.  After NUMBER seconds resume
+    reverting.
+
+Buffers can also be refreshed explicitly, which is useful in buffers
+that weren't current during the last refresh and after changes were
+made to the repository outside of Magit.
+
+- Key: g, magit-refresh
+
+  This command refreshes the current buffer if its major mode derives
+  from ~magit-mode~ as well as the corresponding status buffer.
+
+  If the option ~magit-revert-buffers~ calls for it, then it also
+  reverts all unmodified buffers that visit files being tracked in the
+  current repository.
+
+- Key: G, magit-refresh-all
+
+  This command refreshes all Magit buffers belonging to the current
+  repository and also reverts all unmodified buffers that visit files
+  being tracked in the current repository.
+
+  The file-visiting buffers are always reverted, even if
+  ~magit-revert-buffers~ is nil.
+
+- Function: magit-after-save-refresh-status
+
+  This function is intended to be added to ~after-save-hook~.  After
+  doing that the corresponding status buffer is refreshed whenever a
+  buffer is saved to a file inside a repository.
+
+  Note that refreshing a Magit buffer is done by re-creating its
+  contents from scratch, which can be slow in large repositories.  If
+  you are not satisfied with Magit's performance, then you should
+  obviously not add this function to that hook.
+  
+- User Option: magit-refresh-buffer-hook
+
+  This hook is run in each Magit buffer that was refreshed during the
+  current refresh - normally the current buffer and the status buffer.
+
+- User Option: magit-after-revert-hook
+
+  This hook is run in each file-visiting buffer belonging to the
+  current repository that was actually reverted during a refresh.
+
+  Note that adding something here is very expensive.  If you
+  experience performance issues, you might want to check this hook, as
+  well as ~magit-not-reverted-hook~ and, if possible, remove some of the
+  functions added by third-party packages.
+
+- User Option: magit-not-reverted-hook
+
+  This hook is run in each file-visiting buffer belonging to the
+  current repository that was _not_ reverted during a refresh.  The file
+  was not reverted because it did not change, and so Magit does not
+  have to do anything.  This hook is intended for third-party
+  extensions that need to run some functions even on such files.
+
+** Sections
+
+Magit buffers are organized into nested sections, which can be
+collapsed and expanded, similar to how sections are handled in Org
+mode.  Each section also has a type, and some sections also have a
+value.  For each section type there can also be a local keymap, shared
+by all sections of that type.
+
+Taking advantage of the section value and type, many commands operate on
+the current section, or when the region is active and selects sections
+of the same type, all of the selected sections.  Commands that only
+make sense for a particular section type (as opposed to just behaving
+differently depending on the type) are usually bound in section type
+keymaps.
+
+*** Section movement
+
+To move within a section use the usual keys (~C-p~, ~C-n~, ~C-b~, ~C-f~ etc),
+whose global bindings are not shadowed.  To move to another section use
+the following commands.
+
+- Key: p, magit-section-backward
+
+  When not at the beginning of a section, then move to the beginning
+  of the current section.  At the beginning of a section, instead move
+  to the beginning of the previous visible section.
+
+- Key: n, magit-section-forward
+
+  Move to the beginning of the next visible section.
+
+- Key: M-p, magit-section-backward-siblings
+
+  Move to the beginning of the previous sibling section.  If there is
+  no previous sibling section, then move to the parent section
+  instead.
+
+- Key: M-n, magit-section-forward-siblings
+
+  Move to the beginning of the next sibling section.  If there is no
+  next sibling section, then move to the parent section instead.
+
+- Key: ^, magit-section-up
+
+  Move to the beginning of the parent of the current section.
+
+The above commands all call the hook ~magit-section-movement-hook~.
+And, except for the second, the below functions are all members of
+that hook's default value.
+
+- Variable: magit-section-movement-hook
+
+  This hook is run by all of the above movement commands, after
+  arriving at the destination.
+
+- Function: magit-hunk-set-window-start
+
+  This hook function ensures that the beginning of the current section
+  is visible, provided it is a ~hunk~ section.  Otherwise, it does
+  nothing.
+
+- Function: magit-section-set-window-start
+
+  This hook function ensures that the beginning of the current section
+  is visible, regardless of the section's type.  If you add this to
+  ~magit-section-movement-hook~, then you must remove the hunk-only
+  variant in turn.
+
+- Function: magit-log-maybe-show-more-commits
+
+  This hook function only has an effect in log buffers, and ~point~ is
+  on the "show more" section.  If that is the case, then it doubles
+  the number of commits that are being shown.
+
+- Function: magit-log-maybe-update-revision-buffer
+
+  When moving inside a log buffer, then this function updates the
+  revision buffer, provided it is already being displayed in another
+  window of the same frame.
+
+- Function: magit-log-maybe-update-blob-buffer
+
+  When moving inside a log buffer and another window of the same frame
+  displays a blob buffer, then this function instead displays the blob
+  buffer for the commit at point in that window.
+
+- Function: magit-status-maybe-update-revision-buffer
+
+  When moving inside a status buffer, then this function updates the
+  revision buffer, provided it is already being displayed in another
+  window of the same frame.
+
+- Function: magit-status-maybe-update-blob-buffer
+
+  When moving inside a status buffer and another window of the same
+  frame displays a blob buffer, then this function instead displays
+  the blob buffer for the commit at point in that window.
+
+- User Option: magit-update-other-window-delay
+
+  Delay before automatically updating the other window.
+
+  When moving around in certain buffers certain other buffers, which
+  are being displayed in another window, may optionally be updated to
+  display information about the section at point.
+
+  When holding down a key to move by more than just one section, then
+  that would update that buffer for each section on the way.  To
+  prevent that, updating the revision buffer is delayed, and this
+  option controls for how long.  For optimal experience you might have
+  to adjust this delay and/or the keyboard repeat rate and delay of
+  your graphical environment or operating system.
+
+*** Section visibility
+
+Magit provides many commands for changing the visibility of sections,
+but all you need to get started are the next two.
+
+- Key: TAB, magit-section-toggle
+
+  Toggle the visibility of the body of the current section.
+
+- Key: C-<tab>, magit-section-cycle
+
+  Cycle the visibility of current section and its children.
+
+- Key: M-<tab>, magit-section-cycle-diffs
+
+  Cycle the visibility of diff-related sections in the current buffer.
+
+- Key: s-<tab>, magit-section-cycle-global
+
+  Cycle the visibility of all sections in the current buffer.
+
+#+KINDEX: 1
+#+KINDEX: 2
+#+KINDEX: 3
+#+KINDEX: 4
+- Command( magit-section-show-level-1
+- Command, magit-section-show-level-2
+- Command, magit-section-show-level-3
+- Command) magit-section-show-level-4
+
+  To show sections surrounding the current section, up to level N,
+  press the respective number key (~1~, ~2~, ~3~, or ~4~).
+
+#+KINDEX: M-1
+#+KINDEX: M-2
+#+KINDEX: M-3
+#+KINDEX: M-4
+- Command( magit-section-show-level-1-all
+- Command, magit-section-show-level-2-all
+- Command, magit-section-show-level-3-all
+- Command) magit-section-show-level-4-all
+
+  To show all sections up to level N, press the respective number key
+  and meta (~M-1~, ~M-2~, ~M-3~, or ~M-4~).
+
+Some functions, which are used to implement the above commands, are
+also exposed as commands themselves.  By default no keys are bound to
+these commands, as they are generally perceived to be much less
+useful.  But your mileage may vary.
+
+- Command: magit-section-show
+
+  Show the body of the current section.
+
+- Command: magit-section-hide
+
+  Hide the body of the current section.
+
+- Command: magit-section-show-headings
+
+  Recursively show headings of children of the current section.  Only
+  show the headings.  Previously shown text-only bodies are hidden.
+
+- Command: magit-section-show-children
+
+  Recursively show the bodies of children of the current section.
+  With a prefix argument show children down to the level of the
+  current section, and hide deeper children.
+
+- Command: magit-section-hide-children
+
+  Recursively hide the bodies of children of the current section.
+
+- Command: magit-section-toggle-children
+
+  Toggle visibility of bodies of children of the current section.
+
+When a buffer is first created then some sections are shown expanded
+while others are not.  This is hard coded.  When a buffer is refreshed
+then the previous visibility is preserved. The initial visibility of
+certain sections can also be overwritten using the hook
+~magit-section-set-visibility-hook~.
+
+- Variable: magit-section-set-visibility-hook
+
+  This hook is run when first creating a buffer and also when
+  refreshing an existing buffer, and is used to determine the
+  visibility of the section currently being inserted.
+
+  Each function is called with one argument, the section being
+  inserted.  It should return ~hide~ or ~show~, or to leave the visibility
+  undefined ~nil~.  If no function decides on the visibility and the
+  buffer is being refreshed, then the visibility is preserved; or if
+  the buffer is being created, then the hard coded default is used.
+
+  Usually this should only be used to set the initial visibility but
+  not during refreshes.  If ~magit-insert-section--oldroot~ is non-nil,
+  then the buffer is being refreshed and these functions should
+  immediately return ~nil~.
+
+*** Section hooks
+
+Which sections are inserted into certain buffers is controlled with
+hooks.  This includes the status and the refs buffers.  For other
+buffers, e.g. log, diff, and revision buffers, this is not possible.
+
+For buffers whose sections can be customized by the user, a hook
+variable called ~magit-TYPE-sections-hook~ exists.  This hook should be
+changed using ~magit-add-section-hook~.  Avoid using ~add-hooks~ or the
+Custom interface.
+
+The various available section hook variables are described later in
+this manual along with the appropriate "section inserter functions".
+
+- Function: magit-add-section-hook hook function &optional at append local
+
+  Add the function FUNCTION to the value of section hook HOOK.
+
+  Add FUNCTION at the beginning of the hook list unless optional
+  APPEND is non-nil, in which case FUNCTION is added at the end.  If
+  FUNCTION already is a member then move it to the new location.
+
+  If optional AT is non-nil and a member of the hook list, then add
+  FUNCTION next to that instead.  Add before or after AT depending
+  on APPEND.  If only FUNCTION is a member of the list, then leave
+  it wherever it already is.
+
+  If optional LOCAL is non-nil, then modify the hook's buffer-local
+  value rather than its global value.  This makes the hook local by
+  copying the default value.  That copy is then modified.
+
+  HOOK should be a symbol.  If HOOK is void, it is first set to nil.
+  HOOK's value must not be a single hook function.  FUNCTION should
+  be a function that takes no arguments and inserts one or multiple
+  sections at point, moving point forward.  FUNCTION may choose not
+  to insert its section(s), when doing so would not make sense.  It
+  should not be abused for other side-effects.
+
+To remove a function from a section hook, use ~remove-hook~.
+
+*** Section types and values
+
+Each section has a type, for example ~hunk~, ~file~, and ~commit~.
+Instances of certain section types also have a value.  The value of a
+section of type ~file~, for example, is a file name.
+
+Users usually do not have to worry about a section's type and value,
+but knowing them can be handy at times.
+
+- Key: M-x magit-describe-section, magit-describe-section
+
+  Show information about the section at point in the echo area,
+  as "VALUE [TYPE PARENT-TYPE...] BEGINNING-END".
+
+Many commands behave differently depending on the type of the section
+at point and/or somehow consume the value of that section.  But that
+is only one of the reasons why the same key may do something different,
+depending on what section is current.
+
+Additionally for each section type a keymap *might* be defined, named
+~magit-TYPE-section-map~.  That keymap is used as text property keymap
+of all text belonging to any section of the respective type.  If such
+a map does not exist for a certain type, then you can define it
+yourself, and it will automatically be used.
+
+*** Section options
+
+This section describes options that have an effect on more than just a
+certain type of sections.  As you can see there are not many of those.
+
+- User Option: magit-section-show-child-count
+
+  Whether to append the number of children to section headings.  This
+  only affects sections that could benefit from this information.
+
+** Popup buffers and prefix commands
+
+Many Magit commands are implemented using *popup buffers*.  First the
+user invokes a *popup* or *prefix* command, which causes a popup buffer
+with the available *infix* arguments and *suffix* commands to be
+displayed.  The user then optionally toggles/sets some arguments and
+finally invokes one of the suffix commands.
+
+This is implemented in the library ~magit-popup~.  Earlier releases used
+the library ~magit-key-mode~.  A future release will switch to a
+yet-to-be-written successor, which will likely be named ~transient~.
+
+Because ~magit-popup~ can also be used by other packages without having
+to depend on all of Magit, it is documented in its own manual.  See
+[[info:magit-popup]].
+
+- Key: C-c C-c, magit-dispatch-popup
+
+  This popup command shows a buffer featuring all other Magit popup
+  commands as well as some other commands that are not popup commands
+  themselves.
+
+This command is also, or especially, useful outside Magit buffers, so
+you should setup a global binding:
+
+#+BEGIN_SRC emacs-lisp
+  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
+#+END_SRC
+
+** Completion and confirmation
+
+Many commands read a value from the user.  By default this is done
+using the built-in function ~completing-read~, but Magit can instead use
+another completion framework.
+
+- User Option: magit-completing-read-function
+
+  The value of this variable is the function used to perform
+  completion.  Because functions /intended/ to replace ~completing-read~
+  often are not fully compatible drop-in replacements, and also
+  because Magit expects them to add the default choice to the prompt
+  themselves, such functions should not be used directly.  Instead a
+  wrapper function has to be used.
+
+Currently only the real ~completing-read~ and [[http://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] are fully supported.
+More frameworks will be supported in the future.
+
+- Function: magit-builtin-completing-read prompt choices &optional predicate require-match initial-input hist def
+
+  Perform completion using ~completion-read~.
+
+- Function: magit-ido-completing-read prompt choices &optional predicate require-match initial-input hist def
+
+  Perform completion using ~ido-completing-read+~ from the package by
+  the same name (which you have to explicitly install).  Ido itself
+  comes with a supposed drop-in replacement ~ido-completing-read~, but
+  that has too many deficits to serve our needs.
+
+By default many commands that could potentially lead to data loss have
+to be confirmed.  This includes many very common commands, so this
+can become annoying quickly.  Many of these actions can be undone,
+provided ~magit-wip-before-change-mode~ is turned on (which it is not by
+default, due to performance concerns).
+
+- User Option: magit-no-confirm
+
+  The value of this option is a list of symbols, representing commands
+  which do not have to be confirmed by the user before being carried
+  out.
+
+  When the global mode ~magit-wip-before-change-mode~ is enabled then
+  many commands can be undone.  If that mode is enabled then adding
+  ~safe-with-wip~ to this list has the same effect as adding ~discard~,
+  ~reverse~, ~stage-all-changes~, and ~unstage-all-changes~.
+
+  #+BEGIN_SRC emacs-lisp
+    (add-to-list 'magit-no-confirm 'safe-with-wip)
+  #+END_SRC
+
+  For a list of all symbols that can be added to the value of this
+  variable, see the doc-string.
+
+Note that there are commands that ignore this option and always
+require confirmation, or which can be told not to do so using another
+dedicated option.  Also most commands, when acting on multiple sections
+at once always, require confirmation, even when they do respect this
+option when acting on a single section.
+
+** Running Git
+*** Viewing Git output
+
+Magit runs Git either for side-effects (e.g. when pushing) or to get
+some value (e.g. the name of the current branch).  When Git is run for
+side-effects then the output goes into a per-repository log buffer,
+which can be consulted when things don't go as expected.
+
+- Key: $, magit-process
+
+  This commands displays the process buffer for the current
+  repository.
+
+Inside that buffer, the usual key bindings for navigating and showing
+sections are available.  There is one additional command.
+
+- Key: k, magit-process-kill
+
+  This command kills the process represented by the section at point.
+
+- User Option: magit-git-debug
+
+  When this is non-nil then the output of all calls to git are logged
+  in the process buffer.  This is useful when debugging, otherwise it
+  just negatively affects performance.
+
+*** Running Git manually
+
+While Magit provides many Emacs commands to interact with Git, it does
+not cover everything.  In those cases your existing Git knowledge will
+come in handy.  Magit provides some commands for running arbitrary Git
+commands by typing them into the minibuffer, instead of having to
+switch to a shell.
+
+- Key: !, magit-run-popup
+
+  Shows the popup buffer featuring the below suffix commands.
+
+These suffix commands run a Git subcommand.  The user input has to
+begin with the subcommand, "git" is assumed.
+
+- Key: ! !, magit-git-command-topdir
+
+  This command reads a Git subcommand from the user and executes it in
+  the top-level directory of the current repository.
+
+- Key: ! p, magit-git-command
+
+  This command reads a Git subcommand from the user and executes it in
+  ~default-directory~.  With a prefix argument the command is executed
+  in the top-level directory of the current repository instead.
+
+These suffix commands run arbitrary shell commands.
+
+- Key: ! s, magit-shell-command-topdir
+
+  This command reads a shell command from the user and executes it in
+  the top-level directory of the current repository.
+
+- Key: ! S, magit-shell-command
+
+  This command reads a shell command from the user and executes it in
+  ~default-directory~.  With a prefix argument the command is executed
+  in the top-level directory of the current repository instead.
+
+These suffix commands start external gui tools.
+
+- Key: ! k, magit-run-gitk
+
+  This command runs ~gitk~ in the current repository.
+
+- Key: ! a, magit-run-gitk-all
+
+  This command runs ~gitk --all~ in the current repository.
+
+- Key: ! b, magit-run-gitk-branches
+
+  This command runs ~gitk --branches~ in the current repository.
+
+- Key: ! g, magit-run-git-gui
+
+  This command runs ~git gui~ in the current repository.
+
+*** Git executable
+
+Except on MS Windows, Magit defaults to running Git without specifying
+the path to the git executable.  Instead the first executable found by
+Emacs on ~exec-path~ is used (whose value in turn is set based on the
+value of the environment variable ~$PATH~ when Emacs was started).
+
+This has the advantage that it continues to work even when using Tramp
+to connect to a remote machine on which the executable is found in a
+different place.  The downside is that if you have multiple versions
+of Git installed, then you might end up using another version than the
+one you think you are using.
+
+- Key: M-x magit-version, magit-version
+
+  Shows the currently used versions of Magit, Git, and Emacs in the
+  echo area.  Non-interactively this just returns the Magit version.
+
+When the ~system-type~ is ~windows-nt~, then ~magit-git-executable~ is set
+to an absolute path when Magit is first loaded.  This is necessary
+because Git on that platform comes with several wrapper scripts for
+the actual git binary, which are also placed on ~$PATH~, and using one
+of these wrappers instead of the binary would degrade performance
+horribly.
+
+If Magit doesn't find the correct executable then you *can* work around
+that by setting ~magit-git-executable~ to an absolute path.  But note
+that doing so is a kludge.  It is better to make sure the order in the
+environment variable ~$PATH~ is correct, and that Emacs is started with
+that environment in effect.  If you have to connect from Windows to a
+non-Windows machine, then you must change the value to "git".
+
+- User Option: magit-git-executable
+
+  The git executable used by Magit, either the full path to the
+  executable or the string "git" to let Emacs find the executable
+  itself, using the standard mechanism for doing such things.
+
+*** Global Git arguments
+
+- User Option: magit-git-global-arguments
+
+  The arguments set here are used every time the git executable is run
+  as a subprocess.  They are placed right after the executable itself
+  and before the git command - as in ~git HERE... COMMAND REST~.  For
+  valid arguments see [[info:gitman#git]].
+
+  Be careful what you add here, especially if you are using Tramp to
+  connect to servers with ancient Git versions.  Never remove anything
+  that is part of the default value, unless you really know what you
+  are doing.  And think very hard before adding something; it will be
+  used every time Magit runs Git for any purpose.
+
+* Inspecting
+
+The functionality provided by Magit can be roughly divided into three
+groups: inspecting existing data, manipulating existing data or adding
+new data, and transferring data.  Of course that is a rather crude
+distinction that often falls short, but it's more useful than no
+distinction at all.  This section is concerned with inspecting data,
+the next two with manipulating and transferring it.  Then follows a
+section about miscellaneous functionality, which cannot easily be fit
+into this distinction.
+
+Of course other distinctions make sense too, e.g. Git's distinction
+between porcelain and plumbing commands, which for the most part is
+equivalent to Emacs' distinction between interactive commands and
+non-interactive functions.  All of the sections mentioned before are
+mainly concerned with the porcelain -- Magit's plumbing layer is
+described later.
+
+** Status buffer
+
+While other Magit buffers contain e.g. one particular diff or one
+particular log, the status buffer contains the diffs for staged and
+unstaged changes, logs for unpushed and unpulled commits, lists of
+stashes and untracked files, and information related to the current
+branch.
+
+During certain incomplete operations -- for example when a merge
+resulted in a conflict -- additional information is displayed that
+helps proceeding with or aborting the operation.
+
+The command ~magit-status~ displays the status buffer belonging to the
+current repository in another window.  This command is used so often
+that it should be bound globally.  We recommend using ~C-x g~:
+
+#+BEGIN_SRC emacs-lisp
+  (global-set-key (kbd "C-x g") 'magit-status)
+#+END_SRC
+
+- Key: C-x g, magit-status
+
+  Show the status of the current Git repository in a buffer.
+  With a prefix argument prompt for a repository to be shown.
+  With two prefix arguments prompt for an arbitrary directory.
+  If that directory isn't the root of an existing repository,
+  then offer to initialize it as a new repository.
+
+- User Option: magit-repository-directories
+
+  Directories containing Git repositories.  Magit checks these
+  directories for Git repositories and offers them as choices when
+  ~magit-status~ is used with a prefix argument.
+
+- User Option: magit-repository-directories-depth
+
+  The maximum depth to look for Git repositories.  When looking for
+  a Git repository below the directories in
+  ~magit-repository-directories~, only descend this many levels deep.
+
+- Command: ido-enter-magit-status
+
+  From an Ido prompt used to open a file, instead drop into
+  ~magit-status~.  This is similar to ~ido-magic-delete-char~, which,
+  despite its name, usually causes a Dired buffer to be created.
+
+  To make this command available, use something like:
+
+  #+BEGIN_SRC emacs-lisp
+    (add-hook 'ido-setup-hook
+              (lambda ()
+                (define-key ido-completion-map
+                  (kbd \"C-x g\") 'ido-enter-magit-status)))
+  #+END_SRC
+
+  Starting with Emacs 25.1 the Ido keymaps are defined just once
+  instead of every time Ido is invoked, so now you can modify it
+  like pretty much every other keymap:
+
+  #+BEGIN_SRC emacs-lisp
+    (define-key ido-common-completion-map
+      (kbd \"C-x g\") 'ido-enter-magit-status)
+  #+END_SRC
+
+*** Status sections
+
+The contents of status buffers is controlled using the hook
+~magit-status-sections-hook~.  See [[*Section hooks]] to learn about such
+hooks and how to customize them.
+
+- User Option: magit-status-sections-hook
+
+  Hook run to insert sections into a status buffer.
+
+The first function on that hook by default is
+~magit-insert-status-headers~; it is described in the next section.
+By default the following functions are also members of that hook:
+
+- Function: magit-insert-merge-log
+
+  Insert section for the on-going merge.  Display the heads that are
+  being merged.  If no merge is in progress, do nothing.
+
+- Function: magit-insert-rebase-sequence
+
+  Insert section for the on-going rebase sequence.
+  If no such sequence is in progress, do nothing.
+
+- Function: magit-insert-am-sequence
+
+  Insert section for the on-going patch applying sequence.
+  If no such sequence is in progress, do nothing.
+
+- Function: magit-insert-sequencer-sequence
+
+  Insert section for the on-going cherry-pick or revert sequence.
+  If no such sequence is in progress, do nothing.
+
+- Function: magit-insert-bisect-output
+
+  While bisecting, insert section with output from ~git bisect~.
+
+- Function: magit-insert-bisect-rest
+
+  While bisecting, insert section visualizing the bisect state.
+
+- Function: magit-insert-bisect-log
+
+  While bisecting, insert section logging bisect progress.
+
+- Function: magit-insert-untracked-files
+
+  Maybe insert a list or tree of untracked files.
+  Do so depending on the value of ~status.showUntrackedFiles~.
+
+- Function: magit-insert-unstaged-changes
+
+  Insert section showing unstaged changes.
+
+- Function: magit-insert-staged-changes
+
+  Insert section showing staged changes.
+
+- Function: magit-insert-stashes &optional ref heading
+
+  Insert the ~stashes~ section showing reflog for "refs/stash".
+  If optional REF is non-nil show reflog for that instead.
+  If optional HEADING is non-nil use that as section heading
+  instead of "Stashes:".
+
+- Function: magit-insert-unpulled-commits
+
+  Insert section showing unpulled commits.
+
+- Function: magit-insert-unpushed-commits
+
+  Insert section showing unpushed commits.
+
+The following functions can also be added to the above hook:
+
+- Function: magit-insert-tracked-files
+
+  Insert a tree of tracked files.
+
+- Function: magit-insert-unpulled-or-recent-commits
+
+  Insert section showing unpulled or recent commits.
+  If an upstream is configured for the current branch and it is
+  ahead of the current branch, then show the missing commits.
+  Otherwise, show the last ~magit-log-section-commit-count~
+  commits.
+
+- Function: magit-insert-recent-commits
+
+  Insert section showing the last ~magit-log-section-commit-count~
+  commits.
+
+- User Option: magit-log-section-commit-count
+
+  How many recent commits ~magit-insert-recent-commits~ and
+  ~magit-insert-unpulled-or-recent-commits~ (provided there are no
+  unpulled commits) show.
+
+- Function: magit-insert-unpulled-cherries
+
+  Insert section showing unpulled commits.
+  Like ~magit-insert-unpulled-commits~ but prefix each commit
+  that has not been applied yet (i.e. a commit with a patch-id
+  not shared with any local commit) with "+", and all others
+  with "-".
+
+- Function: magit-insert-unpulled-module-commits
+
+  Insert sections for all submodules with unpulled commits.
+  These sections can be expanded to show the respective commits.
+
+- Function: magit-insert-unpushed-cherries
+
+  Insert section showing unpushed commits.
+  Like ~magit-insert-unpushed-commits~ but prefix each commit
+  which has not been applied to upstream yet (i.e. a commit with
+  a patch-id not shared with any upstream commit) with "+" and
+  all others with "-".
+
+- Function: magit-insert-unpushed-module-commits
+
+  Insert sections for all submodules with unpushed commits.
+  These sections can be expanded to show the respective commits.
+
+See [[*References buffer]] for some more section inserters, which could be
+used here.
+
+*** Status header sections
+
+The contents of status buffers is controlled using the hook
+~magit-status-sections-hook~, as described in the previous section.
+By default ~magit-insert-status-headers~ is the first member of that
+hook variable.
+
+- Function: magit-insert-status-headers
+
+  Insert headers sections appropriate for ~magit-status-mode~ buffers.
+  The sections are inserted by running the functions on the hook
+  ~magit-status-headers-hook~.
+
+- User Option: magit-status-headers-hook
+
+  Hook run to insert headers sections into the status buffer.
+
+  This hook is run by ~magit-insert-status-headers~, which in turn has
+  to be a member of ~magit-insert-status-sections~ to be used at all.
+
+By default the following functions are members of the above hook:
+
+- Function: magit-insert-head-header
+
+  Insert a header line about the ~HEAD~ commit.
+
+- Function: magit-insert-upstream-header
+
+  Insert a header line about the upstream branch and its tip.
+
+- Function: magit-insert-tags-header
+
+  Insert a header line about the current and/or next tag.
+
+The following functions can also be added to the above hook:
+
+- Function: magit-insert-repo-header
+
+  Insert a header line showing the path to the repository top-level.
+
+- Function: magit-insert-remote-header
+
+  Insert a header line about the remote of the current branch.
+
+  If no remote is configured for the current branch, then fall back
+  showing the "origin" remote, or if that does not exist the first
+  remote in alphabetic order.
+
+- Function: magit-insert-user-header
+
+  Insert a header line about the current user.
+
+*** Status options
+
+- User Option: magit-status-refresh-hook
+
+  Hook run after a status buffer has been refreshed.
+
+- User Option: magit-log-section-args
+
+  Additional Git arguments used when creating log sections.  Only
+  ~--graph~, ~--decorate~, and ~--show-signature~ are supported.  This
+  option is only a temporary kludge and will be removed.
+
+  Note that due to an issue in Git the use of ~--graph~ is very slow
+  with long histories, so you probably don't want to add this here.
+
+Also see the proceeding section for more options concerning status
+buffers.
+
+** Logging
+
+The status buffer contains logs for the unpushed and unpulled commits,
+but that obviously isn't enough.  The prefix command ~magit-log-popup~,
+on ~l~, features several suffix commands, which show a specific log in a
+separate log buffer.
+
+Like other popups, the log popup also features several arguments that
+can be changed before invoking one of the suffix commands.  However in
+case of the log popup these arguments correspond to those currently in
+use in the current repository's log buffer.  When the log popup is
+invoked while no log buffer exists for the current repository yet,
+then the default value of ~magit-log-arguments~ is used instead.
+
+For information about the various arguments, see [[info:gitman#git-log]].
+
+The log popup also features several reflog commands.  See [[*Reflog]].
+
+- Key: l, magit-log-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: l l, magit-log-current
+
+  Show log for the current branch.  When ~HEAD~ is detached or with a
+  prefix argument, show log for one or more revs read from the
+  minibuffer.
+
+- Key: l o, magit-log
+
+  Show log for one or more revs read from the minibuffer.  The user
+  can input any revision or revisions separated by a space, or even
+  ranges, but only branches, tags, and a representation of the
+  commit at point are available as completion candidates.
+
+- Key: l h, magit-log-head
+
+  Show log for ~HEAD~.
+
+- Key: l L, magit-log-branches
+
+  Show log for all local branches and ~HEAD~.
+
+- Key: l b, magit-log-all-branches
+
+  Show log for all local and remote branches and ~HEAD~.
+
+- Key: l a, magit-log-all
+
+  Show log for all references and ~HEAD~.
+
+The following related commands are not available from the popup.
+
+- Key: Y, magit-cherry
+
+  Show commits in a branch that are not merged in the upstream branch.
+
+- Key: M-x magit-log-buffer-file, magit-log-buffer-file
+
+  Show log for the file visited in the current buffer.
+
+*** Refreshing logs
+
+The prefix command ~magit-log-refresh-popup~, on ~L~, can be used to
+change the log arguments used in the current buffer, without changing
+which log is shown.  This works in dedicated log buffers, but also in
+the status buffer.
+
+- Key: L, magit-log-refresh-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: L g, magit-log-refresh
+
+  This suffix command sets the local log arguments for the current
+  buffer.
+
+- Key: L s, magit-log-set-default-arguments
+
+  This suffix command sets the default log arguments for buffers of
+  the same type as that of the current buffer.  Other existing buffers
+  of the same type are not affected because their local values have
+  already been initialized.
+
+- Key: L w, magit-log-save-default-arguments
+
+  This suffix command sets the default log arguments for buffers of
+  the same type as that of the current buffer, and saves the value for
+  future sessions.  Other existing buffers of the same type are not
+  affected because their local values have already been initialized.
+
+- Key: L t, magit-toggle-margin
+
+  Show or hide the margin.
+
+*** Log Buffer
+
+- Key: L, magit-log-refresh-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.  See [[*Refreshing
+  logs]].
+
+- Key: q, magit-log-bury-buffer
+
+  Bury the current buffer or the revision buffer in the same frame.
+  Like ~magit-mode-bury-buffer~ (which see) but with a negative prefix
+  argument instead bury the revision buffer, provided it is displayed
+  in the current frame.
+
+- Key: C-c C-b, magit-go-backward
+
+  Move backward in current buffer's history.
+
+- Key: C-c C-f, magit-go-forward
+
+  Move forward in current buffer's history.
+
+- Key: SPC, magit-diff-show-or-scroll-up
+
+  Update the commit or diff buffer for the thing at point.
+
+  Either show the commit or stash at point in the appropriate buffer,
+  or if that buffer is already being displayed in the current frame
+  and contains information about that commit or stash, then instead
+  scroll the buffer up.  If there is no commit or stash at point, then
+  prompt for a commit.
+
+- Key: DEL, magit-diff-show-or-scroll-down
+
+  Update the commit or diff buffer for the thing at point.
+
+  Either show the commit or stash at point in the appropriate buffer,
+  or if that buffer is already being displayed in the current frame
+  and contains information about that commit or stash, then instead
+  scroll the buffer down.  If there is no commit or stash at point,
+  then prompt for a commit.
+
+- Key: =, magit-log-toggle-commit-limit
+
+  Toggle the number of commits the current log buffer is limited to.
+  If the number of commits is currently limited, then remove that
+  limit.  Otherwise set it to 256.
+
+- Key: +, magit-log-double-commit-limit
+
+  Double the number of commits the current log buffer is limited to.
+
+- Key: =, magit-log-half-commit-limit
+
+  Half the number of commits the current log buffer is limited to.
+
+- User Option: magit-log-auto-more
+
+  Insert more log entries automatically when moving past the last
+  entry.  Only considered when moving past the last entry with
+  ~magit-goto-*-section~ commands.
+
+- User Option: magit-log-show-margin
+
+  Whether to initially show the margin in log buffers.
+
+  When non-nil the author name and date are initially displayed in the
+  margin of log buffers.  The margin can be shown or hidden in the
+  current buffer using the command ~magit-toggle-margin~.
+
+  When a log buffer contains a verbose log, then the margin is never
+  displayed.  In status buffers this option is ignored, but it is
+  possible to show the margin using the mentioned command.
+
+- User Option: magit-log-show-refname-after-summary
+
+  Whether to show the refnames after the commit summaries.  This is
+  useful if you use really long branch names.
+
+*** Select from log
+
+When the user has to select a recent commit that is reachable from
+~HEAD~, using regular completion would be inconvenient (because most
+humans cannot remember hashes or "HEAD~5", at least not without double
+checking).  Instead a log buffer is used to select the commit, which
+has the advantage that commits are presented in order and with the
+commit message.  The following additional key bindings are available
+when a log is used for selection:
+
+- Key: C-c C-c, magit-log-select-pick
+
+  Select the commit at point and act on it.  Call
+  ~magit-log-select-pick-function~ with the selected commit as
+  argument.
+
+- Key: C-c C-k, magit-log-select-quit
+
+  Abort selecting a commit, don't act on any commit.
+
+This feature is used by rebase and squash commands.
+
+*** Reflog
+
+Also see [[info:gitman#git-reflog]].
+
+These reflog commands are available from the log popup.  See [[*Logging]].
+
+- Key: l r, magit-reflog-current
+
+  Display the reflog of the current branch.
+
+- Key: l O, magit-reflog-other
+
+  Display the reflog of a branch.
+
+- Key: l H, magit-reflog-head
+
+  Display the ~HEAD~ reflog.
+
+** Diffing
+
+The status buffer contains diffs for the staged and unstaged commits,
+but that obviously isn't enough.  The prefix command ~magit-diff-popup~,
+on ~d~, features several suffix commands, which show a specific diff in
+a separate diff buffer.
+
+Like other popups, the diff popup also features several arguments that
+can be changed before invoking one of the suffix commands.  However in
+case of the diff popup these arguments correspond to those currently
+in use in the current repository's diff buffer.  When the diff popup
+is invoked while no diff buffer exists for the current repository yet,
+then the default value of ~magit-diff-arguments~ is used instead.
+
+Also see [[info:gitman#git-diff]].
+
+- Key: d, magit-diff-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: d d, magit-diff-dwim
+
+  Show changes for the thing at point.
+
+- Key: d r, magit-diff
+
+  Show differences between two commits.
+
+  RANGE should be a range (A..B or A...B) but can also be a single
+  commit.  If one side of the range is omitted, then it defaults to
+  HEAD.  If just a commit is given, then changes in the working tree
+  relative to that commit are shown.
+
+  If the region is active, use the revisions on the first and last
+  line of the region.  With a prefix argument, instead of diffing the
+  revisions, choose a revision to view changes along, starting at the
+  common ancestor of both revisions (i.e., use a "..."  range).
+
+- Key: d w, magit-diff-worktree
+
+  Show changes between the current working tree and the ~HEAD~ commit.
+  With a prefix argument show changes between the working tree and a
+  commit read from the minibuffer.
+
+- Key: d s, magit-diff-staged
+
+  Show changes between the index and the ~HEAD~ commit.  With a prefix
+  argument show changes between the index and a commit read from the
+  minibuffer.
+
+- Key: d u, magit-diff-unstaged
+
+  Show changes between the working tree and the index.
+
+- Key: d p, magit-diff-paths
+
+  Show changes between any two files on disk.
+
+- Key: M-x magit-diff-unpushed, magit-diff-unpushed
+
+  Show unpushed changes.
+
+- Key: M-x magit-diff-unpulled, magit-diff-unpulled
+
+  Show unpulled changes.
+
+All of the above suffix commands update the repository's diff buffer.
+The diff popup also features two commands which show differences in
+another buffer:
+
+- Key: d c, magit-show-commit
+
+  Show the commit at point.  If there is no commit at point or with a
+  prefix argument, prompt for a commit.
+
+- Key: d t, magit-stash-show
+
+  Show all diffs of a stash in a buffer.
+
+*** Refreshing diffs
+
+The prefix command ~magit-diff-refresh-popup~, on ~D~, can be used to
+change the diff arguments used in the current buffer, without changing
+which diff is shown.  This works in dedicated diff buffers, but also
+in the status buffer.
+
+- Key: D, magit-diff-refresh-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: D g, magit-diff-refresh
+
+  This suffix command sets the local diff arguments for the current
+  buffer.
+
+- Key: D s, magit-diff-set-default-arguments
+
+  This suffix command sets the default diff arguments for buffers of
+  the same type as that of the current buffer.  Other existing buffers
+  of the same type are not affected because their local values have
+  already been initialized.
+
+- Key: D w, magit-diff-save-default-arguments
+
+  This suffix command sets the default diff arguments for buffers of
+  the same type as that of the current buffer, and saves the value for
+  future sessions.  Other existing buffers of the same type are not
+  affected because their local values have already been initialized.
+
+- Key: D t, magit-diff-toggle-refine-hunk
+
+  This command toggles hunk refinement on or off.
+
+- Key: D r, magit-diff-switch-range-type
+
+  This command converts the diff range type from "revA..revB" to
+  "revB...revA", or vice versa.
+
+- Key: D f, magit-diff-flip-revs
+
+  This command swaps revisions in the diff range from "revA..revB"
+  to "revB..revA", or vice versa.
+
+In addition to the above popup, which allows changing any of the
+supported arguments, there also exist some commands which change a
+particular argument.
+
+- Key: -, magit-diff-less-context
+
+  This command decreases the context for diff hunks by COUNT lines.
+
+- Key: +, magit-diff-more-context
+
+  This command increases the context for diff hunks by COUNT lines.
+
+- Key: 0, magit-diff-default-context
+
+  This command resets the context for diff hunks to the default height.
+
+The following commands quickly change what diff is being displayed
+without having to using one of the diff popups.
+
+- Key: C-c C-d, magit-diff-while-committing
+
+  While committing, this command shows the changes that are about to
+  be committed.  While amending, invoking the command again toggles
+  between showing just the new changes or all the changes that will be
+  committed.
+
+  This binding is available in the diff buffer as well as the commit
+  message buffer.
+
+- Key: C-c C-b, magit-go-backward
+
+  This command moves backward in current buffer's history.
+
+- Key: C-c C-f, magit-go-forward
+
+  This command moves forward in current buffer's history.
+
+*** Diff buffer
+
+- Key: RET, magit-diff-visit-file
+
+  From a diff, visit the corresponding file at the appropriate
+  position.
+
+  When the file is already being displayed in another window of the
+  same frame, then just select that window and adjust point.  With a
+  prefix argument also display in another window.
+
+  If the diff shows changes in the worktree, the index, or ~HEAD~, then
+  visit the actual file.  Otherwise when the diff is about an older
+  commit, then visit the respective blob using ~magit-find-file~.  Also
+  see ~magit-diff-visit-file-worktree~, which, as the name suggests,
+  always visits the actual file.
+
+- Key: C-<return>, magit-diff-visit-file-worktree
+
+  From a diff, visit the corresponding file at the appropriate position.
+
+  When the file is already being displayed in another window of the
+  same frame, then just select that window and adjust point.  With
+  a prefix argument also display in another window.
+
+  The actual file in the worktree is visited. The positions in the
+  hunk headers get less useful the "older" the changes are, and as a
+  result, jumping to the appropriate position gets less reliable.
+
+  Also see ~magit-diff-visit-file-worktree~, which visits the respective
+  blob, unless the diff shows changes in the worktree, the index, or
+  ~HEAD~.
+
+- Key: j, magit-jump-to-diffstat-or-diff
+
+  Jump to the diffstat or diff.  When point is on a file inside the
+  diffstat section, then jump to the respective diff section.
+  Otherwise, jump to the diffstat section or a child thereof.
+
+- Key: SPC, scroll-up
+
+  Scroll text upward.
+
+- Key: DEL, scroll-down
+
+  Scroll text downward.
+
+*** Diff options
+
+- User Option: magit-diff-refine-hunk
+
+  Whether to show word-granularity differences within diff hunks.
+
+  - ~nil~ never show fine differences.
+  - ~t~ show fine differences for the current diff hunk only.
+  - ~all~ show fine differences for all displayed diff hunks.
+
+- User Option: magit-diff-paint-whitespace
+
+  Specify where to highlight whitespace errors.
+
+  See ~magit-highlight-trailing-whitespace~,
+  ~magit-highlight-indentation~.  The symbol ~t~ means in all diffs,
+  ~status~ means only in the status buffer, and nil means nowhere.
+
+- User Option: magit-diff-highlight-trailing
+
+  Whether to highlight whitespace at the end of a line in diffs.  Used
+  only when ~magit-diff-paint-whitespace~ is non-nil.
+
+- User Option: magit-diff-highlight-indentation
+
+  Highlight the "wrong" indentation style.  Used only when
+  ~magit-diff-paint-whitespace~ is non-nil.
+
+  The value is a list of cons cells.  The car is a regular expression,
+  and the cdr is the value that applies to repositories whose
+  directory matches the regular expression.  If more than one element
+  matches, then the *last* element in the list applies.  The default
+  value should therefore come first in the list.
+
+  If the value is ~tabs~, highlight indentation with tabs.  If the value
+  is an integer, highlight indentation with at least that many spaces.
+  Otherwise, highlight neither.
+
+*** Revision buffer
+
+- User Option: magit-revision-insert-related-refs
+
+  Whether to show related refs in revision buffers.
+
+- User Option: magit-revision-show-gravatar
+
+  Whether to show gravatar images in revision buffers.
+
+  If non-nil, then the value has to be a cons-cell which specifies
+  where the gravatar images for the author and/or the committer are
+  inserted inside the text that was previously inserted according
+  to ~magit-revision-header-format~.
+
+  Both cells are regular expressions.  The car specifies where to
+  insert the author gravatar image.  The top halve of the image is
+  inserted right after the matched text, the bottom halve on the
+  next line at the same offset.  The cdr specifies where to insert
+  the committer image, accordingly.  Either the car or the cdr may
+  be nil.
+
+** Ediffing
+
+- Key: e, magit-ediff-dwim
+
+  Compare, stage, or resolve using Ediff.
+
+  This command tries to guess what file, and what commit or range the
+  user wants to compare, stage, or resolve using Ediff.  It might only
+  be able to guess either the file, or range/commit, in which case
+  the user is asked about the other.  It might not always guess right,
+  in which case the appropriate ~magit-ediff-*~ command has to be used
+  explicitly.  If it cannot read the user's mind at all, then it asks
+  the user for a command to run.
+
+- Key: E, magit-ediff-popup
+
+  This prefix command shows the following suffix commands in a popup
+  buffer.
+
+- Key: E r, magit-ediff-compare
+
+  Compare two revisions of a file using Ediff.
+
+  If the region is active, use the revisions on the first and last
+  line of the region.  With a prefix argument, instead of diffing the
+  revisions, choose a revision to view changes along, starting at the
+  common ancestor of both revisions (i.e., use a "..."  range).
+
+- Key: E m, magit-ediff-resolve
+
+  Resolve outstanding conflicts in a file using Ediff, defaulting to
+  the file at point.
+
+  Provided that the value of ~merge.conflictstyle~ is ~diff3~, you can
+  view the file's merge-base revision using ~/~ in the Ediff control
+  buffer.
+
+  In the rare event that you want to manually resolve all conflicts,
+  including those already resolved by Git, use
+  ~ediff-merge-revisions-with-ancestor~.
+
+- Key: E s, magit-ediff-stage
+
+  Stage and unstage changes to a file using Ediff, defaulting to the
+  file at point.
+
+- Key: E u, magit-ediff-show-unstaged
+
+  Show unstaged changes to a file using Ediff.
+
+- Key: E i, magit-ediff-show-staged
+
+  Show staged changes to a file using Ediff.
+
+- Key: E w, magit-ediff-show-working-tree
+
+  Show changes in a file between HEAD and working tree using Ediff.
+
+- Key: E c, magit-ediff-show-commit
+
+  Show changes to a file introduced by a commit using Ediff.
+
+- User Option: magit-ediff-dwim-show-on-hunks
+
+  This option controls what command ~magit-ediff-dwim~ calls when
+  point is on uncommitted hunks.  When nil, always run
+  ~magit-ediff-stage~.  Otherwise, use ~magit-ediff-show-staged~ and
+  ~magit-ediff-show-unstaged~ to show staged and unstaged changes,
+  respectively.
+
+- User Option: magit-ediff-quit-hook
+
+  This hook is run after quitting an Ediff session that was created
+  using a Magit command.  The hook functions are run inside the Ediff
+  control buffer, and should not change the current buffer.
+
+  This is similar to ~ediff-quit-hook~ but takes the needs of Magit into
+  account.  The regular ~ediff-quit-hook~ is ignored by Ediff sessions
+  that were created using a Magit command.
+
+** References buffer
+
+- Key: y, magit-show-refs-popup
+
+  List and compare references in a dedicated buffer.  By default all
+  refs are compared with ~HEAD~, but with a prefix argument this command
+  instead acts as a prefix command and shows the following suffix
+  commands along with the appropriate infix arguments in a popup
+  buffer.
+
+- Key: y y, magit-show-refs-head
+
+  List and compare references in a dedicated buffer.  Refs are
+  compared with ~HEAD~.
+
+- Key: y c, magit-show-refs-current
+
+  List and compare references in a dedicated buffer.  Refs are
+  compared with the current branch or ~HEAD~ if it is detached.
+
+- Key: y o, magit-show-refs
+
+  List and compare references in a dedicated buffer.  Refs are
+  compared with a branch read from the user.
+
+- User Option: magit-refs-show-commit-count
+
+  Whether to show commit counts in Magit-Refs mode buffers.
+
+  - ~all~ Show counts for branches and tags.
+  - ~branch~ Show counts for branches only.
+  - ~nil~ Never show counts.
+
+  The default is ~nil~ because anything else can be very expensive.
+
+- User Option: magit-refs-show-margin
+
+  Whether to initially show the margin in refs buffers.
+
+  When non-nil the committer name and date are initially displayed in
+  the margin of refs buffers.  The margin can be shown or hidden in
+  the current buffer using the command ~magit-toggle-margin~.
+
+The following variables control how individual refs are displayed.  If
+you change one of these variables (especially the "%c" part), then you
+should also change the others to keep things aligned.  The following
+%-sequences are supported:
+
+- ~%a~ Number of commits this ref has over the one we compare to.
+- ~%b~ Number of commits the ref we compare to has over this one.
+- ~%c~ Number of commits this ref has over the one we compare to.  For
+  the ref which all other refs are compared this is instead "@", if
+  it is the current branch, or "#" otherwise.
+- ~%C~ For the ref which all other refs are compared this is "@", if it
+  is the current branch, or "#" otherwise.  For all other refs " ".
+- ~%h~ Hash of this ref's tip.
+- ~%m~ Commit summary of the tip of this ref.
+- ~%n~ Name of this ref.
+- ~%u~ Upstream of this local branch and additional local vs. upstream
+  information.
+- ~%U~ Upstream of this local branch.
+
+- Variable: magit-refs-local-branch-format
+
+  Format used for local branches in refs buffers.
+
+- Variable: magit-refs-remote-branch-format
+
+  Format used for remote branches in refs buffers.
+
+- Variable: magit-refs-tags-format
+
+  Format used for tags in refs buffers.
+
+- Variable: magit-refs-indent-cherry-lines
+
+  Indentation of cherries in refs buffers.  This should be N-1 where N
+  is taken from "%Nc" in the above format strings.
+
+Everywhere in Magit ~RET~ visits the thing represented by the section
+at point.  In almost all cases visiting is done by showing some
+information in another buffer and *not* doing anything else.  In refs
+buffers ~RET~ behaves differently, and because many users have grown
+accustomed to that inconsistency we are keeping it that way.
+
+- Key: RET, magit-visit-ref
+
+  Everywhere except in refs buffers this command behaves exactly like
+  ~magit-show-commit~; it shows the commit at point in another buffer.
+
+  In refs buffers, when there is a local branch at point, then this
+  command instead checks out that branch.  When there is a remote
+  branch or a tag at point then the respective commit is checked out
+  causing ~HEAD~ to be detached.
+
+  When a prefix argument it used, then this command only *focuses* on
+  the reference at point, i.e. the commit counts and cherries are
+  updated to be relative to that reference, but nothing is checked
+  out.
+
+- User Option: magit-visit-ref-create
+
+  When this is non-nil and ~magit-visit-ref~ is called inside a refs
+  buffer, then it "visits" the remote branch at point by creating a
+  new local branch which tracks that remote branch and then checking
+  out the newly created branch.
+
+  This is not enabled by default because one has to use an extremely
+  loose definition of the verb "to visit" to be able to argue that
+  creating and then checking out a new local branch is a form of
+  visiting a remote branch.
+
+*** References sections
+
+The contents of references buffers is controlled using the hook
+~magit-refs-sections-hook~.  See [[*Section hooks]] to learn about such hooks
+and how to customize them.  All of the below functions are members of
+the default value.  Note that it makes much less sense to customize
+this hook than it does for the respective hook used for the status
+buffer.
+
+- User Option: magit-refs-sections-hook
+
+  Hook run to insert sections into a references buffer.
+
+- Function: magit-insert-local-branches
+
+  Insert sections showing all local branches.
+
+- Function: magit-insert-remote-branches
+
+  Insert sections showing all remote-tracking branches.
+
+- Function: magit-insert-tags
+
+  Insert sections showing all tags.
+
+** Bisecting
+
+Also see [[info:gitman#git-bisect]].
+
+- Key: B, magit-bisect-popup
+
+  This prefix command shows the following suffix commands in a
+  popup buffer.
+
+When bisecting is not in progress, then the popup buffer features the
+following commands.
+
+- Key: B s, magit-bisect-start
+
+  Start a bisect session.
+
+  Bisecting a bug means to find the commit that introduced it.
+  This command starts such a bisect session by asking for a known
+  good and a bad commit.
+
+- Key: B u, magit-bisect-run
+
+  Bisect automatically by running commands after each step.
+
+When bisecting is in progress, then the popup buffer features these
+commands instead.
+
+- Key: B b, magit-bisect-bad
+
+  Mark the current commit as bad.  Use this after you have asserted
+  that the commit does contain the bug in question.
+
+- Key: B g, magit-bisect-good
+
+  Mark the current commit as good.  Use this after you have asserted
+  that the commit does not contain the bug in question.
+
+- Key: B k, magit-bisect-skip
+
+  Skip the current commit.  Use this if for some reason the current
+  commit is not a good one to test.  This command lets Git choose a
+  different one.
+
+- Key: B r, magit-bisect-reset
+
+  After bisecting, cleanup bisection state and return to original
+  ~HEAD~.
+
+** Visiting blobs
+
+- Key: M-x magit-find-file, magit-find-file
+
+  View FILE from REV.  Switch to a buffer visiting blob REV:FILE,
+  creating one if none already exists.
+
+- Key: M-x magit-find-file-other-window, magit-find-file-other-window
+
+  View FILE from REV, in another window.  Like ~magit-find-file~, but
+  create a new window or reuse an existing one.
+
+** Blaming
+
+Also see [[info:gitman#git-blame]].
+
+- Key: M-x magit-blame, magit-blame
+
+  Display edit history of FILE up to REVISION.
+
+  Interactively blame the file being visited in the current buffer.
+  If the buffer visits a revision of that file, then blame up to that
+  revision.  Otherwise, blame the file's full history, including
+  uncommitted changes.
+
+  If Magit-Blame mode is already turned on then blame recursively, by
+  visiting REVISION:FILE (using ~magit-find-file~), where revision is
+  the revision before the revision that added the lines at point.
+
+  ARGS is a list of additional arguments to pass to ~git blame~; only
+  arguments available from ~magit-blame-popup~ should be used.
+
+- Key: M-x magit-blame-popup, magit-blame-popup
+
+  This prefix command shows the above suffix command along with the
+  appropriate infix arguments in a popup buffer.
+
+- Key: RET, magit-show-commit
+
+  Show the commit at point.  If there is no commit at point or with a
+  prefix argument, prompt for a commit.
+
+- Key: SPC, magit-diff-show-or-scroll-up
+
+  Update the commit or diff buffer for the thing at point.
+
+  Either show the commit or stash at point in the appropriate buffer,
+  or if that buffer is already being displayed in the current frame
+  and contains information about that commit or stash, then instead
+  scroll the buffer up.  If there is no commit or stash at point, then
+  prompt for a commit.
+
+- Key: DEL, magit-diff-show-or-scroll-down
+
+  Update the commit or diff buffer for the thing at point.
+
+  Either show the commit or stash at point in the appropriate buffer,
+  or if that buffer is already being displayed in the current frame
+  and contains information about that commit or stash, then instead
+  scroll the buffer down.  If there is no commit or stash at point,
+  then prompt for a commit.
+
+- Key: n, magit-blame-next-chunk
+
+  Move to the next chunk.
+
+- Key: N, magit-blame-next-chunk-same-commit
+
+  Move to the next chunk from the same commit.
+
+- Key: p, magit-blame-previous-chunk
+
+  Move to the previous chunk.
+
+- Key: P, magit-blame-previous-chunk-same-commit
+
+  Move to the previous chunk from the same commit.
+
+- Key: q, magit-blame-quit
+
+  Turn off Magit-Blame mode.  If the buffer was created during a
+  recursive blame, then also kill the buffer.
+
+- Key: M-w, magit-blame-copy-hash
+
+  Save the hash of the current chunk's commit to the kill ring.
+
+- Key: t, magit-blame-toggle-headings
+
+  Show or hide blame chunk headings.
+
+- User Option: magit-blame-heading-format
+
+  Format string used for blame headings.
+
+- User Option: magit-blame-time-format
+
+  Format string used for time strings in blame headings.
+
+- User Option: magit-blame-show-headings
+
+  Whether to initially show blame block headings.  The headings can
+  also be toggled locally using command ~magit-blame-toggle-headings~.
+
+- User Option: magit-blame-goto-chunk-hook
+
+  Hook run by ~magit-blame-next-chunk~ and ~magit-blame-previous-chunk~.
+
+* Manipulating
+** Repository setup
+
+- Key: M-x magit-init, magit-init
+
+  This command initializes a repository and then shows the status
+  buffer for the new repository.
+
+  If the directory is below an existing repository, then the user has
+  to confirm that a new one should be created inside.  If the
+  directory is the root of the existing repository, then the user has
+  to confirm that it should be reinitialized.
+
+- Key: M-x magit-clone, magit-clone
+
+  This command clones a repository and then shows the status buffer
+  for the new repository.
+
+  The user is queried for a remote url and a local directory.
+
+** Staging and unstaging
+
+Like Git, Magit can of course stage and unstage complete files.
+Unlike Git, it also allows users to gracefully un-/stage
+individual hunks and even just part of a hunk.  To stage individual
+hunks and parts of hunks using Git directly, one has to use the very
+modal and rather clumsy interface of a ~git add --interactive~ session.
+
+With Magit, on the other hand, one can un-/stage individual hunks by
+just moving point into the respective section inside a diff displayed
+in the status buffer or a separate diff buffer and typing ~s~ or ~u~.  To
+operate on just parts of a hunk, mark the changes that should be
+un-/staged using the region and then press the same key that would be
+used to un-/stage.  To stage multiple files or hunks at once use a
+region that starts inside the heading of such a section and ends
+inside the heading of a sibling section of the same type.
+
+Besides staging and unstaging, Magit also provides several other
+"apply variants" that can also operate on a file, multiple files at
+once, a hunk, multiple hunks at once, and on parts of a hunk.  These
+apply variants are described in the next section.
+
+- Key: s, magit-stage
+
+  Add the change at point to the staging area.
+
+- Key: S, magit-stage-modified
+
+  Stage all changes to files modified in the worktree.  Stage all new
+  content of tracked files and remove tracked files that no longer
+  exist in the working tree from the index also.  With a prefix
+  argument also stage previously untracked (but not ignored) files.
+
+- Key: u, magit-unstage
+
+  Remove the change at point from the staging area.
+
+- Key: U, magit-unstage-all
+
+  Remove all changes from the staging area.
+
+- Key: M-x magit-reset-index, magit-reset-index
+
+  Reset the index to some commit.  The commit is read from the user
+  and defaults to the commit at point.  If there is no commit at
+  point, then it defaults to ~HEAD~.
+
+
+To stage a smaller unit than a range of lines, similar to ~git add
+--patch~ followed by ~e~ would do, then you can use ~magit-ediff-stage~ to
+do so.
+
+*** Staging from file-visiting buffers
+
+Fine-grained un-/staging has to be done from the status or a diff
+buffer, but it's also possible to un-/stage all changes made to the
+file visited in the current buffer right from inside that buffer.
+
+- Key: M-x magit-stage-file, magit-stage-file
+
+  When invoked inside a file-visiting buffer, then stage all changes
+  to that file.  In a Magit buffer, stage the file at point if any.
+  Otherwise prompt for a file to be staged.  With a prefix argument
+  always prompt the user for a file, even in a file-visiting buffer or
+  when there is a file section at point.
+
+- Key: M-x magit-unstage-file, magit-unstage-file
+
+  When invoked inside a file-visiting buffer, then unstage all changes
+  to that file.  In a Magit buffer, unstage the file at point if any.
+  Otherwise prompt for a file to be unstaged.  With a prefix argument
+  always prompt the user for a file, even in a file-visiting buffer or
+  when there is a file section at point.
+
+** Applying
+
+Magit provides several "apply variants": stage, unstage, discard,
+reverse, and "regular apply".  At least when operating on a hunk they
+are all implemented using ~git apply~, which is why they are called
+"apply variants".
+
+- Stage.  Apply a change from the working tree to the index.  The change
+  also remains in the working tree.
+
+- Unstage.  Remove a change from the index.  The change remains in the
+  working tree.
+
+- Discard.  On a staged change, remove it from the working tree and the
+  index.  On an unstaged change, remove it from the working tree only.
+
+- Reverse.  Reverse a change in the working tree.  Both committed and
+  staged changes can be reversed.  Unstaged changes cannot be
+  reversed.  Discard them instead.
+
+- Apply.  Apply a change to the working tree.  Both committed and staged
+  changes can be applied.  Unstaged changes cannot be applied - as
+  they already have been applied.
+
+The previous section described the staging and unstaging commands.
+What follows are the commands which implement the remaining apply
+variants.
+
+- Key: a, magit-apply
+
+  Apply the change at point to the working tree.
+
+- Key: k, magit-discard
+
+  Remove the change at point from the working tree.
+
+- Key: v, magit-reverse
+
+  Reverse the change at point in the working tree.
+
+With a prefix argument all apply variants attempt a 3-way merge when
+appropriate (i.e. when ~git apply~ is used internally).
+
+** Committing
+
+When the user initiates a commit, Magit calls ~git commit~ without any
+arguments, so Git has to get it from the user.  It creates the file
+~.git/COMMIT_EDITMSG~ and then opens that file in an editor.  Magit
+arranges for that editor to be the Emacsclient.  Once the user
+finishes the editing session, the Emacsclient exits and Git creates the
+commit using the file's content as message.
+
+*** Initiating a commit
+
+Also see [[info:gitman#git-commit]].
+
+- Key: c, magit-commit-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: c c, magit-commit
+
+  Create a new commit on ~HEAD~.  With a prefix argument amend to the
+  commit at ~HEAD~ instead.
+
+- Key: c a, magit-commit-amend
+
+  Amend the last commit.
+
+- Key: c e, magit-commit-extend
+
+  Amend the last commit, without editing the message.  With a prefix
+  argument keep the committer date, otherwise change it.  The option
+  ~magit-commit-extend-override-date~ can be used to inverse the meaning
+  of the prefix argument.
+
+  Non-interactively respect the optional OVERRIDE-DATE argument and
+  ignore the option.
+
+- Key: c w, magit-commit-reword
+
+  Reword the last commit, ignoring staged changes.  With a prefix
+  argument keep the committer date, otherwise change it.  The option
+  ~magit-commit-reword-override-date~ can be used to inverse the meaning
+  of the prefix argument.
+
+  Non-interactively respect the optional OVERRIDE-DATE argument and
+  ignore the option.
+
+- Key: c f, magit-commit-fixup
+
+  Create a fixup commit.
+
+  With a prefix argument the target commit has to be confirmed.
+  Otherwise the commit at point may be used without confirmation
+  depending on the value of option ~magit-commit-squash-confirm~.
+
+- Key: c F, magit-commit-instant-fixup
+
+  Create a fixup commit and instantly rebase.
+
+- Key: c s, magit-commit-squash
+
+  Create a squash commit, without editing the squash message.
+
+  With a prefix argument the target commit has to be confirmed.
+  Otherwise the commit at point may be used without confirmation
+  depending on the value of option ~magit-commit-squash-confirm~.
+
+- Key: c S, magit-commit-instant-squash
+
+  Create a squash commit and instantly rebase.
+
+- Key: c A, magit-commit-augment
+
+  Create a squash commit, editing the squash message.
+
+  With a prefix argument the target commit has to be confirmed.
+  Otherwise the commit at point may be used without confirmation
+  depending on the value of option ~magit-commit-squash-confirm~.
+
+- User Option: magit-commit-ask-to-stage
+
+  Whether to ask to stage everything when committing and nothing is
+  staged.
+
+- User Option: magit-commit-extend-override-date
+
+  Whether using ~magit-commit-extend~ changes the committer date.
+
+- User Option: magit-commit-reword-override-date
+
+  Whether using ~magit-commit-reword~ changes the committer date.
+
+- User Option: magit-commit-squash-confirm
+
+  Whether the commit targeted by squash and fixup has to be confirmed.
+  When non-nil then the commit at point (if any) is used as default
+  choice.  Otherwise it has to be confirmed.  This option only affects
+  ~magit-commit-squash~ and ~magit-commit-fixup~.  The "instant" variants
+  always require confirmation because making an error while using
+  those is harder to recover from.
+
+*** Editing commit messages
+
+After initiating a commit as described in the previous section, two new
+buffers appear.  One shows the changes that are about to committed,
+while the other is used to write the message.  All regular editing
+commands are available in the commit message buffer.  This section
+only describes the additional commands.
+
+Commit messages are edited in an edit session - in the background Git
+is waiting for the editor, in our case the Emacsclient, to save the
+commit message in a file (in most cases ~.git/COMMIT_EDITMSG~) and then
+return.  If the Emacsclient returns with a non-zero exit status then
+Git does not create the commit.  So the most important commands are
+those for finishing and aborting the commit.
+
+- Key: C-c C-c, with-editor-finish
+
+  Finish the current editing session by returning with exit code 0.
+  Git then creates the commit using the message it finds in the file.
+
+- Key: C-c C-k, with-editor-cancel
+
+  Cancel the current editing session by returning with exit code 1.
+  Git then cancels the commit, but leaves the file untouched.
+
+In addition to being used by Git, these messages may also be stored in
+a ring that persists until Emacs is closed.  By default the message is
+stored at the beginning and the end of an edit session (regardless of
+whether the session is finished successfully or was canceled).  It is
+sometimes useful to bring back messages from that ring.
+
+- Key: C-s M-s, git-commit-save-message
+
+  Save the current buffer content to the commit message ring.
+
+- Key: M-p, git-commit-prev-message
+
+  Cycle backward through the commit message ring, after saving the
+  current message to the ring.  With a numeric prefix ARG, go back
+  ARG comments.
+
+- Key: M-n, git-commit-next-message
+
+  Cycle forward through the commit message ring, after saving the
+  current message to the ring.  With a numeric prefix ARG, go back
+  ARG comments.
+
+By default the diff for the changes that are about to be committed are
+automatically shown when invoking the commit.  When amending to an
+existing commit it may be useful to show either the changes that are
+about to be added to that commit or to show those changes together
+with those that are already committed.
+
+- Key: C-c C-d, magit-diff-while-committing
+
+  While committing, show the changes that are about to be committed.
+  While amending, invoking the command again toggles between showing
+  just the new changes or all the changes that will be committed.
+
+- Key: C-c C-w, magit-pop-revision-stack
+
+  This command inserts a representation of a revision into the current
+  buffer.  It can be used inside buffers used to write commit messages
+  but also in other buffers such as buffers used to edit emails or
+  ChangeLog files.
+
+  By default this command pops the revision which was last added to
+  the ~magit-revision-stack~ and inserts it into the current buffer
+  according to ~magit-pop-revision-stack-format~.  Revisions can be put
+  on the stack using ~magit-copy-section-value~ and
+  ~magit-copy-buffer-revision~.
+
+  If the stack is empty or with a prefix argument it instead reads a
+  revision in the minibuffer.  By using the minibuffer history this
+  allows selecting an item which was popped earlier or to insert an
+  arbitrary reference or revision without first pushing it onto the
+  stack.
+
+  When reading the revision from the minibuffer, then it might not
+  be possible to guess the correct repository.  When this command
+  is called inside a repository (e.g. while composing a commit
+  message), then that repository is used.  Otherwise (e.g. while
+  composing an email) then the repository recorded for the top
+  element of the stack is used (even though we insert another
+  revision).  If not called inside a repository and with an empty
+  stack, or with two prefix arguments, then read the repository in
+  the minibuffer too.
+
+- User Option: magit-pop-revision-stack-format
+
+  This option controls how the command ~magit-pop-revision-stack~
+  inserts a revision into the current buffer.
+
+  The entries on the stack have the format ~(HASH TOPLEVEL)~ and this
+  option has the format ~(POINT-FORMAT EOB-FORMAT INDEX-REGEXP)~, all
+  of which may be nil or a string (though either one of EOB-FORMAT
+  or POINT-FORMAT should be a string, and if INDEX-REGEXP is
+  non-nil, then the two formats should be too).
+
+  First INDEX-REGEXP is used to find the previously inserted entry,
+  by searching backward from point.  The first submatch must match
+  the index number.  That number is incremented by one, and becomes
+  the index number of the entry to be inserted.  If you don't want
+  to number the inserted revisions, then use nil for INDEX-REGEXP.
+
+  If INDEX-REGEXP is non-nil then both POINT-FORMAT and EOB-FORMAT
+  should contain \"%N\", which is replaced with the number that was
+  determined in the previous step.
+
+  Both formats, if non-nil and after removing %N, are then expanded
+  using `git show --format=FORMAT ...' inside TOPLEVEL.
+
+  The expansion of POINT-FORMAT is inserted at point, and the
+  expansion of EOB-FORMAT is inserted at the end of the buffer (if the
+  buffer ends with a comment, then it is inserted right before that).
+
+Some projects use pseudo headers in commit messages.  Magit colorizes
+such headers and provides some commands to insert such headers.
+
+- User Option: git-commit-known-pseudo-headers
+
+  A list of Git pseudo headers to be highlighted.
+
+- Key: C-c C-a, git-commit-ack
+
+  Insert a header acknowledging that you have looked at the commit.
+
+- Key: C-c C-r, git-commit-review
+
+  Insert a header acknowledging that you have reviewed the commit.
+
+- Key: C-c C-s, git-commit-signoff
+
+  Insert a header to sign off the commit.
+
+- Key: C-c C-t, git-commit-test
+
+  Insert a header acknowledging that you have tested the commit.
+
+- Key: C-c C-o, git-commit-cc
+
+  Insert a header mentioning someone who might be interested.
+
+- Key: C-c C-p, git-commit-reported
+
+  Insert a header mentioning the person who reported the issue being
+  fixed by the commit.
+
+- Key: C-c C-i, git-commit-suggested
+
+  Insert a header mentioning the person who suggested the change.
+
+~git-commit-mode~ is a minor mode that is only used to establish
+the above key bindings.  This allows using an arbitrary major mode
+when editing the commit message.  It's even possible to use a
+different major mode in different repositories, which is useful when
+different projects impose different commit message conventions.
+
+- User Option: git-commit-major-mode
+
+  The value of this option is the major mode used to edit Git commit
+  messages.
+
+Because ~git-commit-mode~ is a minor mode, we don't use its mode hook
+to setup the buffer, except for the key bindings.  All other setup
+happens in the function ~git-commit-setup~, which among other things runs
+the hook ~git-commit-setup-hook~.  The following functions are suitable
+for that hook.
+
+- User Option: git-commit-setup-hook
+
+  Hook run at the end of ~git-commit-setup~.
+
+- Function: magit-revert-buffers &optional force
+
+  Revert unmodified file-visiting buffers of the current repository.
+
+  If either ~magit-revert-buffers~ is non-nil and ~inhibit-magit-revert~
+  is nil, or if optional FORCE is non-nil, then revert all unmodified
+  buffers that visit files being tracked in the current repository.
+
+- Function: git-commit-save-message
+
+  Save the current buffer content to the commit message ring.
+
+- Function: git-commit-setup-changelog-support
+
+  After this function is called, ChangeLog entries are treated as
+  paragraphs.
+
+- Function: git-commit-turn-on-auto-fill
+
+  Turn on ~auto-fill-mode~ and set ~fill-column~ to the value of
+  ~git-commit-fill-column~.
+
+- Function: git-commit-turn-on-flyspell
+
+  Turn on Flyspell mode.  Also prevent comments from being checked and
+  finally check current non-comment text.
+
+- Function: git-commit-propertize-diff
+
+  Propertize the diff shown inside the commit message buffer.  Git
+  inserts such diffs into the commit message template when the
+  ~--verbose~ argument is used.  Magit's commit popup by default does
+  not offer that argument because the diff that is shown in a separate
+  buffer is more useful.  But some users disagree, which is why this
+  function exists.
+
+- Function: with-editor-usage-message
+
+  Show usage information in the echo area.
+
+Magit also helps with writing *good* commit messages by complaining when
+certain rules are violated.
+
+- User Option: git-commit-summary-max-length
+
+  The intended maximal length of the summary line of commit messages.
+  Characters beyond this column are colorized to indicate that this
+  preference has been violated.
+
+- User Option: git-commit-fill-column
+
+  Column beyond which automatic line-wrapping should happen in commit
+  message buffers.
+
+- User Option: git-commit-finish-query-functions
+
+  List of functions called to query before performing commit.
+
+  The commit message buffer is current while the functions are called.
+  If any of them returns nil, then the commit is not performed and the
+  buffer is not killed.  The user should then fix the issue and try
+  again.
+
+  The functions are called with one argument.  If it is non-nil then
+  that indicates that the user used a prefix argument to force
+  finishing the session despite issues.  Functions should usually
+  honor this wish and return non-nil.
+
+- Function: git-commit-check-style-conventions
+
+  Check for violations of certain basic style conventions.  For each
+  violation ask the user if she wants to proceed anyway.  This makes
+  sure the summary line isn't too long and that the second line is
+  empty.
+
+To show no diff while committing remove ~magit-commit-diff~ from
+~server-switch-hook~.
+
+** Branching
+
+Also see [[info:gitman#git-branch]] and [[info:gitman#git-checkout]].
+
+- Key: b, magit-branch-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: b b, magit-checkout
+
+  Checkout a revision read in the minibuffer and defaulting to the
+  branch or arbitrary revision at point.  If the revision is a local
+  branch then that becomes the current branch.  If it is something
+  else then ~HEAD~ becomes detached.  Checkout fails if the working tree
+  or the staging area contain changes.
+
+- Key: b c, magit-branch
+
+  Create a new branch.  The user is asked for a branch or arbitrary
+  revision to use as the starting point of the new branch.  When a
+  branch name is provided, then that becomes the upstream branch of
+  the new branch.  The name of the new branch is also read in the
+  minibuffer.
+
+- Key: b B, magit-branch-and-checkout
+
+  This command creates a new branch like ~magit-branch~, but then also
+  checks it out.
+
+- Key: b s, magit-branch-spinoff
+
+  This command creates and checks out a new branch starting at and
+  tracking the current branch.  That branch in turn is reset to the
+  last commit it shares with its upstream.  If the current branch has
+  no upstream or no unpushed commits, then the new branch is created
+  anyway and the previously current branch is not touched.
+
+  This is useful to create a feature branch after work has already
+  began on the old branch (likely but not necessarily "master").
+
+- Key: b x, magit-branch-reset
+
+  This command resets a branch, defaulting to the branch at point, to
+  the tip of another branch or any other commit.
+
+  When resetting to another branch, then that branch is also set as
+  the upstream of the branch being reset.
+
+  When the branch being reset is the current branch, then a hard reset
+  is performed.  If there are any uncommitted changes, then the user
+  has to confirming the reset because those changes would be lost.
+
+  This is useful when you have started work on a feature branch but
+  realize it's all crap and want to start over.
+
+- Key: b d, magit-branch-delete
+
+  Delete one or multiple branches.  If the region marks multiple
+  branches, then offer to delete those.  Otherwise, prompt for a single
+  branch to be deleted, defaulting to the branch at point.
+
+- Key: b u, magit-branch-set-upstream
+
+  Change the upstream branch of a branch.  Both branches are read in
+  the minibuffer, while providing reasonable defaults.
+
+- Key: b U, magit-branch-unset-upstream
+
+  Unset the upstream branch of a branch read in the minibuffer and
+  defaulting to the branch at point or the current branch.
+
+- Key: b r, magit-branch-rename
+
+  Rename a branch.  The branch and the new name are read in the
+  minibuffer.  With prefix argument the branch is renamed even if that
+  name conflicts with an existing branch.
+
+- Key: b e, magit-branch-edit-description
+
+  Edit the description of a branch.  The branch is read in the
+  minibuffer defaulting to the branch at point or the current branch.
+  The description is edited in a regular buffer similar to how commit
+  messages are edited.
+
+- User Option: magit-branch-read-upstream-first
+
+  When creating a branch, whether to read the upstream branch before
+  the name of the branch that is to be created.
+
+** Merging
+
+Also see [[info:gitman#git-merge]].
+
+- Key: m, magit-merge-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+When no merge is in progress, then the popup buffer features the
+following commands.
+
+- Key: m m, magit-merge
+
+  Merge another branch or an arbitrary revision into the current
+  branch.  The branch or revision to be merged is read in the
+  minibuffer and defaults to the one at point.
+
+  Unless there are conflicts or a prefix argument is used, the
+  resulting merge commit uses a generic commit message, and the user
+  does not get a chance to inspect or change it before the commit is
+  created.  With a prefix argument this does not actually create the
+  merge commit, which makes it possible to inspect how conflicts were
+  resolved and to adjust the commit message.
+
+- Key: m e, magit-merge-editmsg
+
+  Merge another branch or an arbitrary revision into the current
+  branch and open a commit message buffer, so that the user can make
+  adjustments.  The commit is not actually created until the user
+  finishes with ~C-c C-c~.
+
+- Key: m n, magit-merge-nocommit
+
+  Merge another branch or an arbitrary revision into the current
+  branch, but do not actually create the commit.  The user can then
+  further adjust the merge, even when automatic conflict resolution
+  succeeded and/or adjust the commit message.
+
+- Key: m p, magit-merge-preview
+
+  Preview result of merging another branch or an arbitrary revision
+  into the current branch.
+
+When a merge is in progress, then the popup buffer features these
+commands instead.
+
+- Key: m m, magit-merge
+
+  After resolving conflicts, proceed with the merge.  If there are
+  still conflicts, then this fails.
+
+- Key: m a, magit-merge-abort
+
+  Abort the current merge operation.
+
+** Rebasing
+
+Also see [[info:gitman#git-rebase]].
+
+- Key: r, magit-rebase-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+When no rebase is in progress, then the popup buffer features the
+following commands.
+
+- Key: r r, magit-rebase
+
+  Start a non-interactive rebase sequence.  All commits not in
+  UPSTREAM are rebased.
+
+- Key: r o, magit-rebase-subset
+
+  Start a non-interactive rebase sequence with commits from START to
+  ~HEAD~ onto NEWBASE.  START has to be selected from a list of recent
+  commits.
+
+Note that the popup also features the infix argument ~--interactive~.
+This can be used to turn one of the above non-interactive rebase
+variants into an interactive rebase.
+
+For example if you want to clean up a feature branch and at the same
+time rebase it onto ~master~, then you could use ~r-ir~.  But we recommend
+that you instead do that in two steps.  First use ~rs~ to cleanup the
+feature branch, and then in a second step ~rl~ to rebase it onto ~master~.
+That way if things turn out to be more complicated than you thought
+and/or you make a mistake and have to start over, then you only have
+to redo half the work.
+
+Explicitly enabling ~--interactive~ won't have an effect on the
+following commands as they always use that argument anyway, even if it
+is not enabled in the popup.
+
+- Key: r i, magit-rebase-interactive
+
+  Start an interactive rebase sequence.
+
+- Key: r l, magit-rebase-unpushed
+
+  Start an interactive rebase sequence of unpushed commits.  This is
+  like ~magit-rebase-interactive~, but if the upstream of the current
+  branch is configured, then all commits since the merge-base are
+  rebased.  If there is no upstream or no merge-base, then the user
+  has to select the first commit to be rebased like for
+  ~magit-rebase-interactive~.
+
+- Key: r f, magit-rebase-autosquash
+
+  Combine squash and fixup commits with their intended targets.
+
+- Key: r e, magit-rebase-edit-commit
+
+  Edit a single older commit using rebase.
+
+- Key: r w, magit-rebase-reword-commit
+
+  Reword a single older commit using rebase.
+
+When a rebase is in progress, then the popup buffer features these
+commands instead.
+
+- Key: r r, magit-rebase-continue
+
+  Restart the current rebasing operation.
+
+- Key: r s, magit-rebase-skip
+
+  Skip the current commit and restart the current rebase operation.
+
+- Key: r e, magit-rebase-edit
+
+  Edit the todo list of the current rebase operation.
+
+- Key: r a, magit-rebase-abort
+
+  Abort the current rebase operation, restoring the original branch.
+
+*** Editing rebase sequences
+
+- Key: C-c C-c, with-editor-finish
+
+  Finish the current editing session by returning with exit code 0.
+  Git then creates the commit using the message it finds in the file.
+
+- Key: C-c C-k, with-editor-cancel
+
+  Cancel the current editing session by returning with exit code 1.
+  Git then cancels the commit, but leaves the file untouched.
+
+- Key: RET, git-rebase-show-commit
+
+  Show the commit on the current line in another buffer and select
+  that buffer.
+
+- Key: SPC, magit-diff-show-or-scroll-up
+
+  Show the commit on the current line in another buffer without
+  selecting that buffer.  If the revision buffer is already visible in
+  another window of the current frame, then instead scroll that window
+  up.
+
+- Key: DEL, magit-diff-show-or-scroll-down
+
+  Show the commit on the current line in another buffer without
+  selecting that buffer.  If the revision buffer is already visible in
+  another window of the current frame, then instead scroll that window
+  down.
+
+- Key: p, git-rebase-backward-line
+
+  Move to previous line.
+
+- Key: n, forward-line
+
+  Move to next line.
+
+- Key: M-p, git-rebase-move-line-up
+
+  Move the current commit (or command) up.
+
+- Key: M-n, git-rebase-move-line-down
+
+  Move the current commit (or command) down.
+
+- Key: r, git-rebase-reword
+
+  Edit message of commit on current line.
+
+- Key: e, git-rebase-edit
+
+  Stop at the commit on the current line.
+
+- Key: s, git-rebase-squash
+
+  Meld commit on current line into previous commit, and edit message.
+
+- Key: f, git-rebase-fixup
+
+  Meld commit on current line into previous commit, discarding the
+  current commit's message.
+
+- Key: k, git-rebase-kill-line
+
+  Kill the current action line.
+
+- Key: c, git-rebase-pick
+
+  Use commit on current line.
+
+- Key: x, git-rebase-exec
+
+  Insert a shell command to be run after the proceeding commit.
+
+  If there already is such a command on the current line, then edit
+  that instead.  With a prefix argument insert a new command even when
+  there already is one on the current line.  With empty input remove
+  the command on the current line, if any.
+
+- Key: y, git-rebase-insert
+
+  Read an arbitrary commit and insert it below current line.
+
+- Key: C-x u, git-rebase-undo
+
+  Undo some previous changes.  Like ~undo~ but works in read-only
+  buffers.
+
+- User Option: git-rebase-auto-advance
+
+  Whether to move to next line after changing a line.
+
+- User Option: git-rebase-show-instructions
+
+  Whether to show usage instructions inside the rebase buffer.
+
+- User Option: git-rebase-confirm-cancel
+
+  Whether confirmation is required to cancel.
+*** Rebase sequence log
+
+While a rebase sequence is in progress, the status buffer features a
+section which lists the commits that have already been applied as well
+as the commits that still have to be applied.
+
+The commits are split in two halves.  When rebase stops at a commit,
+either because the user has to deal with a conflict or explicitly
+requested that rebase stops at that commit, then point is placed on
+the commit that separates the two groups, i.e. on ~HEAD~.  The commits
+above it have not been applied yet, while it and the commits below it
+have already been applied.  In between these two groups or applied and
+yet-to-be applied commits, there sometimes is a commit which has been
+dropped.
+
+Each commit is prefixed with a word and these words are additionally
+shown in different colors to indicate the status of the commits.
+
+The following colors are used:
+
+- Yellow commits have not been applied yet.
+
+- Gray commits have already been applied.
+
+- The blue commit is the ~HEAD~ commit.
+
+- The green commit is the commit the rebase sequence stopped at.  If
+  this is the same commit as ~HEAD~ (e.g. because you haven't done
+  anything yet after rebase stopped at the commit, then this commit is
+  shown in blue, not green.  There can only be a green and a blue
+  commit at the same time, if you create one or more new commits after
+  rebase stops at a commit.
+
+- Red commits have been dropped.  They are shown for reference only,
+  e.g. to make it easier to diff.
+
+Of course these colors are subject to the color-theme in use.
+
+The following words are used:
+
+- Commits prefixed with ~pick~, ~reword~, ~edit~, ~squash~, and ~fixup~ have not
+  been applied yet.  These words have the same meaning here as they do
+  in the buffer used to edit the rebase sequence.  See [[*Editing rebase
+  sequences]].
+
+- The commit prefixed with ~onto~ is the commit on top of which all the
+  other commits are being re-applied.  Like the commits that have
+  already been re-applied, it is reachable from ~HEAD~, but unlike those
+  it has not actually been re-applied during the current session - it
+  wasn't touched at all.
+
+- Commits prefixed with ~done~ have already been re-applied.  Not all
+  commits that have already been applied are prefixed with this word,
+  though.
+
+- When a commit is prefixed with ~void~, then that indicates that Magit
+  knows for sure that all the changes in that commit have been applied
+  using several new commits.  This commit is no longer reachable from
+  ~HEAD~, and it also isn't one of the commits that will be applied when
+  resuming the session.
+
+- When a commit is prefixed with ~join~, then that indicates that the
+  rebase sequence stopped at that commit due to a conflict - you now
+  have to join (merge) the changes with what has already been
+  applied.  In a sense this is the commit rebase stopped at, but while
+  its effect is already in the index and in the worktree (with
+  conflict markers), the commit itself has not actually been applied
+  yet (it isn't the ~HEAD~).  So it is shown in yellow, like the other
+  commits that still have to be applied.
+
+- When a commit is prefixed with ~goal~, ~same~, or ~work~, then that
+  indicates that you reset to an earlier commit (and that this commit
+  therefore is no longer reachable from ~HEAD~), but that it might still
+  be possible to create a new commit with the exact same tree or at
+  least the same patch-id, without manually editing any file.  Or at
+  the very least that there are some uncommitted remaining, which
+  may or may not originate from that commit.
+
+  - When a commit is prefixed with ~goal~, then that indicates that it
+    is still possible to create a commit with the exact same tree
+    (the "goal") without manually editing a file, by simply committing
+    the index (or, provided nothing is already staged, by staging all
+    unstaged changes and then committing that).  This is the case when
+    the original tree exists in the index or worktree in untainted
+    form.
+
+  - When a commit is prefixed with ~same~, then that indicates that it
+    is no longer possible to create a commit with the exact same tree,
+    but that it is still possible to create a commit with the same
+    patch-id.  This would be the case if you created a new commit with
+    other changes, but the changes from the original commit still
+    exist in the index and/or working tree in untainted form.
+
+  - When a commit is prefixed with ~work~, then that indicates that you
+    are working with the changes from that commit after resetting to
+    an earlier commit.  There are changes in the index and/or working
+    tree and some of them likely originate from that commit.
+
+- When a commit is prefixed with ~poof~ or ~gone~, then that indicates
+  that you reset to an earlier commit (and that this commit therefore
+  is no longer reachable from ~HEAD~), and that there are no
+  uncommitted changes remaining which might allow you to create a new
+  commit with the same tree or at least the same patch-id.
+
+  - When a commit is prefixed with ~poof~, then that indicates that it
+    is no longer reachable from ~HEAD~, but that it has been replaced
+    with one or more commits, which together have the exact same
+    effect.
+
+  - When a commit is prefixed with ~gone~, then that indicates that it
+    is no longer reachable from ~HEAD~ and that we also cannot determine
+    whether its changes are still in effect in one or more new
+    commits.  They might be, but if so, then there must also be other
+    changes which makes it impossible to know for sure.
+
+Do not worry if you do not fully understand the above.  That's okay,
+you will acquire a good enough understanding through practice.
+
+For other sequence operations such as cherry-picking, a similar section
+is displayed, but they lack some of the features described below, due
+to limitations in the git commands used to implement them.  Most
+importantly these sequences only support "picking" a commit but not
+other actions such as "rewording", and they do not keep track of the
+commits which have already been applied.
+
+** Cherry picking
+
+Also see [[info:gitman#git-cherry-pick]].
+
+- Key: A, magit-cherry-pick-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+When no cherry-pick or revert is in progress, then the popup buffer
+features the following commands.
+
+- Key: A A, magit-cherry-pick
+
+  Cherry-pick a commit.  Prompt for a commit, defaulting to the commit
+  at point.  If the region selects multiple commits, then pick all of
+  them, without prompting.
+
+- Key: A a, magit-cherry-apply
+
+  Apply the changes in a commit to the working tree, but do not commit
+  them.  Prompt for a commit, defaulting to the commit at point.  If
+  the region selects multiple commits, then apply all of them, without
+  prompting.
+
+  This command also has a top-level binding, which can be invoked without
+  using the popup by typing ~a~ at the top-level.
+
+When a cherry-pick or revert is in progress, then the popup buffer
+features these commands instead.
+
+- Key: A A, magit-sequence-continue
+
+  Resume the current cherry-pick or revert sequence.
+
+- Key: A s, magit-sequence-skip
+
+  Skip the stopped at commit during a cherry-pick or revert sequence.
+
+- Key: A a, magit-sequence-abort
+
+  Abort the current cherry-pick or revert sequence.  This discards all
+  changes made since the sequence started.
+
+*** Reverting
+
+- Key: V, magit-revert-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+When no cherry-pick or revert is in progress, then the popup buffer
+features the following commands.
+
+- Key: V V, magit-revert
+
+  Revert a commit by creating a new commit.  Prompt for a commit,
+  defaulting to the commit at point.  If the region selects multiple
+  commits, then revert all of them, without prompting.
+
+- Key: V v, magit-revert-no-commit
+
+  Revert a commit by applying it in reverse to the working tree.
+  Prompt for a commit, defaulting to the commit at point.  If the
+  region selects multiple commits, then revert all of them, without
+  prompting.
+
+When a cherry-pick or revert is in progress, then the popup buffer
+features these commands instead.
+
+- Key: V A, magit-sequence-continue
+
+  Resume the current cherry-pick or revert sequence.
+
+- Key: V s, magit-sequence-skip
+
+  Skip the stopped at commit during a cherry-pick or revert sequence.
+
+- Key: V a, magit-sequence-abort
+
+  Abort the current cherry-pick or revert sequence.  This discards all
+  changes made since the sequence started.
+
+** Resetting
+
+Also see [[info:gitman#git-reset]].
+
+- Key: x, magit-reset
+
+  Reset the head and index to some commit read from the user and
+  defaulting to the commit at point.  The working tree is kept as-is.
+  With a prefix argument also reset the working tree.
+
+- Key: M-x magit-reset-index, magit-reset-index
+
+  Reset the index to some commit read from the user and defaulting to
+  the commit at point.  Keep the ~HEAD~ and working tree as-is, so if
+  the commit refers to the ~HEAD~, then this effectively unstages all
+  changes.
+
+- Key: M-x magit-reset-head, magit-reset-head
+
+  Reset the ~HEAD~ and index to some commit read from the user and
+  defaulting to the commit at point.  The working tree is kept as-is.
+
+- Key: M-x magit-reset-soft, magit-reset-soft
+
+  Reset the ~HEAD~ to some commit read from the user and defaulting
+  to the commit at point.  The index and the working tree are kept
+  as-is.
+
+- Key: M-x magit-reset-hard, magit-reset-hard
+
+  Reset the ~HEAD~, index, and working tree to some commit read from the
+  user and defaulting to the commit at point.
+
+- Key: M-x magit-checkout-file, magit-checkout-file
+
+  Update file in the working tree and index to the contents from a
+  revision.
+
+  Both the revision and file are read from the user.
+
+** Stashing
+
+Also see [[info:gitman#git-stash]].
+
+- Key: z, magit-stash-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: z z, magit-stash
+
+  Create a stash of the index and working tree.  Untracked files are
+  included according to popup arguments.  One prefix argument is
+  equivalent to ~--include-untracked~ while two prefix arguments are
+  equivalent to ~--all~.
+
+- Key: z i, magit-stash-index
+
+  Create a stash of the index only.  Unstaged and untracked changes
+  are not stashed.
+
+- Key: z w, magit-stash-worktree
+
+  Create a stash of the working tree only.  Untracked files are
+  included according to popup arguments.  One prefix argument is
+  equivalent to ~--include-untracked~ while two prefix arguments are
+  equivalent to ~--all~.
+
+- Key: z x, magit-stash-keep-index
+
+  Create a stash of the index and working tree, keeping index intact.
+  Untracked files are included according to popup arguments.  One
+  prefix argument is equivalent to ~--include-untracked~ while two
+  prefix arguments are equivalent to ~--all~.
+
+- Key: z Z, magit-snapshot
+
+  Create a snapshot of the index and working tree.  Untracked files
+  are included according to popup arguments.  One prefix argument is
+  equivalent to ~--include-untracked~ while two prefix arguments are
+  equivalent to ~--all~.
+
+- Key: z I, magit-snapshot-index
+
+  Create a snapshot of the index only.  Unstaged and untracked changes
+  are not stashed.
+
+- Key: z W, magit-snapshot-worktree
+
+  Create a snapshot of the working tree only.  Untracked files are
+  included according to popup arguments.  One prefix argument is
+  equivalent to ~--include-untracked~ while two prefix arguments are
+  equivalent to ~--all~-.
+
+- Key: z a, magit-stash-apply
+
+  Apply a stash to the working tree.  Try to preserve the stash index.
+  If that fails because there are staged changes, apply without
+  preserving the stash index.
+
+- Key: z p, magit-stash-pop
+
+  Apply a stash to the working tree and remove it from stash list.
+  Try to preserve the stash index.  If that fails because there are
+  staged changes, apply without preserving the stash index and forgo
+  removing the stash.
+
+- Key: z d, magit-stash-drop
+
+  Remove a stash from the stash list.  When the region is active, offer
+  to drop all contained stashes.
+
+- Key: z l, magit-stash-list
+
+  List all stashes in a buffer.
+
+- Key: z v, magit-stash-show
+
+  Show all diffs of a stash in a buffer.
+
+- Key: z b, magit-stash-branch
+
+  Create and checkout a new BRANCH from STASH.
+
+- Key: z f, magit-stash-format-patch
+
+  Create a patch from STASH.
+
+- Key: k, magit-stash-clear
+  
+  Remove all stashes saved in REF's reflog by deleting REF.
+
+* Transferring
+** Remotes
+
+Also see [[info:gitman#git-remote]].
+
+- Key: M, magit-remote-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: M a, magit-remote-add
+
+  Add a remote and fetch it.  The remote name and url are read in the
+  minibuffer.
+
+- Key: M r, magit-remote-rename
+
+  Rename a remote.  Both the old and the new names are read in the
+  minibuffer.
+
+- Key: M u, magit-remote-set-url
+
+  Change the url of a remote.  Both the remote and the new url are
+  read in the minibuffer.
+
+- Key: M k, magit-remote-remove
+
+  Delete a remote, read from the minibuffer.
+
+** Fetching
+
+Also see [[info:gitman#git-fetch]].
+
+- Key: f, magit-fetch-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: f f, magit-fetch-current
+
+  Fetch from the upstream repository of the current branch.  If ~HEAD~
+  is detached or if the upstream is not configured, then read the
+  remote.
+
+- Key: f o, magit-fetch
+
+  Fetch from another repository.
+
+- Key: f a, magit-fetch-all
+
+  Fetch from all configured remotes.
+
+- Key: f m, magit-submodule-fetch
+
+  Fetch all submodules.  With a prefix argument fetch all remotes or
+  all submodules.
+
+** Pulling
+
+Also see [[info:gitman#git-pull]].
+
+- Key: F, magit-pull-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: F F, magit-pull-current
+
+  Fetch and merge into current branch.
+
+- Key: F o, magit-pull
+
+  Fetch from another repository and merge a fetched branch.
+
+** Pushing
+
+Also see [[info:gitman#git-push]].
+
+- Key: P, magit-push-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: P P, magit-push-current
+
+  Push the current branch to its upstream branch.  If the upstream
+  isn't set, then read the remote branch.
+
+- Key: P o, magit-push
+
+  Push a branch to its upstream branch.  If the upstream isn't set,
+  then read the remote branch.
+
+- Key: P e, magit-push-elsewhere
+
+  Push a branch or commit to some remote branch.  Read the local and
+  remote branch.
+
+- Key: P Q, magit-push-quickly
+
+  Push the current branch to some remote.  When the Git variable
+  ~magit.pushRemote~ is set, then push to that remote.  If that variable
+  is undefined or the remote does not exist, then push to "origin".
+  If that also doesn't exist then raise an error.  The local branch is
+  pushed to the remote branch with the same name.
+
+- Key: P i, magit-push-implicitly
+
+  Push without explicitly specifying what to push.  This runs ~git push
+  -v~.  What is being pushed depends on various Git variables as
+  described in the info:gitman#git-push and info:gitman#git-config
+  manpages.
+
+- Key: P m, magit-push-matching
+
+  Push all matching branches to another repository.  If multiple
+  remotes exit, then read one from the user.  If just one exists, use
+  that without requiring confirmation.
+
+- Key: P t, magit-push-tags
+
+  Push all tags to another repository.  If only one remote exists,
+  then push to that.  Otherwise prompt for a remote, offering the
+  remote configured for the current branch as default.
+
+- Key: P T, magit-push-tag
+
+  Push a tag to another repository.
+
+- User Option: magit-push-always-verify
+
+  Whether certain commands require verification before pushing.
+
+  Starting with ~v2.1.0~ some of the push commands are supposed to
+  push to the configured upstream branch without requiring user
+  confirmation or offering to push somewhere else.
+
+  This has taken a few users by surprise, and they suggested that we
+  force users to opt-in to this behavior.  Unfortunately adding this
+  option means that now other users will complain about us needlessly
+  forcing them to set an option.  This is an attempt to make everyone
+  happy and like all such attempts it is prone to fail.  Before
+  complaining about having to set this option, please consider that
+  other users are less experienced than you and have different needs.
+
+  You should set the value of this option to nil, causing all push
+  commands to behave as intended.  But first read the description of
+  each command above.
+
+** Creating and sending patches
+
+- Key: W, magit-patch-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: W p, magit-format-patch
+
+  Create patches for a set commits.  If the region marks commits, then
+  create patches for those.  Otherwise prompt for a range or a single
+  commit, defaulting to the commit at point.
+
+- Key: W r, magit-request-pull
+
+  Request that upstream pulls from your public repository.
+
+** Applying patches
+
+Also see [[info:gitman#git-am]].
+
+- Key: w, magit-am-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: w w, magit-am-apply-patches
+
+  Apply one or more patches.  If the region marks files, then apply
+  those patches.  Otherwise read a file name in the minibuffer
+  defaulting to the file at point.
+
+- Key: w m, magit-am-apply-maildir
+
+  Apply the patches from a maildir.
+
+- Key: w w, magit-am-continue
+
+  Resume the current patch applying sequence.
+
+- Key: w s, magit-am-skip
+
+  Skip the stopped at patch during a patch applying sequence.
+
+- Key: w a, magit-am-abort
+
+  Abort the current patch applying sequence.  This discards all
+  changes made since the sequence started.
+
+* Miscellaneous
+** Tagging
+
+Also see [[info:gitman#git-tag]].
+
+- Key: t, magit-tag-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: t t, magit-tag
+
+  Create a new tag with the given NAME at REV.  With a prefix argument
+  annotate the tag.
+
+- Key: t k, magit-tag-delete
+
+  Delete one or more tags.  If the region marks multiple tags (and
+  nothing else), then offer to delete those.  Otherwise, prompt for a
+  single tag to be deleted, defaulting to the tag at point.
+
+- Key: t p, magit-tag-prune
+
+  Offer to delete tags missing locally from REMOTE, and vice versa.
+
+** Notes
+
+Also see [[info:gitman#git-notes]].
+
+- Key: T, magit-notes-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: T T, magit-notes-edit
+
+  Edit the note attached to a commit, defaulting to the commit at
+  point.
+
+  By default use the value of Git variable ~core.notesRef~ or
+  "refs/notes/commits" if that is undefined.
+
+- Key: T r, magit-notes-remove
+
+  Remove the note attached to a commit, defaulting to the commit at
+  point.
+
+  By default use the value of Git variable ~core.notesRef~ or
+  "refs/notes/commits" if that is undefined.
+
+- Key: T p, magit-notes-prune
+
+  Remove notes about unreachable commits.
+
+- Key: T s, magit-notes-set-ref
+
+  Set the current notes ref to a the value read from the user.  The
+  ref is made current by setting the value of the Git variable
+  ~core.notesRef~.  With a prefix argument change the global value
+  instead of the value in the current repository.  When this is
+  undefined, then "refs/notes/commit" is used.
+
+  Other ~magit-notes-*~ commands, as well as the sub-commands of Git's
+  ~note~ command, default to operate on that ref.
+
+- Key: T S, magit-notes-set-display-refs
+
+  Set notes refs to be display in addition to "core.notesRef".  This
+  reads a colon separated list of notes refs from the user.  The
+  values are stored in the Git variable ~notes.displayRef~.  With a
+  prefix argument GLOBAL change the global values instead of the
+  values in the current repository.
+
+It is possible to merge one note ref into another.  That may result in
+conflicts which have to resolved in the temporary worktree
+".git/NOTES_MERGE_WORKTREE".
+
+- Key: T m, magit-notes-merge
+
+  Merge the notes of a ref read from the user into the current notes
+  ref.  The current notes ref is the value of Git variable
+  ~core.notesRef~ or "refs/notes/commits" if that is undefined.
+
+When a notes merge is in progress then the popup features the
+following suffix commands, instead of those listed above.
+
+- Key: T c, magit-notes-merge-commit
+
+  Commit the current notes ref merge, after manually resolving
+  conflicts.
+
+- Key: T a, magit-notes-merge-abort
+
+  Abort the current notes ref merge.
+
+** Submodules
+
+Also see [[info:gitman#git-submodule]].
+
+- Key: o, magit-submodule-popup
+
+  This prefix command shows the following suffix commands along with
+  the appropriate infix arguments in a popup buffer.
+
+- Key: o a, magit-submodule-add
+
+  Add the repository at URL as a submodule.  Optional PATH is the path
+  to the submodule relative to the root of the super-project. If it is
+  nil then the path is determined based on URL.
+
+- Key: o b, magit-submodule-setup
+
+  Clone and register missing submodules and checkout appropriate
+  commits.
+
+- Key: o i, magit-submodule-init
+
+  Register submodules listed in ".gitmodules" into ".git/config".
+
+- Key: o u, magit-submodule-update
+
+  Clone missing submodules and checkout appropriate commits.  With a
+  prefix argument also register submodules in ".git/config".
+
+- Key: o s, magit-submodule-sync
+
+  Update each submodule's remote URL according to ".gitmodules".
+
+- Key: o f, magit-submodule-fetch
+
+  Fetch submodule.  With a prefix argument fetch all remotes.
+
+- Key: o i, magit-submodule-init
+
+  Unregister the submodule at PATH.
+
+** Common commands
+
+These are some of the commands that can be used in all buffers whose
+major-modes derive from ~magit-mode~.  There are other common commands
+beside the ones below, but these didn't fit well anywhere else.
+
+- Key: M-w, magit-copy-section-value
+
+  This command saves the value of the current section to the
+  ~kill-ring~, and, provided that the current section is a commit,
+  branch, or tag section, it also pushes the (referenced) revision to
+  the ~magit-revision-stack~.
+
+  When the current section is a branch or a tag, and a prefix argument
+  is used, then it saves the revision at its tip to the ~kill-ring~
+  instead of the reference name.
+
+- Key: C-w, magit-copy-buffer-revision
+
+  This command save the revision being displayed in the current buffer
+  to the ~kill-ring~ and also pushes it to the ~magit-revision-stack~.  It
+  is mainly intended for use in ~magit-revision-mode~ buffers, the only
+  buffers where it is always unambiguous exactly which revision should
+  be saved.
+
+  Most other Magit buffers usually show more than one revision, in
+  some way or another, so this command has to select one of them, and
+  that choice might not always be the one you think would have been
+  the best pick.
+
+Outside of Magit ~M-w~ and ~C-w~ are usually bound to ~kill-ring-save~ and
+~kill-region~, and these commands would also be useful in Magit buffers.
+Therefore when the region is active, then both of these commands
+behave like ~kill-ring-save~ instead of as described above.
+
+** Wip modes
+
+Git keeps *committed* changes around long enough for users to recover
+changes they have accidentally deleted.  It does so by not garbage
+collecting any committed but no longer referenced objects for a
+certain period of time, by default 30 days.
+
+But Git does *not* keep track of *uncommitted* changes in the working tree
+and not even the index (the staging area).  Because Magit makes it so
+convenient to modify uncommitted changes, it also makes it easy to
+shoot yourself in the foot in the process.
+
+For that reason Magit provides three global modes that save *tracked*
+files to work-in-progress references after or before certain actions.
+(Untracked files are never saved and these modes also only work after
+the first commit has been created).
+
+Two separate work-in-progress references are used to track the state
+of the index and of the working tree: "refs/wip/index/<branchref>" and
+"refs/wip/wtree/<branchref>", where ~<branchref>~ is the full ref of the
+current branch, e.g. "refs/heads/master".  When the ~HEAD~ is detached
+then "HEAD" is in place of ~<branchref>~.
+
+Checking out another branch (or detaching ~HEAD~) causes the use of
+different wip refs for subsequent changes, but the old refs are not
+deleted.
+
+Creating a commit and then making a change causes the wip refs to be
+recreated to fork from the new commit.  But the old commits on the wip
+refs are not lost.  They are still available from the reflog.  To make
+it easier to see when the fork point of a wip ref was changed, an
+additional commit with the message "restart autosaving" is created on
+it (~xxO~ commits below are such boundary commits).
+
+Starting with
+
+#+BEGIN_EXAMPLE
+      BI0---BI1    refs/wip/index/refs/heads/master
+     /
+A---B              refs/heads/master
+     \
+      BW0---BW1    refs/wip/wtree/refs/heads/master
+#+END_EXAMPLE
+
+and committing the staged changes and editing and saving a file would
+result in
+
+#+BEGIN_EXAMPLE
+      BI0---BI1        refs/wip/index/refs/heads/master
+     /
+A---B---C              refs/heads/master
+     \   \
+      \   CW0---CW1    refs/wip/wtree/refs/heads/master
+       \
+        BW0---BW1      refs/wip/wtree/refs/heads/master@{2}
+#+END_EXAMPLE
+
+The fork-point of the index wip ref is not changed until some change
+is being staged.  Likewise just checking out a branch or creating a
+commit does not change the fork-point of the working tree wip ref.  The
+fork-points are not adjusted until there actually is a change that
+should be committed to the respective wip ref.
+
+To view the log for the a branch and its wip refs use the commands
+~magit-wip-log~ and ~magit-wip-log-current~.  You should use ~--graph~ when
+using these commands.  Alternatively you can use the reflog to show
+all commits that ever existed on a wip ref.  You can then recover lost
+changes from the commits shown in the log or reflog.
+
+- Command: magit-wip-log
+
+  This command shows the log for a branch and its wip refs.
+
+  With a negative prefix argument only the worktree wip ref is shown.
+  The absolute numeric value of the prefix argument controls how many
+  "branches" of each wip ref are shown.
+
+- Command: magit-wip-log-current
+
+  This command shows the log for the current branch and its wip refs.
+
+  With a negative prefix argument only the worktree wip ref is shown.
+  The absolute numeric value of the prefix argument controls how many
+  "branches" of each wip ref are shown.
+
+There exists a total of three global modes that save to the wip refs,
+which might seem excessive, but allows fine tuning of when exactly
+changes are being committed to the wip refs.  Enabling all modes makes
+it less likely that a change slips through the cracks.
+
+Setting the below variable directly does not take effect; either
+customize them or call the respective mode function.
+
+- User Option: magit-wip-after-save-mode
+
+  When this mode is enabled, then saving a buffer that visits a file
+  tracked in a Git repository causes its current state to be committed
+  to the working tree wip ref for the current branch.
+
+- User Option: magit-wip-after-apply-mode
+
+  When this mode is enabled, then applying (i.e. staging, unstaging,
+  discarding, reversing, and regularly applying) a change to a file
+  tracked in a Git repository causes its current state to be committed
+  to the index and/or working tree wip refs for the current branch.
+
+If you only ever edit files using Emacs and only ever interact with
+Git using Magit, then the above two modes should be enough to protect
+each and every change from accidental loss.  In practice nobody does
+that.  So an additional mode exists that does commit to the wip refs
+before making changes that could cause the loss of earlier changes.
+
+- User Option: magit-wip-before-change-mode
+
+  When this mode is enabled, then certain commands commit the existing
+  changes to the files they are about to make changes to.
+
+Note that even if you enable all three modes this won't give you
+perfect protection.  The most likely scenario for losing changes
+despite the use of these modes is making a change outside Emacs and
+then destroying it also outside Emacs.  In such a scenario, Magit,
+being an Emacs package, didn't get the opportunity to keep you from
+shooting yourself in the foot.
+
+When you are unsure whether Magit did commit a change to the wip refs,
+then you can explicitly request that all changes to all tracked files
+are being committed.
+
+- Key: M-x magit-wip-commit, magit-wip-commit
+
+  This command commits all changes to all tracked files to the index
+  and working tree work-in-progress refs.  Like the modes described above,
+  it does not commit untracked files, but it does check all tracked
+  files for changes.  Use this command when you suspect that the modes
+  might have overlooked a change made outside Emacs/Magit.
+
+- User Option: magit-wip-after-save-local-mode-lighter
+
+  Mode-line lighter for ~magit-wip-after-save-local-mode~.
+
+- User Option: magit-wip-after-apply-mode-lighter
+
+  Mode-line lighter for ~magit-wip-after-apply-mode~.
+
+- User Option: magit-wip-before-change-mode-lighter
+
+  Mode-line lighter for ~magit-wip-before-change-mode~.
+
+- User Option: magit-wip-namespace
+
+  The namespace used for work-in-progress refs.  It has to end with a
+  slash.  The wip refs are named "<namespace>index/<branchref>" and
+  "<namespace>wtree/<branchref>".  When snapshots are created while
+  the ~HEAD~ is detached then "HEAD" is used in place of ~<branchref>~.
+
+** Minor mode for buffers visiting files
+
+The ~magit-file-mode~ enables certain Magit features in file-visiting
+buffers belonging to a Git repository.  It should be enabled globally
+using ~global-magit-file-mode~.  Currently this mode only establishes a
+few key bindings, but this might be extended in the future.
+
+- User Option: global-magit-file-mode
+
+  Whether to establish certain Magit key bindings in all file-visiting
+  buffers belonging to a Git repository.  This establishes the
+  bindings suggested in [[*Getting started]] (but only for file-visiting
+  buffers), and additionally binds ~C-c M-g~ to ~magit-file-popup~.
+
+- Key: C-c M-g, magit-file-popup
+
+  This prefix command shows a popup buffer featuring suffix commands
+  that operate on the file being visited in the current buffer.
+
+- Key: C-c M-g s, magit-stage-file
+
+  Stage all changes to the file being visited in the current buffer.
+
+- Key: C-c M-g u, magit-unstage-file
+
+  Unstage all changes to the file being visited in the current buffer.
+
+- Key: C-c M-g l, magit-log-buffer-file
+
+  This command shows the log for the file of blob that the current
+  buffer visits.  Renames are followed when a prefix argument is used
+  or when ~--follow~ is part of ~magit-log-arguments~.
+
+- Key: C-c M-g b, magit-blame-popup
+
+  This prefix command shows the ~magit-blame~ suffix command along with
+  the appropriate infix arguments in a popup buffer.  See [[*Initiating
+  a commit]].
+
+- Key: C-c M-g p, magit-blob-previous
+
+  Visit the previous blob which modified the current file.
+
+- Key: C-c M-g c, magit-commit-popup
+
+  This prefix command shows suffix commands along with the appropriate
+  infix arguments in a popup buffer.  See [[*Initiating a commit]].
+
+** Minor mode for buffers visiting blobs
+
+The ~magit-blob-mode~ enables certain Magit features in blob-visiting
+buffers.  Such buffers can be created using ~magit-find-file~ and some
+of the commands mentioned below, which also take care of turning on
+this minor mode.  Currently this mode only establishes a few key
+bindings, but this might be e
+
+- Key: p, magit-blob-previous
+
+  Visit the previous blob which modified the current file.
+
+- Key: n, magit-blob-next
+
+  Visit the next blob which modified the current file.
+
+- Key: q, magit-kill-this-buffer
+
+  Kill the current buffer.
+
+* Customizing
+
+Both Git and Emacs are highly customizable.  Magit is both a Git
+porcelain as well as an Emacs package, so it makes sense to customize
+it using both Git variables as well as Emacs options.  However this
+flexibility doesn't come without problems, including but not limited
+to the following.
+
+- Some Git variables automatically have an effect in Magit without
+  requiring any explicit support.  Sometimes that is desirable - in
+  other cases, it breaks Magit.
+
+  When a certain Git setting breaks Magit but you want to keep using
+  that setting on the command line, then that can be accomplished by
+  overriding the value for Magit only by appending something like
+  ~("-c" "some.variable=compatible-value")~ to
+  ~magit-git-global-arguments~.
+
+- Certain settings like ~fetch.prune=true~ are respected by Magit
+  commands (because they simply call the respective Git command) but
+  their value is not reflected in the respective popup buffers.  In
+  this case the ~--prune~ argument in ~magit-fetch-popup~ might be active
+  or inactive depending on the value of ~magit-fetch-arguments~ only,
+  but that doesn't keep the Git variable from being honored by the
+  suffix commands anyway.  So pruning might happen despite the the
+  ~--prune~ arguments being displayed in a way that seems to indicate
+  that no pruning will happen.
+
+I intend to address these and similar issues in a future release.
+
+** Per-repository configuration
+
+Magit can be configured on a per-repository level using both Git
+variables as well as Emacs options.
+
+To set a Git variable for one repository only, simply set it in
+~/path/to/repo/.git/config~ instead of ~$HOME/.gitconfig~ or
+~/etc/gitconfig~.  See [[info:gitman#git-config]].
+
+Similarly, Emacs options can be set for one repository only by editing
+~/path/to/repo/.dir-locals.el~.  See [[info:emacs#Directory Variables]].
+For example to disable automatic refreshes of file-visiting buffers in
+just one huge repository use this:
+
+- ~/path/to/huge/repo/.dir-locals.el~
+
+  #+BEGIN_SRC emacs-lisp
+    ((nil . ((magit-refresh-buffers . nil))
+  #+END_SRC
+
+If you want to apply the same settings to several, but not all,
+repositories then keeping the repository-local config files in sync
+would quickly become annoying.  To avoid that you can create config
+files for certain classes of repositories (e.g. "huge repositories")
+and then include those files in the per-repository config files.
+For example:
+
+- ~/path/to/huge/repo/.git/config~
+
+  #+BEGIN_SRC conf
+    [include]
+            path = /path/to/huge-gitconfig
+  #+END_SRC
+
+- ~/path/to/huge-gitconfig~
+
+  #+BEGIN_SRC conf
+    [status]
+            showUntrackedFiles = no
+  #+END_SRC
+
+- ~$HOME/.emacs.d/init.el~
+
+  #+BEGIN_SRC emacs-lisp
+    (dir-locals-set-class-variables 'huge-git-repository
+       '((nil . ((magit-refresh-buffers . nil)))))
+
+    (dir-locals-set-directory-class
+       "/path/to/huge/repo/" 'huge-git-repository)
+  #+END_SRC
+
+** Essential settings
+
+The next two sections list and discuss several variables that many
+users might want to customize, for safety and/or performance reasons.
+
+*** Safety
+
+This section discusses various variables that you might want to
+change (or *not* change) for safety reasons.
+
+Git keeps *committed* changes around long enough for users to recover
+changes they have accidentally deleted.  It does not do the same for
+*uncommitted* changes in the working tree and not even the index (the
+staging area).  Because Magit makes it so easy to modify uncommitted
+changes, it also makes it easy to shoot yourself in the foot in the
+process.  For that reason Magit provides three global modes that save
+*tracked* files to work-in-progress references after or before certain
+actions.  See [[*Wip modes]].
+
+These modes are not enabled by default because of performance
+concerns.  Instead a lot of potentially destructive commands require
+confirmation every time they are used.  In many cases this can be
+disabled by adding a symbol to ~magit-no-confirm~ (see [[*Completion and
+confirmation]]).  If you enable the various wip modes then you should
+add ~safe-with-wip~ to this list.
+
+Similarly it isn't necessary to require confirmation before moving a
+file to the system trash - if you trashed a file by mistake then you
+can recover it from the there.  Option ~magit-delete-by-moving-to-trash~
+controls whether the system trash is used, which is the case by default.
+Nevertheless, ~trash~ isn't a member of ~magit-no-confirm~ - you
+might want to change that.
+
+Buffers visiting files tracked in the current repository are being
+refreshed before certain actions.  See [[*Automatic refresh and revert]].
+This isn't as risky as it might seem.  If a buffer is modified
+(i.e. it contains changes that haven't been saved yet), then
+Emacs/Magit would refuse to revert it.  If the buffer has been saved
+resulting in what is seen by Git as an uncommitted change, then Git in
+turn would refuse to carry out the action that would cause these
+changes to be lost.  Since Git doesn't do anything, the file doesn't
+change on disk, and Emacs/Magit has nothing to revert.
+
+However if you do modify some files, visit the respective files in
+Emacs, somehow discard the changes (not using Magit and probably even
+outside Emacs), and then expect the respective file-visiting buffers
+to retain the uncommitted changes, then the automatic reverting would
+actually be harmful.  In other words if you use file-visiting buffers
+as a sort of "staging area", then you should set ~magit-revert-buffers~
+to ~nil~.
+
+So far I have only heard from one user who uses such a workflow.  But
+because there might be some other users doing such things, and I don't
+want to be responsible for data loss, these reverts by default happen
+quite verbosely, allowing these few users to undo the reverts using
+the ~undo~ command and then disabling the automatic reverts for the
+future.  Most users should however keep automatic reverts turned on
+and instead configure it to be less verbose by setting
+~magit-revert-buffers~ to ~t~ or even ~silent~.
+
+*** Performance
+
+Magit is slower than raw Git because it does more.  For example ~git
+commit~ creates a commit and that's it.  ~magit-commit~ also updates the
+current Magit buffer to make sure you are not looking at outdated
+information without noticing it.  To refresh the status buffer, Magit
+has to run Git a dozen times or more, making it slower than ~git
+status~, but also much more informative.  Magit also optionally reverts
+file-visiting buffers, creates backups, runs hooks where third-party
+extensions can do their slow thing, etc.
+
+I do care about performance and try to optimize for it as much as
+possible, but many features simply come with an inherent performance
+penalty.  When a feature is just too slow given certain usage and
+repository characteristics, then it often can be disabled, globally or
+on a per-repository basis.
+
+But first a short list of performance issues that cannot easily be
+worked around:
+
+- Creating a new process on MS Windows is much slower than on
+  POSIX-compatible systems.  This is a problem because Magit creates a
+  lot of child processes to retrieve information from Git.  In the
+  short run, only switching to a POSIX system can fix this.  Of course
+  this could also be fixed in Windows itself, but I am just one unpaid
+  person while Microsoft is a billion dollar company, so I will leave
+  it to them to fix this grave flaw in their OS.
+
+- When showing logs, Magit limits the number of commits initially
+  shown in the hope that this avoids unnecessary work.  When using
+  ~--graph~ this unfortunately does not have the desired effect for
+  large histories.  Junio said on the git mailing list
+  (http://www.spinics.net/lists/git/msg232230.html): "~--graph~ wants to
+  compute the whole history and the max-count only affects the output
+  phase after ~--graph~ does its computation".
+
+  In other words, it's not that Git is slow at outputting the
+  differences, or that Magit is slow at parsing the output - the
+  problem is that Git first goes outside and has a smoke.
+
+  We actually work around this issue by limiting the commit not only
+  using ~-<N>~ but also using a range.  But unfortunately that's not
+  always possible.
+
+- Whenever "something changes", Magit "refreshes" the status buffer and
+  the current Magit buffer by recreating them from scratch.  This is
+  an old design decision that we couldn't depart from easily.  And it
+  has its benefits too - most importantly it's much simpler and less
+  error prone to do it this way than to only refreshing "what actually
+  has changed" (that would basically be a huge collection of special
+  cases).  So for now at least, we don't avoid recreating the buffer
+  content and instead focus on making doing so faster.
+
+Now for the things that you can do to improve performance:
+
+Most optional features which can have a negative effect on performance
+are disabled by default.  So start by checking the options you have
+explicitly enabled.  Even the potentially slow features are expected
+to only lead to barely noticeable delays, but your mileage may vary.
+Also note that it is now possible to set options on a per-repository
+or per-repository-class basis.  See [[*Per-repository configuration]].
+
+You should check the values of at least the following variables:
+
+- ~magit-after-revert-hook~
+- ~magit-diff-auto-show~
+- ~magit-diff-highlight-hunk-body~
+- ~magit-diff-highlight-indentation~
+- ~magit-diff-highlight-trailing~
+- ~magit-diff-paint-whitespace~
+- ~magit-diff-refine-hunk~
+- ~magit-log-arguments~, ~magit-log-select-arguments~, and
+  ~magit-log-section-arguments~
+
+  In repositories with more than a few thousand commits ~--graph~ should
+  never be a member of ~magit-log-section-arguments~.  That variable is
+  in the status buffer which is refreshed every time you run any Magit
+  command.
+
+  Using ~--color --graph~ is even slower.  Magit uses code that is part
+  of Emacs to turn control characters into faces.  That code is pretty
+  slow and this is quite noticeable when showing a log with many
+  branches and merges.  For that reason ~--color~ is not enabled by
+  default anymore.  Consider leaving it at that.
+
+- ~magit-not-reverted-hook~
+- ~magit-refresh-buffer-hook~
+- ~magit-refs-sections-hook~
+
+  When refreshing the "references buffer" is slow, then that's usually
+  because several hundred refs are being displayed.  The best way to
+  address that is to display fewer refs, obviously.
+
+  If you are not, or only mildly, interested in seeing the list of
+  tags, then start by not displaying them:
+
+  #+BEGIN_SRC emacs-lisp
+    (remove-hook 'magit-refs-sections-hook 'magit-insert-tags)
+  #+END_SRC
+
+  Then you should also make sure that the listed remote branches
+  actually all exist.  You can do so by pruning branches which no
+  longer exist using ~f-pa~.
+
+- ~magit-status-refresh-hook~
+- ~magit-wip-after-apply-mode~
+- ~magit-wip-after-save-mode~
+- ~magit-wip-before-change-mode~
+
+Also note that everything involving "cherry commits" is slow.
+
+If, after actually trying the above suggestions, performance is still
+bad, and the above does not contain a statement explaining why that is
+so in that particular case and that there is nothing that we can
+currently do about it, then comment on the appropriate existing issue
+(see https://github.com/magit/magit/labels/performance), or if
+necessary open a new issue.  Note that "something is slow, I am using
+v2.2" is not helpful, you have to be a bit more specific.  Benchmarks
+are a start.
+
+* Plumbing
+
+The following sections describe how to use several of Magit's core
+abstractions to extend Magit itself or implement a separate extension.
+
+A few of the low-level features used by Magit have been factored out
+into separate libraries/packages, so that they can be used by other
+packages, without having to depend on Magit.  These libraries are
+described in separate manuals, see [[info:with-editor]] and
+[[info:magit-popup]].
+
+** Calling Git
+
+Magit provides many specialized functions for calling Git.  All of
+these functions are defined in either ~magit-git.el~ or ~magit-process.el~
+and have one of the prefixes ~magit-run-~, ~magit-call-~, ~magit-start-~,
+or ~magit-git-~ (which is also used for other things).
+
+All of these functions accept an indefinite number of arguments, which
+are strings that specify command line arguments for git (or in some
+cases an arbitrary executable).  These arguments are flattened before
+being passed on to the executable; so instead of strings they can also
+be lists of strings and arguments that are ~nil~ are silently dropped.
+Some of these functions also require a single mandatory argument
+before these command line arguments.
+
+Roughly speaking these functions run Git either to get some value or
+for side-effect.  The functions that return a value are useful to
+collect the information necessary to populate a Magit buffer, while
+the others are used to implement Magit commands.
+
+The functions in the value-only group always run synchronously, and
+they never trigger a refresh.  The function in the side-effect group
+can be further divided into subgroups depending on whether they run
+Git synchronously or asynchronously, and depending on whether they
+trigger a refresh when the executable has finished.
+
+*** Getting a value from Git
+
+These functions run Git in order to get a value, either its exit
+status or its output.  Of course you could also use them to run Git
+commands that have side-effects, but that should be avoided.
+
+- Function: magit-git-exit-code &rest args
+
+  Executes git with ARGS and returns its exit code.
+
+- Function: magit-git-success &rest args
+
+  Executes git with ARGS and returns ~t~ if the exit code is ~0~, ~nil~
+  otherwise.
+
+- Function: magit-git-failure &rest args
+
+  Executes git with ARGS and returns ~t~ if the exit code is ~1~, ~nil~
+  otherwise.
+
+- Function: magit-git-true &rest args
+
+  Executes git with ARGS and returns ~t~ if the first line printed by
+  git is the string "true", ~nil~ otherwise.
+
+- Function: magit-git-false &rest args
+
+  Executes git with ARGS and returns ~t~ if the first line printed by
+  git is the string "false", ~nil~ otherwise.
+
+- Function: magit-git-insert &rest args
+
+  Executes git with ARGS and inserts its output at point.
+
+- Function: magit-git-string &rest args
+
+  Executes git with ARGS and returns the first line of its output.  If
+  there is no output or if it begins with a newline character, then
+  this returns ~nil~.
+
+- Function: magit-git-lines &rest args
+
+  Executes git with ARGS and returns its output as a list of lines.
+  Empty lines anywhere in the output are omitted.
+
+- Function: magit-git-items &rest args
+
+  Executes git with ARGS and returns its null-separated output as a
+  list.  Empty items anywhere in the output are omitted.
+
+  If the value of option ~magit-git-debug~ is non-nil and git exits with
+  a non-zero exit status, then warn about that in the echo area and
+  add a section containing git's standard error in the current
+  repository's process buffer.
+
+When an error occurs when using one of the above functions, then that
+is usually due to a bug, i.e. the use of an argument which is not
+actually supported.  Such errors are usually not reported, but when
+they occur we need to be able to debug them.
+
+- User Option: magit-git-debug
+
+  Whether to report errors that occur when using ~magit-git-insert~,
+  ~magit-git-string~, ~magit-git-lines~, or ~magit-git-items~.  This does
+  not actually raise an error.  Instead a message is shown in the echo
+  area, and git's standard error is insert into a new section in the
+  current repository's process buffer.
+
+- Function: magit-git-str &rest args
+
+  This is a variant of ~magit-git-string~ that ignores the option
+  ~magit-git-debug~.  It is mainly intended to be used while handling
+  errors in functions that do respect that option.  Using such a
+  function while handing an error could cause yet another error and
+  therefore lead to an infinite recursion.  You probably won't ever
+  need to use this function.
+
+*** Calling Git for effect
+
+These functions are used to run git to produce some effect.  Most
+Magit commands that actually run git do so by using such a function.
+
+Because we do not need to consume git's output when using these
+functions, their output is instead logged into a per-repository
+buffer, which can be shown using ~$~ from a Magit buffer or ~M-x
+magit-process~ elsewhere.
+
+These functions can have an effect in two distinct ways.  Firstly,
+running git may change something, i.e. create or push a new commit.
+Secondly, that change may require that Magit buffers are refreshed to
+reflect the changed state of the repository.  But refreshing isn't
+always desirable, so only some of these functions do perform such a
+refresh after git has returned.
+
+Sometimes it is useful to run git asynchronously.  For example, when
+the user has just initiated a push, then there is no reason to make
+her wait until that has completed.  In other cases it makes sense to
+wait for git to complete before letting the user do something else.
+For example after staging a change it is useful to wait until after
+the refresh because that also automatically moves to the next change.
+
+- Function: magit-call-git &rest args
+
+  Calls git synchronously with ARGS.
+
+- Function: magit-call-process program &rest args
+
+  Calls PROGRAM synchronously with ARGS.
+
+- Function: magit-run-git &rest args
+
+  Calls git synchronously with ARGS and then refreshes.
+
+- Function: magit-run-git-with-input input &rest args
+
+  Calls git synchronously with ARGS and sends it INPUT on standard
+  input.
+
+  INPUT should be a buffer or the name of an existing buffer.  The
+  content of that buffer is used as the process' standard input.
+  After the process returns a refresh is performed.
+
+  As a special case, INPUT may also be nil.  In that case the content
+  of the current buffer is used as standard input and *no* refresh is
+  performed.
+
+  This function actually runs git asynchronously.  But then it waits
+  for the process to return, so the function itself is synchronous.
+
+- Function: magit-run-git-with-logfile file &rest args
+
+  Calls git synchronously with ARGS.  The process' output is saved in
+  FILE.  This is rarely useful and so this function might be removed
+  in the future.
+
+  This function actually runs git asynchronously.  But then it waits
+  for the process to return, so the function itself is synchronous.
+
+- Function: magit-git &rest args
+
+  Calls git synchronously with ARGS for side-effects only.  This
+  function does not refresh the buffer.
+
+- Function: magit-git-wash washer &rest args
+
+  Execute Git with ARGS, inserting washed output at point.  Actually
+  first insert the raw output at point.  If there is no output call
+  ~magit-cancel-section~.  Otherwise temporarily narrow the buffer to
+  the inserted text, move to its beginning, and then call function
+  WASHER with no argument.
+
+And now for the asynchronous variants.
+
+- Function: magit-run-git-async &rest args
+
+  Start Git, prepare for refresh, and return the process object.
+  ARGS is flattened and then used as arguments to Git.
+
+  Display the command line arguments in the echo area.
+
+  After Git returns some buffers are refreshed: the buffer that was
+  current when this function was called (if it is a Magit buffer and
+  still alive), as well as the respective Magit status buffer.
+  Unmodified buffers visiting files that are tracked in the current
+  repository are reverted if ~magit-revert-buffers~ is non-nil.
+
+- Function: magit-run-git-with-editor &rest args
+
+  Export GIT_EDITOR and start Git.  Also prepare for refresh and
+  return the process object.  ARGS is flattened and then used as
+  arguments to Git.
+
+  Display the command line arguments in the echo area.
+
+  After Git returns some buffers are refreshed: the buffer that was
+  current when this function was called (if it is a Magit buffer and
+  still alive), as well as the respective Magit status buffer.
+
+- Function: magit-start-git &rest args
+
+  Start Git, prepare for refresh, and return the process object.
+
+  If INPUT is non-nil, it has to be a buffer or the name of an
+  existing buffer.  The buffer content becomes the processes
+  standard input.
+
+  Option ~magit-git-executable~ specifies the Git executable and option
+  ~magit-git-global-arguments~ specifies constant arguments.  The
+  remaining arguments ARGS specify arguments to Git.  They are
+  flattened before use.
+
+  After Git returns, some buffers are refreshed: the buffer that was
+  current when this function was called (if it is a Magit buffer and
+  still alive), as well as the respective Magit status buffer.
+  Unmodified buffers visiting files that are tracked in the current
+  repository are reverted if ~magit-revert-buffers~ is non-nil.
+
+- Function: magit-start-process &rest args
+
+  Start PROGRAM, prepare for refresh, and return the process object.
+
+  If optional argument INPUT is non-nil, it has to be a buffer or
+  the name of an existing buffer.  The buffer content becomes the
+  processes standard input.
+
+  The process is started using ~start-file-process~ and then setup to
+  use the sentinel ~magit-process-sentinel~ and the filter
+  ~magit-process-filter~.  Information required by these functions is
+  stored in the process object.  When this function returns the
+  process has not started to run yet so it is possible to override the
+  sentinel and filter.
+
+  After the process returns, ~magit-process-sentinel~ refreshes the
+  buffer that was current when ~magit-start-process~ was called (if it
+  is a Magit buffer and still alive), as well as the respective Magit
+  status buffer.  Unmodified buffers visiting files that are tracked
+  in the current repository are reverted if ~magit-revert-buffers~ is
+  non-nil.
+
+- Variable: magit-this-process
+
+  The child process which is about to start.  This can be used to
+  change the filter and sentinel.
+
+- Variable: magit-process-raise-error
+
+  When this is non-nil, then ~magit-process-sentinel~ raises an error if
+  git exits with a non-zero exit status.  For debugging purposes.
+
+** Section plumbing
+*** Creating sections
+
+- Macro: magit-insert-section &rest args
+
+  Insert a section at point.
+
+  TYPE is the section type, a symbol.  Many commands that act on the
+  current section behave differently depending on that type.  Also if
+  a variable ~magit-TYPE-section-map~ exists, then use that as the
+  text-property ~keymap~ of all text belonging to the section (but this
+  may be overwritten in subsections).
+
+  Optional VALUE is the value of the section, usually a string that is
+  required when acting on the section.
+
+  When optional HIDE is non-nil collapse the section body by default,
+  i.e. when first creating the section, but not when refreshing the
+  buffer.  Otherwise, expand it by default.  This can be overwritten using
+  ~magit-section-set-visibility-hook~.  When a section is recreated
+  during a refresh, then the visibility of predecessor is inherited
+  and HIDE is ignored (but the hook is still honored).
+
+  BODY is any number of forms that actually insert the section's
+  heading and body.  Optional NAME, if specified, has to be a symbol,
+  which is then bound to the struct of the section being inserted.
+
+  Before BODY is evaluated the ~start~ of the section object is set to
+  the value of ~point~ and after BODY was evaluated its ~end~ is set to
+  the new value of ~point~; BODY is responsible for moving ~point~
+  forward.
+
+  If it turns out inside BODY that the section is empty, then
+  ~magit-cancel-section~ can be used to abort and remove all traces of
+  the partially inserted section.  This can happen when creating a
+  section by washing Git's output and Git didn't actually output
+  anything this time around.
+
+- Function: magit-insert-heading &rest args
+
+  Insert the heading for the section currently being inserted.
+
+  This function should only be used inside ~magit-insert-section~.
+
+  When called without any arguments, then just set the ~content~ slot of
+  the object representing the section being inserted to a marker at
+  ~point~.  The section should only contain a single line when this
+  function is used like this.
+
+  When called with arguments ARGS, which have to be strings, then
+  insert those strings at point.  The section should not contain any
+  text before this happens and afterwards it should again only contain
+  a single line.  If the ~face~ property is set anywhere inside any of
+  these strings, then insert all of them unchanged.  Otherwise use the
+  ~magit-section-heading~ face for all inserted text.
+
+  The ~content~ property of the section struct is the end of the heading
+  (which lasts from ~start~ to ~content~) and the beginning of the body
+  (which lasts from ~content~ to ~end~).  If the value of ~content~ is nil,
+  then the section has no heading and its body cannot be collapsed.
+  If a section does have a heading then its height must be exactly one
+  line, including a trailing newline character.  This isn't enforced;
+  you are responsible for getting it right.  The only exception is
+  that this function does insert a newline character if necessary.
+
+- Function: magit-cancel-section
+
+  Cancel the section currently being inserted.  This exits the
+  innermost call to ~magit-insert-section~ and removes all traces of
+  what has already happened inside that call.
+
+- Function: magit-define-section-jumper sym title &optional value
+
+  Define an interactive function to go to section SYM.  TITLE is the
+  displayed title of the section.
+
+*** Section selection
+
+- Function: magit-current-section
+
+  Return the section at point.
+
+- Function: magit-region-sections
+
+  Return a list of the selected sections.
+
+  When the region is active and constitutes a valid section selection,
+  then return a list of all selected sections.  This is the case when
+  the region begins in the heading of a section and ends in the
+  heading of a sibling of that first section.  When the selection is
+  not valid then return nil.  Most commands that can act on the
+  selected sections, then instead just act on the current section, the
+  one point is in.
+
+  When the region looks like it would in any other buffer then the
+  selection is invalid.  When the selection is valid then the region
+  uses the ~magit-section-highlight~.  This does not apply to diffs where
+  things get a bit more complicated, but even here if the region looks
+  like it usually does, then that's not a valid selection as far as
+  this function is concerned.
+
+- Function: magit-region-values &rest types
+
+  Return a list of the values of the selected sections.
+
+  Also see ~magit-region-sections~ whose doc-string explains when a
+  region is a valid section selection.  If the region is not active
+  or is not a valid section selection, then return nil.  If optional
+  TYPES is non-nil then the selection not only has to be valid; the
+  types of all selected sections additionally have to match one of
+  TYPES, or nil is returned.
+
+*** Matching sections
+
+- Key: M-x magit-describe-section, magit-describe-section
+
+  Show information about the section at point.  This command is
+  intended for debugging purposes.
+
+- Function: magit-section-ident
+
+  Return an unique identifier for SECTION.  The return value has the
+  form ~((TYPE . VALUE)...)~.
+
+- Function: magit-get-section
+
+  Return the section identified by IDENT.  IDENT has to be a list as
+  returned by ~magit-section-ident~.
+
+- Function: magit-section-match condition &optional section
+
+  Return ~t~ if SECTION matches CONDITION.  SECTION defaults to the
+  section at point.
+
+  Conditions can take the following forms:
+  - ~(CONDITION...)~
+
+    matches if any of the CONDITIONs matches.
+
+  - ~[TYPE...]~
+
+    matches if the first TYPE matches the type of the section at
+    point, the second matches that of its parent, and so on.
+
+  - ~[* TYPE...]~
+
+    matches sections that match [TYPE...] and also recursively all
+    their child sections.
+
+  - ~TYPE~
+
+    matches TYPE regardless of its parents.
+
+  Each TYPE is a symbol.  Note that is not necessary to specify all
+  TYPEs up to the root section as printed by ~magit-describe-type~,
+  unless of course your want to be that precise.
+
+- Function: magit-section-when condition &rest body
+
+  If the section at point matches CONDITION evaluate BODY.
+
+  If the section matches evaluate BODY forms sequentially and return
+  the value of the last one, or if there are no BODY forms return the
+  value of the section.  If the section does not match return nil.
+
+  See ~magit-section-match~ for the forms CONDITION can take.
+
+- Function: magit-section-case &rest clauses
+
+  Choose among clauses on the type of the section at point.
+
+  Each clause looks like (CONDITION BODY...).  The type of the
+  section is compared against each CONDITION; the BODY forms of the
+  first match are evaluated sequentially and the value of the last
+  form is returned.  Inside BODY the symbol ~it~ is bound to the
+  section at point.  If no clause succeeds or if there is no
+  section at point return nil.
+
+  See ~magit-section-match~ for the forms CONDITION can take.
+  Additionally a CONDITION of t is allowed in the final clause and
+  matches if no other CONDITION match, even if there is no section at
+  point.
+
+- Variable: magit-root-section
+
+  The root section in the current buffer.  All other sections are
+  descendants of this section.  The value of this variable is set by
+  ~magit-insert-section~ and you should never modify it.
+
+For diff related sections a few additional tools exist.
+
+- Function: magit-diff-type &optional section
+
+  Return the diff type of SECTION.
+
+  The returned type is one of the symbols ~staged~, ~unstaged~, ~committed~,
+  or ~undefined~.  This type serves a similar purpose as the general
+  type common to all sections (which is stored in the ~type~ slot of the
+  corresponding ~magit-section~ struct) but takes additional information
+  into account.  When the SECTION isn't related to diffs and the
+  buffer containing it also isn't a diff-only buffer, then return nil.
+
+  Currently the type can also be one of ~tracked~ and ~untracked~, but
+  these values are not handled explicitly in every place they should
+  be.  A possible fix could be to just return nil here.
+
+  The section has to be a ~diff~ or ~hunk~ section, or a section whose
+  children are of type ~diff~.  If optional SECTION is nil, return the
+  diff type for the current section.  In buffers whose major mode is
+  ~magit-diff-mode~ SECTION is ignored and the type is determined using
+  other means.  In ~magit-revision-mode~ buffers the type is always
+  ~committed~.
+
+- Function: magit-diff-scope &optional section strict
+
+  Return the diff scope of SECTION or the selected section(s).
+
+  A diff's "scope" describes what part of a diff is selected, it is a
+  symbol, one of ~region~, ~hunk~, ~hunks~, ~file~, ~files~, or ~list~.  Do not
+  confuse this with the diff "type", as returned by ~magit-diff-type~.
+
+  If optional SECTION is non-nil, then return the scope of that,
+  ignoring the sections selected by the region.  Otherwise return the
+  scope of the current section, or if the region is active and selects
+  a valid group of diff related sections, the type of these sections,
+  i.e. ~hunks~ or ~files~.  If SECTION (or if the current section that
+  is nil) is a ~hunk~ section and the region starts and ends inside
+  the body of a that section, then the type is ~region~.
+
+  If optional STRICT is non-nil then return nil if the diff type of
+  the section at point is ~untracked~ or the section at point is not
+  actually a ~diff~ but a ~diffstat~ section.
+
+** Refreshing buffers
+
+All commands that create a new Magit buffer or change what is being
+displayed in an existing buffer do so by calling ~magit-mode-setup~.
+Among other things, that function sets the buffer local values of
+~default-directory~ (to the top-level of the repository),
+~magit-refresh-function~, and ~magit-refresh-args~.
+
+Buffers are refreshed by calling the function that is the local value
+of ~magit-refresh-function~ (a function named ~magit-*-refresh-buffer~,
+where ~*~ may be something like ~diff~) with the value of
+~magit-refresh-args~ as arguments.
+
+- Macro: magit-mode-setup buffer switch-func mode refresh-func &optional refresh-args
+
+  This function displays and selects BUFFER, turns on MODE, and
+  refreshes a first time.
+
+  This function displays and optionally selects BUFFER by calling
+  ~magit-mode-display-buffer~ with BUFFER, MODE and SWITCH-FUNC as
+  arguments.  Then it sets the local value of ~magit-refresh-function~
+  to REFRESH-FUNC and that of ~magit-refresh-args~ to REFRESH-ARGS.
+  Finally it creates the buffer content by calling REFRESH-FUNC with
+  REFRESH-ARGS as arguments.
+
+  All arguments are evaluated before switching to BUFFER.
+
+- Function: magit-mode-display-buffer buffer mode &optional switch-function
+
+  This function display BUFFER in some window and select it.  BUFFER
+  may be a buffer or a string, the name of a buffer.  The buffer is
+  returned.
+
+  Unless BUFFER is already displayed in the selected frame, store the
+  previous window configuration as a buffer local value, so that it
+  can later be restored by ~magit-mode-bury-buffer~.
+
+  The buffer is displayed and selected using SWITCH-FUNCTION.  If that
+  is ~nil~ then ~pop-to-buffer~ is used if the current buffer's major mode
+  derives from ~magit-mode~.  Otherwise ~switch-to-buffer~ is used.
+
+- Variable: magit-refresh-function
+
+  The value of this buffer-local variable is the function used to
+  refresh the current buffer.  It is called with ~magit-refresh-args~ as
+  arguments.
+
+- Variable: magit-refresh-args
+
+  The list of arguments used by ~magit-refresh-function~ to refresh the
+  current buffer.  ~magit-refresh-function~ is called with these
+  arguments.
+
+  The value is usually set using ~magit-mode-setup~, but in some cases
+  it's also useful to provide commands which can change the value.  For
+  example, the ~magit-diff-refresh-popup~ can be used to change any of
+  the arguments used to display the diff, without having to specify
+  again which differences should be shown.  ~magit-diff-more-context~,
+  ~magit-diff-less-context~, and ~magit-diff-default-context~ change just
+  the ~-U<N>~ argument.  In both case this is done by changing the value
+  of this variable and then calling this ~magit-refresh-function~.
+
+** Conventions
+*** Confirmation and completion
+
+Dangerous operations that may lead to data loss have to be confirmed
+by default.  With a multi-section selection, this is done using
+questions that can be answered with "yes" or "no".  When the region isn't
+active, or if it doesn't constitute a valid section selection, then
+such commands instead read a single item in the minibuffer.  When the
+value of the current section is among the possible choices, then that
+is presented as default choice.  To confirm the action on a single
+item, the user has to answer ~RET~ (instead of "yes"), and to abort, ~C-g~
+(instead of "no").  But alternatively the user may also select another
+item, just like if the command had been invoked with no suitable
+section at point at all.
+
+*** Theming Faces
+
+The default theme uses blue for local branches, green for remote
+branches, and goldenrod (brownish yellow) for tags.  When creating a
+new theme, you should probably follow that example.  If your theme
+already uses other colors, then stick to that.
+
+In older releases these reference faces used to have a background
+color and a box around them.  The basic default faces no longer do so,
+to make Magit buffers much less noisy, and you should follow that
+example at least with regards to boxes.  (Boxes were used in the past
+to work around a conflict between the highlighting overlay and text
+property backgrounds.  That's no longer necessary because highlighting no
+longer causes other background colors to disappear.)  Alternatively
+you can keep the background color and/or box, but then have to take
+special care to adjust ~magit-branch-current~ accordingly.  By default
+it looks mostly like ~magit-branch-local~, but with a box (by default
+the former is the only face that uses a box, exactly so that it sticks
+out).  If the former also uses a box, then you have to make sure that
+it differs in some other way from the latter.
+
+The most difficult faces to theme are those related to diffs,
+headings, highlighting, and the region.  There are faces that fall
+into all four groups - expect to spend some time getting this right.
+
+The ~region~ face in the default theme, in both the light and dark
+variants, as well as in many other themes, distributed with Emacs or
+by third-parties, is very ugly.  It is common to use a background
+color that really sticks out, which is ugly but if that were the only
+problem then it would be acceptable.  Unfortunately many themes also
+set the foreground color, which ensures that all text within the
+region is readable.  Without doing that there might be cases where
+some foreground color is too close to the region background color to
+still be readable.  But it also means that text within the region
+loses all syntax highlighting.
+
+I consider the work that went into getting the ~region~ face right to be
+a good indicator for the general quality of a theme.  My
+recommendation for the ~region~ face is this: use a background color
+slightly different from the background color of the ~default~ face, and
+do not set the foreground color at all.  So for a light theme you
+might use a light (possibly tinted) gray as the background color of
+~default~ and a somewhat darker gray for the background of ~region~.
+That should usually be enough to not collide with the foreground color
+of any other face.  But if some other faces also set a light gray as
+background color, then you should also make sure it doesn't collide
+with those (in some cases it might be acceptable though).
+
+Magit only uses the ~region~ face when the region is "invalid" by its
+own definition.  In a Magit buffer the region is used to either select
+multiple sibling sections, so that commands which support it act on
+all of these sections instead of just the current section, or to
+select lines within a single hunk section.  In all other cases, the
+section is considered invalid and Magit won't act on it.  But such
+invalid sections happen, either because the user has not moved point
+enough yet to make it valid or because she wants to use a non-magit
+command to act on the region, e.g. ~kill-region~.
+
+So using the regular ~region~ face for invalid sections is a feature.  It
+tells the user that Magit won't be able to act on it.  It's acceptable
+if that face looks a bit odd and even (but less so) if it collides
+with the background colors of section headings and other things that
+have a background color.
+
+Magit highlights the current section.  If a section has subsections,
+then all of them are highlighted.  This is done using faces that have
+"highlight" in their names.  For most sections, ~magit-section-highlight~
+is used for both the body and the heading.  Like the ~region~ face, it
+should only set the background color to something similar to that of
+~default~.  The highlight background color must be different from both
+the ~region~ background color and the ~default~ background color.
+
+For diff related sections Magit uses various faces to
+highlight different parts of the selected section(s).  Note that hunk
+headings, unlike all other section headings, by default have a
+background color, because it is useful to have very visible separators
+between hunks.  That face ~magit-diff-hunk-heading~, should be different
+from both ~magit-diff-hunk-heading-highlight~ and
+~magit-section-highlight~, as well as from ~magit-diff-context~ and
+~magit-diff-context-highlight~.  By default we do that by changing the
+foreground color.  Changing the background color would lead to
+complications, and there are already enough we cannot get around.
+(Also note that it is generally a good idea for section headings to
+always be bold, but only for sections that have subsections).
+
+When there is a valid region selecting diff-related sibling sections,
+i.e. multiple files or hunks, then the bodies of all these sections
+use the respective highlight faces, but additionally the headings
+instead use one of the faces ~magit-diff-file-heading-selection~ or
+~magit-diff-hunk-heading-selection~.  These faces have to be different
+from the regular highlight variants to provide explicit visual
+indication that the region is active.
+
+When theming diff related faces, start by setting the option
+~magit-diff-refine-hunk~ to ~all~.  You might personally prefer to only
+refine the current hunk or not use hunk refinement at all, but some of
+the users of your theme want all hunks to be refined, so you have to
+cater to that.
+
+(Also turn on ~magit-diff-highlight-indentation~,
+~magit-diff-highlight-trailing~, and ~magit-diff-paint-whitespace~; and
+insert some whitespace errors into the code you use for testing.)
+
+For e.g. "added lines" you have to adjust three faces:
+~magit-diff-added~, ~magit-diff-added-highlight~, and
+~smerge-refined-added~.  Make sure that the latter works well with both
+of the former, as well as ~smerge-other~ and ~diff-added~.  Then do the
+same for the removed lines, context lines, lines added by us, and
+lines added by them.  Also make sure the respective added, removed,
+and context faces use approximately the same saturation for both the
+highlighted and unhighlighted variants.  Also make sure the file and
+diff headings work nicely with context lines (e.g. make them look
+different).  Line faces should set both the foreground and the
+background color.  For example, for added lines use two different
+greens.
+
+It's best if the foreground color of both the highlighted and the
+unhighlighted variants are the same, so you will need to have to find
+a color that works well on the highlight and unhighlighted background,
+the refine background, and the highlight context background.  When
+there is an hunk internal region, then the added- and removed-lines
+background color is used only within that region.  Outside the region
+the highlighted context background color is used.  This makes it
+easier to see what is being staged.  With an hunk internal region the
+hunk heading is shown using ~magit-diff-hunk-heading-selection~, and so
+are the thin lines that are added around the lines that fall within
+the region.  The background color of that has to be distinct enough
+from the various other involved background colors.
+
+Nobody said this would be easy.  If your theme restricts itself to a
+certain set of colors, then you should make an exception here.
+Otherwise it would be impossible to make the diffs look good in each
+and every variation.  Actually you might want to just stick to the
+default definitions for these faces.  You have been warned.  Also
+please note that if you do not get this right, this will in some cases
+look to users like bugs in Magit - so please do it right or not at
+all.
+
+* FAQ
+:PROPERTIES:
+:APPENDIX:   t
+:END:
+
+Below you find a list of frequently asked questions.  For a list of
+frequently *and recently* asked questions, i.e. questions that haven't
+made it into the manual yet, see https://github.com/magit/magit/wiki/FAQ.
+
+** Magit is slow
+
+See [[*Performance]].
+
+** I changed several thousand files at once and now Magit is unusable
+
+Magit is *currently* not expected to work under such conditions. It sure
+would be nice if it did, and v2.5 will hopefully be a big step into
+that direction.  But it might take until v3.1 to accomplish fully
+satisfactory performance, because that requires some heavy refactoring.
+
+But for now we recommend you use the command line to complete this one
+commit.  Also see [[*Performance]].
+
+** I am having problems committing
+
+That likely means that Magit is having problems finding an appropriate
+emacsclient executable.  See [[info:with-editor#Configuring With-Editor]]
+and [[info:with-editor#Debugging]].
+
+** I don't like how branching and pushing works
+
+In v2.1 the default behavior of the branch and push commands changed,
+which has taken a few users by surprise and left more unsatisfied.
+The next release, v2.4, will try to address these concerns.
+
+** I cannot install the pre-requisits for Magit v2
+
+An Elpa archive featuring obsolete Magit v1.4.2 and its dependencies
+is available from http://magit.vc/elpa/v1.  But note that v1.4.2 is
+obsolete and no longer maintained.
+
+** I am using an Emacs release older than v24.4
+
+At least Emacs v24.4 is required.  There is no way around it, if you
+want to use Magit v2.
+
+If you own the machine you work on, then consider updating to the
+latest release provided by your distribution.  If it doesn't feature a
+recent enough release, then you will have to use a backport package or
+build Emacs from source.
+
+Installing Emacs from source is quite simple. See the instructions at
+http://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL and
+http://git.savannah.gnu.org/cgit/emacs.git/tree/INSTALL.REPO to get an
+idea of that this involves.  But when you perform the installation
+then use the instructions for the release you are actually installing.
+
+Unfortunately these instructions do not cover the hardest part (which
+is the hardest part exactly because it is not covered there):
+installing the build time dependencies.
+
+For that you'll need to perform a web search and find an appropriate
+tutorial for your distribution.  If you think you should not have had
+to do that yourself, then consider informing me about the resources
+that helped you figure what to do for your specific setup, so that I
+can post a link here.  That way those coming after you have it easier.
+
+An Elpa archive featuring obsolete Magit v1.4.2 and its dependencies
+is available from http://magit.vc/elpa/v1.
+
+** I am using a Git release older than v1.9.4
+
+At least Git v1.9.4 is required.  There is no way around it, if you
+want to use Magit v2.
+
+If you own the machine, then consider updating to the latest release
+provided by your distribution.  If it doesn't feature a recent enough
+release, then you will have to use a backport package or build Git
+from source.
+
+Installing Git from source is quite simple. See the instructions at
+https://github.com/git/git/blob/master/INSTALL to get an idea of that
+this involves.  But when you perform the installation then use the
+instructions for the release you are actually installing.
+
+An Elpa archive featuring obsolete Magit v1.4.2 and its dependencies
+is available from http://magit.vc/elpa/v1.
+
+** I am using MS Windows and cannot push with Magit
+
+It's almost certain that Magit is only incidental to this issue.  It
+is much more likely that this is a configuration issue, even if you
+can push on the command line.
+
+Detailed setup instructions can be found at
+https://github.com/magit/magit/wiki/Pushing-with-Magit-from-Windows.
+
+** How to install the gitman info manual?
+
+Git's manpages can be exported as an info manual called ~gitman~.
+Magit's own info manual links to nodes in that manual instead of the
+actual manpages because texinfo sadly doesn't support linking to
+manpages.
+
+Unfortunately many distributions do not install the ~gitman~ manual by
+default.  Some distributions may provide a separate package containing
+the info manual.  Please let me know the name of that package for your
+distribution, so that I can mention here.
+
+If the distribution you are using does not offer a package that
+contains the ~gitman~ manual, then you have to install it manually.
+Clone Git's own Git repository, checkout the tag corresponding to the
+Git release you have installed, and follow the instructions in
+~INSTALL~.  The relevant make targets are ~info~ and ~install-info~.
+
+Alternatively you may add this advice to your ~init.el~ file.
+
+#+BEGIN_SRC emacs-lisp
+  (defadvice Info-follow-nearest-node (around gitman activate)
+    "When encountering a cross reference to the `gitman' info
+  manual, then instead of following that cross reference show
+  the actual manpage using the function `man'."
+    (let ((node (Info-get-token
+                 (point) "\\*note[ \n\t]+"
+                 "\\*note[ \n\t]+\\([^:]*\\):\\(:\\|[ \n\t]*(\\)?")))
+      (if (and node (string-match "^(gitman)\\(.+\\)" node))
+          (progn (require 'man)
+                 (man (match-string 1 node)))
+        ad-do-it)))
+#+END_SRC
+
+Or if you are using MS Windows and ~man~ is not available, use this
+variation with used the Emacs Lisp implementation provided by the
+~woman~ package.
+
+#+BEGIN_SRC emacs-lisp
+  (defadvice Info-follow-nearest-node (around gitman activate)
+    "When encountering a cross reference to the `gitman' info
+  manual, then instead of following that cross reference show
+  the actual manpage using the function `woman'."
+    (let ((node (Info-get-token
+                 (point) "\\*note[ \n\t]+"
+                 "\\*note[ \n\t]+\\([^:]*\\):\\(:\\|[ \n\t]*(\\)?")))
+      (if (and node (string-match "^(gitman)\\(.+\\)" node))
+          (progn (require 'woman)
+                 (woman (match-string 1 node)))
+        ad-do-it)))
+#+END_SRC
+
+Did I mention that texinfo cross reference are just awful?  (This is
+just one of many issues.)
+
+** How can I show Git's output?
+
+To show the output of recently run git commands, press ~$~ (or, if that
+isn't available, ~M-x magit-process-buffer~).  This will show a buffer
+containing a section per git invocation; as always press ~TAB~ to expand
+or collapse them.
+
+By default git's output is only inserted into the process buffer if it
+is run for side-effects.  When the output is consumed in some way then
+also inserting it into the process buffer would be to expensive.  For
+debugging purposes it's possible to do so anyway by setting
+~magit-git-debug~ to ~t~.
+
+** Expanding a file to show the diff causes it to disappear
+
+This is probably caused by a change of a ~diff.*~ Git variable.  You
+probably set that variable for a reason, and should therefore
+only undo that setting in Magit by customizing
+~magit-git-global-arguments~.
+
+** Point is wrong in the COMMIT_EDITMSG buffer
+
+Neither Magit nor `git-commit` fiddle with point in the buffer used to
+write commit messages, so something else must be doing it.
+
+You have probably globally enabled a mode which does restore point in
+file-visiting buffers.  It might be a bit surprising, but when you
+write a commit message, then you are actually editing a file.
+
+So you have to figure out which package is doing.  ~saveplace~,
+~pointback~, and ~session~ are likely candidates.  These snippets might
+help:
+
+#+BEGIN_SRC emacs-lisp
+  (setq session-name-disable-regexp "\\(?:\\`'\\.git/[A-Z_]+\\'\\)")
+
+  (with-eval-after-load 'pointback
+    (lambda ()
+      (when (or git-commit-mode git-rebase-mode)
+	(pointback-mode -1))))
+#+END_SRC
+
+** Can Magit be used as ediff-version-control-package?
+
+No, it cannot.  For that to work the functions ~ediff-magit-internal~
+and ~ediff-magit-merge-internal~ would have to be implemented, and they
+are not.  These two functions are only used by the three commands
+~ediff-revision~, ~ediff-merge-revisions-with-ancestor~, and
+~ediff-merge-revisions~.
+
+These commands only delegate the task of populating buffers with
+certain revisions to the "internal" functions.  The equally important
+task of determining which revisions are to be compared/merged is not
+delegated.  Instead this is done without any support whatsoever, from
+the version control package/system - meaning that the user has to
+enter the revisions explicitly.  Instead of implementing
+~ediff-magit-internal~ we provide ~magit-ediff-compare~, which handles
+both tasks like it is 2005.
+
+The other commands ~ediff-merge-revisions~ and
+~ediff-merge-revisions-with-ancestor~ are normally not what you want
+when using a modern version control system like Git.  Instead of
+letting the user resolve only those conflicts which Git could not
+resolve on its own, they throw away all work done by Git and then
+expect the user to manually merge all conflicts, including those that
+had already been resolved.  That made sense back in the days when
+version control systems couldn't merge (or so I have been told), but
+not anymore.  Once in a blue moon you might actually want to see all
+conflicts, in which case you *can* use these commands, which then use
+~ediff-vc-merge-internal~.  So we don't actually have to implement
+~ediff-magit-merge-internal~.  Instead we provide the more useful
+command ~magit-ediff-resolve~ which only shows yet-to-be resolved
+conflicts.
+
+** How to show diffs for gpg-encrypted files?
+
+Git supports showing diffs for encrypted files, but has to be told to
+do so.  Since Magit just uses Git to get the diffs, configuring Git
+also affects the diffs displayed inside Magit.
+
+#+BEGIN_SRC shell-script
+  git config --global diff.gpg.textconv "gpg --no-tty --decrypt"
+  echo "*.gpg filter=gpg diff=gpg" > .gitattributes
+#+END_SRC
+
+** Emacs 24.5 hangs when loading Magit
+
+This is actually triggered by loading Tramp.  See
+https://debbugs.gnu.org/cgi/bugreport.cgi?bug=20015 for details. You
+can work around the problem by setting
+~tramp-ssh-controlmaster-options~. Changing your DNS server (e.g. to
+Google's ~8.8.8.8~) may also be sufficient to work around the issue.
+
+* Keystroke Index
+:PROPERTIES:
+:APPENDIX:   t
+:INDEX:      ky
+:COOKIE_DATA: recursive
+:END:
+* Command Index
+:PROPERTIES:
+:APPENDIX:   t
+:INDEX:      cp
+:END:
+* Function Index
+:PROPERTIES:
+:APPENDIX:   t
+:INDEX:      fn
+:END:
+* Variable Index
+:PROPERTIES:
+:APPENDIX:   t
+:INDEX:      vr
+:END:
+
+#  LocalWords:  ARG ARGS CONDITIONs ChangeLog DNS Dired Ediff Ediffing
+#  LocalWords:  Elpa Emacsclient FUNC Flyspell Git Git's Gitk HOOK's
+#  LocalWords:  IDENT Ido Junio LocalWords Magit Magit's Magitian Magitians
+#  LocalWords:  Melpa Propertize REF REF's RET Reflog SPC SYM Spacemacs
+#  LocalWords:  Submodules TODO TYPEs Theming Unpulled Unpushed Unstaged
+#  LocalWords:  Untracked WORKTREE Wip ack args async autoloads autosaving
+#  LocalWords:  autosquash backport basename branchref builtin
+#  LocalWords:  cdr changelog committer config customizable diff's diffstat
+#  LocalWords:  dwim ediff ediffing editmsg emacsclient filename fixup
+#  LocalWords:  flyspell func git's gitk gitman gitmodule gitmodules goto
+#  LocalWords:  gpg gui ident ido init inserter inserters keymap keymaps
+#  LocalWords:  logfile magit maildir manpage manpages minibuffer multi mv
+#  LocalWords:  namespace newbase nocommit notesRef popup popups posix prev
+#  LocalWords:  propertize rebase rebased rebasing reflog repo signoff str
+#  LocalWords:  struct subcommand submodule submodule's submodules subprocess
+#  LocalWords:  sym texinfo theming todo topdir un unhighlighted unpulled
+#  LocalWords:  unpushed unstage unstaged unstages unstaging untracked url
+#  LocalWords:  versa whitespace wip workflow worktree wtree
diff --git a/Documentation/with-editor.org b/Documentation/with-editor.org
new file mode 100644
index 0000000..53f06c6
--- /dev/null
+++ b/Documentation/with-editor.org
@@ -0,0 +1,259 @@
+#+TITLE: With-Editor User Manual
+#+AUTHOR: Jonas Bernoulli
+#+EMAIL: jonas@bernoul.li
+#+DATE: 2015
+#+LANGUAGE: en
+
+#+TEXINFO_DIR_CATEGORY: Emacs
+#+TEXINFO_DIR_TITLE: With-Editor: (with-editor).
+#+TEXINFO_DIR_DESC: Using the Emacsclient as $EDITOR
+#+SUBTITLE: for version 2.3
+
+#+OPTIONS: H:4 num:3 toc:2
+#+STARTUP: indent
+
+* Copying
+:PROPERTIES:
+:COPYING:    t
+:END:
+
+#+BEGIN_TEXINFO
+@ifnottex
+The library @code{with-editor} makes it easy to use the Emacsclient as
+the @code{$EDITOR} of child processes, making sure they know how to call
+home.  For remote processes a substitute is provided, which communicates
+with Emacs on standard output instead of using a socket as the Emacsclient
+does.
+
+This library was written because Magit has to be able to do the above
+to allow the user to edit commit messages gracefully and to edit
+rebase sequences, which wouldn't be possible at all otherwise.
+
+Because other packages can benefit from such functionality, this
+library is made available as a separate package.  It also defines some
+additional functionality which makes it useful even for end-users, who
+don't use Magit or another package which uses it internally.
+@end ifnottex
+
+@quotation
+Copyright (C) 2015 Jonas Bernoulli <jonas@@bernoul.li>
+
+You can redistribute this document and/or modify it under the terms
+of the GNU General Public License as published by the Free Software
+Foundation, either version 3 of the License, or (at your option) any
+later version.
+
+This document is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+@end quotation
+#+END_TEXINFO
+
+* Using the With-Editor package
+
+The ~With-Editor~ package is used internally by Magit when editing
+commit messages and rebase sequences.  It also provides some commands
+and features which are useful by themselves, even if you don't use
+Magit.
+
+For information about using this library in you own package, see
+[[*Using With-Editor as a library]].
+
+** Configuring With-Editor
+
+With-Editor tries very hard to locate a suitable emacsclient
+executable, so ideally you should never have to customize the option
+~with-editor-emacsclient-executable~.  When it fails to do so, then the
+most likely reason is that someone found yet another way to package
+Emacs (most likely on OS X) without putting the executable on ~$PATH~,
+and we have to add another kludge to find it anyway.
+
+- User Option: with-editor-emacsclient-executable
+
+  The emacsclient executable used as the editor by child process of
+  this Emacs instance.  By using this executable, child processes can
+  call home to their parent process.
+
+  This option is automatically set at startup by looking in ~exec-path~,
+  and other places where the executable could be installed, to find
+  the emacsclient executable most suitable for the current emacs
+  instance.
+
+  You should *not* customize this option permanently.  If you have to do
+  it, then you should consider that a temporary kludge and inform the
+  Magit maintainer as described in [[*Debugging][Debugging]].
+
+  If With-Editor fails to find a suitable emacsclient on you system,
+  then this should be fixed for all users at once, by teaching
+  ~with-editor-locate-emacsclient~ how to so on your system and system
+  like yours. Doing it this way has the advantage, that you won't have
+  do it again every time you update Emacs, and that other users who
+  have installed Emacs the same way as you have, won't have to go
+  through the same trouble.
+
+  Note that there also is a nuclear option; setting this variable to
+  ~nil~ causes the "sleeping editor" described below to be used even for
+  local child processes.  Obviously we don't recommend that you use
+  this except in "emergencies", i.e. before we had a change to add a
+  kludge appropriate for you setup.
+
+- Function: with-editor-locate-emacsclient
+
+  The function used to set the initial value of the option
+  ~with-editor-emacsclient-executable~.  There's a lot of voodoo here.
+
+The emacsclient cannot be used when using Tramp to run a process on a
+remote machine.  (Theoretically it could, but that would be hard to
+setup, very fragile, and rather insecure).
+
+With-Editor provides an alternative "editor" which can be used by
+remote processes in much the same way as local processes use an
+emacsclient executable.  This alternative is known as the "sleeping
+editor" because it is implemented as a shell script which sleeps until
+it receives a signal.
+
+- User Option: with-editor-sleeping-editor
+
+  The sleeping editor is a shell script used as the editor of child
+  processes when the emacsclient executable cannot be used.
+
+  This fallback is used for asynchronous process started inside the
+  macro ~with-editor~, when the process runs on a remote machine or for
+  local processes when ~with-editor-emacsclient-executable~ is ~nil~.
+
+  Where the latter uses a socket to communicate with Emacs' server,
+  this substitute prints edit requests to its standard output on
+  which a process filter listens for such requests.  As such it is
+  not a complete substitute for a proper Emacsclient, it can only
+  be used as ~$EDITOR~ of child process of the current Emacs instance.
+
+  It is unlikely that you should ever have to customize this option.
+
+** Using With-Editor commands
+
+This section describes how to use the ~with-editor~ library /outside/ of
+Magit.  You don't need to know any of this just to create commits
+using Magit.
+
+The commands ~with-editor-async-shell-command~ and
+~with-editor-shell-command~ are intended as drop in replacements for
+~async-shell-command~ and ~shell-command~.  They automatically export
+~$EDITOR~ making sure the executed command uses the current Emacs
+instance as "the editor".  With a prefix argument these commands
+prompt for an alternative environment variable such as ~$GIT_EDITOR~.
+
+- Command: with-editor-async-shell-command
+
+  Like ~async-shell-command~, but the command is run with the current
+  Emacs instance exported as ~$EDITOR~.
+
+- Command: with-editor-shell-command
+
+  Like ~async-shell-command~, but the command is run with the current
+  Emacs instance exported as ~$EDITOR~.  This only has an effect if
+  the command is run asynchronously, i.e. when the command ends
+  with ~&~.
+
+To always use these variants add this to you init file:
+
+#+BEGIN_SRC emacs-lisp
+  (define-key (current-global-map)
+    [remap async-shell-command] 'with-editor-async-shell-command)
+  (define-key (current-global-map)
+    [remap shell-command] 'with-editor-shell-command)
+#+END_SRC
+
+Alternatively use the global ~shell-command-with-editor-mode~.
+
+- Variable: shell-command-with-editor-mode
+
+  When this mode is active, then ~$EDITOR~ is exported whenever
+  ultimately ~shell-command~ is called to asynchronously run some shell
+  command.  This affects most variants of that command, whether they
+  are defined in Emacs or in some third-party package.
+
+The command ~with-editor-export-editor~ exports ~$EDITOR~ or
+another such environment variable in ~shell-mode~, ~term-mode~ and
+~eshell-mode~ buffers.  Use this Emacs command before executing a
+shell command which needs the editor set, or always arrange for the
+current Emacs instance to be used as editor by adding it to the
+appropriate mode hooks:
+
+#+BEGIN_SRC emacs-lisp
+  (add-hook 'shell-mode-hook  'with-editor-export-editor)
+  (add-hook 'term-mode-hook   'with-editor-export-editor)
+  (add-hook 'eshell-mode-hook 'with-editor-export-editor)
+#+END_SRC
+
+Some variants of this function exist; these two forms are equivalent:
+
+#+BEGIN_SRC emacs-lisp
+  (add-hook 'shell-mode-hook
+            (apply-partially 'with-editor-export-editor "GIT_EDITOR"))
+  (add-hook 'shell-mode-hook 'with-editor-export-git-editor)
+#+END_SRC
+
+- Command: with-editor-export-editor
+
+  When invoked in a ~shell-mode~, ~term-mode~, or ~eshell-mode~ buffer, this
+  command teaches shell commands to use the current Emacs instance as
+  the editor, by exporting ~$EDITOR~.
+
+- Command: with-editor-export-git-editor
+
+  Like ~with-editor-export-editor~ but exports ~$GIT_EDITOR~.
+
+- Command: with-editor-export-hg-editor
+
+  Like ~with-editor-export-editor~ but exports ~$HG_EDITOR~.
+
+* Using With-Editor as a library
+
+This section describes how to use the =with-editor= library /outside/ of
+Magit to teach another package how to have its child processes call
+home, just like Magit does.  You don't need to know any of this just
+to create commits using Magit.  You can also ignore this if you use
+~with-editor~ outside of Magit, but only as an end-user.
+
+For information about interactive use and options which affect both
+interactive and non-interactive use, see [[*Using the With-Editor
+package]].
+
+- Macro: with-editor &rest body
+
+  This macro arranges for the emacsclient or the sleeping editor to be
+  used as the editor of child processes, effectively teaching them to
+  call home to the current emacs instance when they require that the
+  user edits a file.
+
+  This is essentially done by establishing a local binding for
+  ~process-environment~ and changing the value of the ~$EDITOR~
+  environment variable.  This affects all processes started by forms
+  inside BODY.
+
+- Function: with-editor-set-process-filter process filter
+
+  This function is like ~set-process-filter~ but ensures that adding the
+  new FILTER does not remove the ~with-editor-process-filter~.  This is
+  done by wrapping the two filter functions using a lambda, which
+  becomes the actual filter.  It calls ~with-editor-process-filter~
+  first, passing ~t~ as NO-STANDARD-FILTER.  Then it calls FILTER.
+
+* Debugging
+
+With-Editor tries very hard to locate a suitable emacsclient
+executable, and then sets option ~with-editor-emacsclient-executable~
+accordingly.  In very rare cases this fails.  When it does fail, then
+the most likely reason is that someone found yet another way to
+package Emacs (most likely on OS X) without putting the executable on
+~$PATH~, and we have to add another kludge to find it anyway.
+
+If you are having problems using ~with-editor~, e.g. you cannot commit
+in Magit, then please open a new issue at
+https://github.com/magit/magit/issues and provide information about
+your Emacs installation.  Most importantly how did you install Emacs
+and what is the output of ~M-x with-editor-debug~?
+
+#  LocalWords:  Emacsclient LocalWords Magit async emacs emacsclient
+#  LocalWords:  hg init rebase startup
diff --git a/t/magit-tests.el b/t/magit-tests.el
new file mode 100644
index 0000000..2f7b82b
--- /dev/null
+++ b/t/magit-tests.el
@@ -0,0 +1,263 @@
+;;; magit-tests.el --- tests for Magit
+
+;; Copyright (C) 2011-2015  The Magit Project Contributors
+;;
+;; License: GPLv3
+
+;;; Code:
+
+(require 'cl-lib)
+(require 'dash)
+(require 'ert)
+
+(require 'magit)
+
+(defmacro magit-with-test-directory (&rest body)
+  (declare (indent 0) (debug t))
+  (let ((dir (make-symbol "dir")))
+    `(let ((,dir (file-name-as-directory (make-temp-file "magit-" t)))
+           (process-environment process-environment))
+       (setenv "GIT_AUTHOR_NAME" "A U Thor")
+       (setenv "GIT_AUTHOR_EMAIL" "a.u.thor@example.com")
+       (condition-case err
+           (cl-letf (((symbol-function #'message) (lambda (&rest _))))
+             (let ((default-directory ,dir))
+               ,@body))
+         (error (message "Keeping test directory:\n  %s" ,dir)
+                (signal (car err) (cdr err))))
+       (delete-directory ,dir t))))
+
+(defmacro magit-with-test-repository (&rest body)
+  (declare (indent 0) (debug t))
+  `(magit-with-test-directory (magit-git "init" ".") ,@body))
+
+;;; Git
+
+(ert-deftest magit--with-safe-default-directory ()
+  (magit-with-test-directory
+    (let ((find-file-visit-truename nil))
+      (should (equal (magit-toplevel "repo/")
+                     (magit-toplevel (expand-file-name "repo/"))))
+      (should (equal (magit-toplevel "repo")
+                     (magit-toplevel (expand-file-name "repo/")))))))
+
+(ert-deftest magit-toplevel:basic ()
+  (let ((find-file-visit-truename nil))
+    (magit-with-test-directory
+      (magit-git "init" "repo")
+      (magit-test-magit-toplevel)
+      (should (equal (magit-toplevel   "repo/.git/")
+                     (expand-file-name "repo/")))
+      (should (equal (magit-toplevel   "repo/.git/objects/")
+                     (expand-file-name "repo/")))
+      (should (equal (magit-toplevel   "repo-link/.git/")
+                     (expand-file-name "repo-link/")))
+      (should (equal (magit-toplevel   "repo-link/.git/objects/")
+                     ;; We could theoretically return "repo-link/"
+                     ;; here by going up until `--git-dir' gives us
+                     ;; "." .  But that would be a bit risky and Magit
+                     ;; never goes there anyway, so it's not worth it.
+                     ;; But in the doc-string we say we cannot do it.
+                     (expand-file-name "repo/"))))))
+
+(ert-deftest magit-toplevel:tramp ()
+  (let ((find-file-visit-truename nil))
+    (magit-with-test-directory
+      (setq default-directory
+            (concat (format "/sudo:%s@localhost:" (user-login-name))
+                    default-directory))
+      (magit-git "init" "repo")
+      (magit-test-magit-toplevel)
+      (should (equal (magit-toplevel   "repo/.git/")
+                     (expand-file-name "repo/")))
+      (should (equal (magit-toplevel   "repo/.git/objects/")
+                     (expand-file-name "repo/")))
+      (should (equal (magit-toplevel   "repo-link/.git/")
+                     (expand-file-name "repo-link/")))
+      (should (equal (magit-toplevel   "repo-link/.git/objects/")
+                     (expand-file-name "repo/"))))))
+
+(ert-deftest magit-toplevel:submodule ()
+  (let ((find-file-visit-truename nil))
+    (magit-with-test-directory
+      (magit-git "init" "remote")
+      (let ((default-directory (expand-file-name "remote/")))
+        (magit-git "commit" "-m" "init" "--allow-empty"))
+      (magit-git "init" "super")
+      (setq default-directory (expand-file-name "super/"))
+      (magit-git "submodule" "add" "../remote" "repo/")
+      (magit-test-magit-toplevel)
+      (should (equal (magit-toplevel   ".git/modules/repo/")
+                     (expand-file-name "repo/")))
+      (should (equal (magit-toplevel   ".git/modules/repo/objects/")
+                     (expand-file-name "repo/"))))))
+
+(defun magit-test-magit-toplevel ()
+  ;; repo
+  (make-directory "repo/subdir/subsubdir" t)
+  (should (equal (magit-toplevel   "repo/")
+                 (expand-file-name "repo/")))
+  (should (equal (magit-toplevel   "repo/")
+                 (expand-file-name "repo/")))
+  (should (equal (magit-toplevel   "repo/subdir/")
+                 (expand-file-name "repo/")))
+  (should (equal (magit-toplevel   "repo/subdir/subsubdir/")
+                 (expand-file-name "repo/")))
+  ;; repo-link
+  (make-symbolic-link "repo" "repo-link")
+  (should (equal (magit-toplevel   "repo-link/")
+                 (expand-file-name "repo-link/")))
+  (should (equal (magit-toplevel   "repo-link/subdir/")
+                 (expand-file-name "repo-link/")))
+  (should (equal (magit-toplevel   "repo-link/subdir/subsubdir/")
+                 (expand-file-name "repo-link/")))
+  ;; *subdir-link
+  (make-symbolic-link "repo/subdir"           "subdir-link")
+  (make-symbolic-link "repo/subdir/subsubdir" "subsubdir-link")
+  (should (equal (magit-toplevel   "subdir-link/")
+                 (expand-file-name "repo/")))
+  (should (equal (magit-toplevel   "subdir-link/subsubdir/")
+                 (expand-file-name "repo/")))
+  (should (equal (magit-toplevel   "subsubdir-link")
+                 (expand-file-name "repo/")))
+  ;; subdir-link-indirect
+  (make-symbolic-link "subdir-link" "subdir-link-indirect")
+  (should (equal (magit-toplevel   "subdir-link-indirect")
+                 (expand-file-name "repo/")))
+  ;; wrap/*link
+  (magit-git "init" "wrap")
+  (make-symbolic-link "../repo"                  "wrap/repo-link")
+  (make-symbolic-link "../repo/subdir"           "wrap/subdir-link")
+  (make-symbolic-link "../repo/subdir/subsubdir" "wrap/subsubdir-link")
+  (should (equal (magit-toplevel   "wrap/repo-link/")
+                 (expand-file-name "wrap/repo-link/")))
+  (should (equal (magit-toplevel   "wrap/subdir-link")
+                 (expand-file-name "repo/")))
+  (should (equal (magit-toplevel   "wrap/subsubdir-link")
+                 (expand-file-name "repo/"))))
+
+(ert-deftest magit-get-boolean ()
+  (magit-with-test-repository
+    (magit-git "config" "a.b" "true")
+    (should     (magit-get-boolean "a.b"))
+    (should     (magit-get-boolean "a" "b"))
+    (magit-git "config" "a.b" "false")
+    (should-not (magit-get-boolean "a.b"))
+    (should-not (magit-get-boolean "a" "b"))))
+
+(ert-deftest magit-get-{current|next}-tag ()
+  (magit-with-test-repository
+    (magit-git "commit" "-m" "1" "--allow-empty")
+    (should (equal (magit-get-current-tag) nil))
+    (should (equal (magit-get-next-tag)    nil))
+    (magit-git "tag" "1")
+    (should (equal (magit-get-current-tag) "1"))
+    (should (equal (magit-get-next-tag)    nil))
+    (magit-git "commit" "-m" "2" "--allow-empty")
+    (magit-git "tag" "2")
+    (should (equal (magit-get-current-tag) "2"))
+    (should (equal (magit-get-next-tag)    nil))
+    (magit-git "commit" "-m" "3" "--allow-empty")
+    (should (equal (magit-get-current-tag) "2"))
+    (should (equal (magit-get-next-tag)    nil))
+    (magit-git "commit" "-m" "4" "--allow-empty")
+    (magit-git "tag" "4")
+    (magit-git "reset" "HEAD~")
+    (should (equal (magit-get-current-tag) "2"))
+    (should (equal (magit-get-next-tag)    "4"))))
+
+(ert-deftest magit-list-{|local-|remote-}branch-names ()
+  (magit-with-test-repository
+    (magit-git "commit" "-m" "init" "--allow-empty")
+    (magit-git "update-ref" "refs/remotes/foobar/master" "master")
+    (magit-git "update-ref" "refs/remotes/origin/master" "master")
+    (should (equal (magit-list-branch-names)
+                   (list "master" "foobar/master" "origin/master")))
+    (should (equal (magit-list-local-branch-names)
+                   (list "master")))
+    (should (equal (magit-list-remote-branch-names)
+                   (list "foobar/master" "origin/master")))
+    (should (equal (magit-list-remote-branch-names "origin")
+                   (list "origin/master")))
+    (should (equal (magit-list-remote-branch-names "origin" t)
+                   (list "master")))))
+
+(ert-deftest magit-process:match-prompt-nil-when-no-match ()
+  (should (null (magit-process-match-prompt '("^foo: ?$") "bar: "))))
+
+(ert-deftest magit-process:match-prompt-non-nil-when-match ()
+  (should (magit-process-match-prompt '("^foo: ?$") "foo: ")))
+
+(ert-deftest magit-process:match-prompt-match-non-first-prompt ()
+  (should (magit-process-match-prompt '("^bar: ?$ " "^foo: ?$") "foo: ")))
+
+(ert-deftest magit-process:match-prompt-suffixes-prompt ()
+  (let ((prompts '("^foo: ?$")))
+    (should (equal (magit-process-match-prompt prompts "foo:")  "foo: "))
+    (should (equal (magit-process-match-prompt prompts "foo: ") "foo: "))))
+
+(ert-deftest magit-process:match-prompt-preserves-match-group ()
+  (let* ((prompts '("^foo '\\(?99:.*\\)': ?$"))
+         (prompt (magit-process-match-prompt prompts "foo 'bar':")))
+    (should (equal prompt "foo 'bar': "))
+    (should (equal (match-string 99 "foo 'bar':") "bar"))))
+
+(ert-deftest magit-process:password-prompt ()
+  (let ((magit-process-find-password-functions
+         (list (lambda (host) (when (string= host "www.host.com") "mypasswd")))))
+    (cl-letf (((symbol-function 'process-send-string)
+               (lambda (process string) string)))
+      (should (string-equal (magit-process-password-prompt
+                             nil "Password for 'www.host.com':")
+                            "mypasswd\n")))))
+
+;;; Status
+
+(defun magit-test-get-section (type info)
+  (magit-status-internal default-directory)
+  (--first (equal (magit-section-value it) info)
+           (magit-section-children
+            (magit-get-section `((,type) (status))))))
+
+(ert-deftest magit-status:file-sections ()
+  (magit-with-test-repository
+    (cl-flet ((modify (file) (with-temp-file file
+                               (insert (make-temp-name "content")))))
+      (modify "file")
+      (modify "file with space")
+      (modify "file with äöüéλ")
+      (should (magit-test-get-section 'untracked "file"))
+      (should (magit-test-get-section 'untracked "file with space"))
+      (should (magit-test-get-section 'untracked "file with äöüéλ"))
+      (magit-stage-modified t)
+      (should (magit-test-get-section 'staged "file"))
+      (should (magit-test-get-section 'staged "file with space"))
+      (should (magit-test-get-section 'staged "file with äöüéλ"))
+      (magit-git "add" ".")
+      (modify "file")
+      (modify "file with space")
+      (modify "file with äöüéλ")
+      (should (magit-test-get-section 'unstaged "file"))
+      (should (magit-test-get-section 'unstaged "file with space"))
+      (should (magit-test-get-section 'unstaged "file with äöüéλ")))))
+
+(ert-deftest magit-status:log-sections ()
+  (magit-with-test-repository
+    (magit-git "commit" "-m" "common" "--allow-empty")
+    (magit-git "commit" "-m" "unpulled" "--allow-empty")
+    (magit-git "remote" "add" "origin" "/origin")
+    (magit-git "update-ref" "refs/remotes/origin/master" "master")
+    (magit-git "branch" "--set-upstream-to=origin/master")
+    (magit-git "reset" "--hard" "HEAD~")
+    (magit-git "commit" "-m" "unpushed" "--allow-empty")
+    (should (magit-test-get-section 'unpulled
+                                    (magit-rev-parse "--short" "origin/master")))
+    (should (magit-test-get-section 'unpushed
+                                    (magit-rev-parse "--short" "master")))))
+
+;;; magit-tests.el ends soon
+(provide 'magit-tests)
+;; Local Variables:
+;; indent-tabs-mode: nil
+;; End:
+;;; magit-tests.el ends here
